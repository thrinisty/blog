<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Thrinisty&apos;s Blog</title><description>New One</description><link>https://thrinisty.github.io/</link><language>en</language><item><title>JavaWeb笔记(JSP)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jsp/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jsp/</guid><description>JSP</description><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;JSP&lt;/h2&gt;
&lt;h3&gt;初步介绍&lt;/h3&gt;
&lt;p&gt;JSP全称为Java Server Pages，java的服务器页面，主要作用为替Servlet程序回传html页面的数据，因为Servlet程序回传html页面数据是一件非常繁琐的事情，开发成本和维护成本都很高&lt;/p&gt;
&lt;p&gt;我们在使用Servlet程序回传html需要通过回传流需要一行一行地将html页面的数据传回，要会传完整一个html页面需要大量的代码使用write写入返回到客户端地浏览器&lt;/p&gt;
&lt;p&gt;以下是一个代码示例，可见非常的繁琐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test&quot;)
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //通过响应的回传流回传html页面数据
        // 设置响应内容类型为HTML
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 获取响应输出流
        PrintWriter out = resp.getWriter();

        // 构建HTML页面内容
        out.println(&quot;&amp;lt;!DOCTYPE html&amp;gt;&quot;);
        out.println(&quot;&amp;lt;html&amp;gt;&quot;);
        out.println(&quot;&amp;lt;head&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;title&amp;gt;Servlet生成的页面&amp;lt;/title&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;style&amp;gt;&quot;);
        out.println(&quot;        body { font-family: Arial, sans-serif; margin: 40px; }&quot;);
        out.println(&quot;        h1 { color: #3366cc; }&quot;);
        out.println(&quot;    &amp;lt;/style&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/head&amp;gt;&quot;);
        out.println(&quot;&amp;lt;body&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;h1&amp;gt;这是由TestServlet动态生成的页面&amp;lt;/h1&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;当前时间: &quot; + new java.util.Date() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;请求方法: &quot; + req.getMethod() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;    &amp;lt;p&amp;gt;Servlet路径: &quot; + req.getServletPath() + &quot;&amp;lt;/p&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/body&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/html&amp;gt;&quot;);

        // 关闭输出流
        out.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与此同时JSP可以很好的解决这个问题，代替了Servlet程序回传html页面的数据，注意JSP页面要通过服务器端进行解析，需要先运行Tomcat服务器后才可以显示动态生成出来，而不是像html一样可以直接通过本地的浏览器一样解析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    JSP JSP JSP
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSP页面本质上是一个Servlet程序，当我们第一次访问JSP页面的时候，Tomcat服务器会帮我们将jsp页面翻译为一个java源文件，并且将其编译为class字节码程序&lt;/p&gt;
&lt;p&gt;生成的Servlet继承自HttpJspBase，所以 JSP 本质上就是一个Servlet，生成的Servlet程序生成的html页面也是通过write输出流生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      out.write(&quot;\r\n&quot;);
      out.write(&quot;\r\n&quot;);
      out.write(&quot;&amp;lt;html&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;head&amp;gt;\r\n&quot;);
      out.write(&quot;    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;/head&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;body&amp;gt;\r\n&quot;);
      out.write(&quot;    JSP JSP JSP\r\n&quot;);
      out.write(&quot;&amp;lt;/body&amp;gt;\r\n&quot;);
      out.write(&quot;&amp;lt;/html&amp;gt;\r\n&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;JSP page&lt;/h3&gt;
&lt;p&gt;jsp的page指令可以修改jsp页面中的一些重要属性或者行为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一些常见的可以修改的属性&lt;/p&gt;
&lt;p&gt;language 属性：表示jsp翻译后是什么语言文件，暂时只支持java&lt;/p&gt;
&lt;p&gt;contentType 属性：表示jsp返回的数据类型是什么，也是源码中response.setContentType设置的编码类型（一般都是UTF-8）&lt;/p&gt;
&lt;p&gt;pageEncoding 属性：表示当前jsp页面文件本身的字符集（一般都是UTF-8）&lt;/p&gt;
&lt;p&gt;import 属性：和Java一致，导入包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page import=&quot;java.util&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;autoFlush 属性：设置当out输出流缓冲区满了后，是否自动刷新缓冲区，默认为true&lt;/p&gt;
&lt;p&gt;buffer 属性：设置out输出缓冲区大小，默认为8kb&lt;/p&gt;
&lt;p&gt;errorPage 属性：设置当jsp页面运行出错的时候，会自动跳转的错误页面&lt;/p&gt;
&lt;p&gt;isErrorPage 属性：设置当前jsp页面是否是错误信息页面，默认为false，如果是true可以获取异常信息&lt;/p&gt;
&lt;p&gt;session 属性：设置访问当前jsp页面，是否会创建HttpSession对象，默认是true&lt;/p&gt;
&lt;p&gt;extends 属性：设置jsp翻译出来的java类默认继承谁&lt;/p&gt;
&lt;h3&gt;JSP脚本&lt;/h3&gt;
&lt;h4&gt;声明脚本&lt;/h4&gt;
&lt;p&gt;可以给JSP翻译出来的java类定义属性和方法，甚至是静态代码块和方法，定义的声明会生成到对应的Java源文件和class文件中&lt;/p&gt;
&lt;p&gt;格式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
	Java声明语句
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明类属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    private Integer id;
    private String name;
    private static Map&amp;lt;String,Object&amp;gt; map;
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明static静态代码块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    static {
        map = new HashMap&amp;lt;String,String&amp;gt;();
        map.put(&quot;key1&quot;, &quot;v1&quot;);
        map.put(&quot;key2&quot;, &quot;v2&quot;);
        map.put(&quot;key3&quot;, &quot;v3&quot;);
        map.put(&quot;key4&quot;, &quot;v4&quot;);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明类方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    public int function(){
        return 12;
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%!
    public static class Student{
        private String name = &quot;Jack&quot;;
        private int age = 10;
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;表达式脚本&lt;/h4&gt;
&lt;p&gt;作用：在jsp页面上输出数据&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=表达式%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=12 %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=name %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=&quot;字符串测试&quot; %&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%=map %&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSP JSP JSP 12
TestString
字符串测试
{key1=v1, key2=v2, key3=v3, key4=v4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;p&gt;所有的表达式脚本都会被翻译到_jspService方法中&lt;/p&gt;
&lt;p&gt;所有的表达式脚本都会被翻译成为out.print输出到页面上&lt;/p&gt;
&lt;p&gt;由于表达式脚本翻译的内容都在_jspService方法中，所以jspService方法中的对象都可以直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%=request.getParameter(&quot;name&quot;)%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;http://localhost:8080/JSPTest/Test.jsp?name=1234&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1234
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表达式内容不可以 ; 结束&lt;/p&gt;
&lt;h4&gt;代码脚本&lt;/h4&gt;
&lt;p&gt;作用：可以在jsp页面中，编写我们自己需要的功能（java语句）&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
	java语句
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    if(i == 12) {
        System.out.println(i);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码脚本特点&lt;/p&gt;
&lt;p&gt;1.代码脚本翻译之后都在_jspServive方法中&lt;/p&gt;
&lt;p&gt;2.代码脚本中可以直接使用_jspService方法中的对象&lt;/p&gt;
&lt;p&gt;3.代码脚本还可以由多个代码脚本块组合完成一个Java语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    for (int j = 0; j &amp;lt; i; j++) {   
%&amp;gt;
&amp;lt;%
        System.out.println(&quot;j&quot;);
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.代码脚本还可以与表达式脚本组合使用在JSP页面打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
    int i = 12;
    for (int j = 0; j &amp;lt; i; j++) {
%&amp;gt;
    &amp;lt;%=j%&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;%
    }
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也不建议这么使用，太过于混乱了，现在基本上都是直接使用框架了，这么些可维护性差&lt;/p&gt;
&lt;h4&gt;JSP注释&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--html注释--&amp;gt;
    &amp;lt;%
        //Java注释
        /*会被翻译到Java源代码中*/
    %&amp;gt;
    &amp;lt;%--JSP注释（时JSP中真正的注释）--%&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;内置对象&lt;/h3&gt;
&lt;p&gt;JSP中的内置对象，指的是Tomcat在翻译JSP页面为Servlet源代码后，内部提供的九大对象称为内置对象&lt;/p&gt;
&lt;p&gt;request：请求对象&lt;/p&gt;
&lt;p&gt;response：响应对象&lt;/p&gt;
&lt;p&gt;pageContext：jsp上下文对象&lt;/p&gt;
&lt;p&gt;session：会话对象&lt;/p&gt;
&lt;p&gt;application：ServletContext对象&lt;/p&gt;
&lt;p&gt;config：ServletConfig对象&lt;/p&gt;
&lt;p&gt;out：jsp输出流对象&lt;/p&gt;
&lt;p&gt;page：指向当前jsp的对象&lt;/p&gt;
&lt;p&gt;exception：异常对象（当页面异常isErrorPage开启时创建异常对象）&lt;/p&gt;
&lt;h4&gt;四个域对象&lt;/h4&gt;
&lt;p&gt;pageContext（PageContextImpl类）当前jsp页面范围内有效&lt;/p&gt;
&lt;p&gt;request（HttpServletRequest类）一次请求内有效（请求转发不会丢失request数据）&lt;/p&gt;
&lt;p&gt;session（HttpSession类）一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）&lt;/p&gt;
&lt;p&gt;application（ServletContext类）整个Web工程范围内都有效（Web停止后销毁）&lt;/p&gt;
&lt;p&gt;域对象是可以像Map一样存取数据的对象，四个域对象的功能一样，不同的是特们对于数据的存取范围&lt;/p&gt;
&lt;p&gt;我在这里遇到了pageContext无法解析set/getAttribute方法，应该是缺少 JSP API 依赖导致的&lt;/p&gt;
&lt;p&gt;你的依赖中没有明确包含 &lt;code&gt;jsp-api&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这会导致 IDEA 无法解析 &lt;code&gt;pageContext&lt;/code&gt; 的方法&lt;/p&gt;
&lt;p&gt;添加如下的依赖配置即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.servlet.jsp-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;JSP标题&amp;lt;/h1&amp;gt;
    &amp;lt;%
        pageContext.setAttribute(&quot;key1&quot;, &quot;pageContext&quot;);
        request.setAttribute(&quot;key2&quot;, &quot;Request&quot;);
        session.setAttribute(&quot;key3&quot;, &quot;Session&quot;);
        application.setAttribute(&quot;key4&quot;, &quot;Application&quot;);
    %&amp;gt;
    &amp;lt;%=pageContext.getAttribute(&quot;key1&quot;)%&amp;gt;
    &amp;lt;%=request.getAttribute(&quot;key2&quot;)%&amp;gt;
    &amp;lt;%=session.getAttribute(&quot;key3&quot;)%&amp;gt;
    &amp;lt;%=application.getAttribute(&quot;key4&quot;)%&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然都可以存取顺序，但是有使用优先顺序，最好在使用条件允许下使用小的范围&lt;/p&gt;
&lt;h3&gt;输出的细节&lt;/h3&gt;
&lt;h4&gt;out与getWriter&lt;/h4&gt;
&lt;p&gt;response中表示响应，经常用于设置返回给客户端的内容（输出）&lt;/p&gt;
&lt;p&gt;out也是给用户做输出使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;JSP输出&amp;lt;/h1&amp;gt;
    &amp;lt;%
        response.getWriter().write(&quot;输出一&quot;);
        out.write(&quot;输出二&quot;);
    %&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：我们发现response的write输出在标题的上边，和预期有些不符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/151.png&quot; alt=&quot;151&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSP 引擎先处理模板文本 &lt;code&gt;&amp;lt;h1&amp;gt;JSP输出&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到脚本片段时：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;response.getWriter().write()&lt;/code&gt; 立即输出到客户端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out.write()&lt;/code&gt; 写入缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后 JSP 引擎刷新缓冲区，&lt;code&gt;out.write()&lt;/code&gt; 的内容才真正输出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般在使用中统一使用out输出，避免打乱顺序&lt;/p&gt;
&lt;h4&gt;out.print与out.write&lt;/h4&gt;
&lt;p&gt;print会将内容逐个转为字符再通过write输出，而write输出整形数据会出现问题，会将内容转为字符串（并非单个字符转化）&lt;/p&gt;
&lt;p&gt;所以在实际使用的时候输出数字用print完成（或者直接统一使用print）&lt;/p&gt;
&lt;h3&gt;常用标签&lt;/h3&gt;
&lt;h4&gt;静态包含&lt;/h4&gt;
&lt;p&gt;有的时候我们将一个页面分为数个部分显示，为了保证页面的灵活性，我们可以将单个部分提取出来编写，方便随时替换或者修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    页脚信息&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将页脚信息提取出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;页脚&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    页脚内容(静态包含)&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用jsp页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    &amp;lt;%@ include file=&quot;/foot.jsp&quot;%&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态包含的特点：不会翻译被包含的jsp页面，而是将被包含的jsp页面拷贝到包含的位置输出&lt;/p&gt;
&lt;h4&gt;动态包含&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;常用标签&amp;lt;/h1&amp;gt;
    头部信息&amp;lt;br&amp;gt;
    主体信息&amp;lt;br&amp;gt;
    &amp;lt;jsp:include page=&quot;foot.jsp&quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果上和静态包含效果上差别不大，动态包含会把包含的jsp页面也翻译为java代码，动态包含底层调用了include方法调用被包含的页面进行输出（将被包含的页面的对象给包含页面进行使用）&lt;/p&gt;
&lt;p&gt;工程上一般使用静态代码&lt;/p&gt;
&lt;h4&gt;请求转发&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSP生成的页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;请求转发&amp;lt;/h1&amp;gt;
    &amp;lt;jsp:forward page=&quot;/servlet&quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Listener监听器&lt;/h3&gt;
&lt;p&gt;Listener监听器时JavaWeb的三大组件之一（Servler程序、Filter过滤器、Listener监听器）&lt;/p&gt;
&lt;p&gt;是JavaEE的规范，即接口，作用为监听某种事物的变化，通过回调函数，反馈给客户（程序）做一些处理&lt;/p&gt;
&lt;h4&gt;ServletContextListener&lt;/h4&gt;
&lt;p&gt;可以监听ServletContext对象的创建和销毁（ServletContext对象在Web工程启动的时候创建，在Web工程停止的时候销毁）&lt;/p&gt;
&lt;p&gt;监听到创建和销毁之后都会分别调用ServletContextListener监听器的方法反馈，这两个方法分别是contextInitialized和contextDestroyed，其中传入了ServletContextEvent对象&lt;/p&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;p&gt;1.编写一个类实现ServletContextListener&lt;/p&gt;
&lt;p&gt;2.实现两个回调方法&lt;/p&gt;
&lt;p&gt;3.配置web.xml监听器（配置注解@WebListener）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import java.awt.event.ActionListener;

@WebListener
public class ListenerTest implements ServletContextListener {
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;contextDestroyed&quot;);
    }

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println(&quot;contextInitialized&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两天忙着准备面试+编译原理实验（最恶心的一个）+线性代数考试复习，暂时抽不出时间，等10号之后再开始EL表达式的学习&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(Servlet)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservletrequestservletresponse%E9%87%8D%E5%AE%9A%E5%90%91/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservletrequestservletresponse%E9%87%8D%E5%AE%9A%E5%90%91/</guid><description>ServletRequest，ServletResponse，重定向</description><pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;今天完成Servlet剩余部分的学习，JavaWeb部分的实战项目我就不练了，我打算这一个部分的练手等到学习完开发框架之后做成一整个项目&lt;/p&gt;
&lt;p&gt;今天发现自己的Servlet程序没有办法打印出中文字符，去网络上搜索了以下，回答的都是处理请求头的编码处理，但想想直接打印也是乱码，应该是Tomcat的配置出了问题，以下是解决方式：在Tomcat运行设置里的虚拟机选项填入以下内容（修改运行配置）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Dfile.encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;HttpServletRequest&lt;/h2&gt;
&lt;p&gt;作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法，在doGet和doPost方法中给我们使用，我们可以通过HttpServletRequest对象，获取到所有的请求信息&lt;/p&gt;
&lt;p&gt;http://localhost:8080/ServletTest/test?username=2022302546&amp;amp;password=123455&amp;amp;hobby=cpp&amp;amp;hobby=java&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;getRequestURI&lt;/h4&gt;
&lt;p&gt;获取请求资源路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRequestURI());
///ServletRequests/test
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getRequestURL&lt;/h4&gt;
&lt;p&gt;获取请求的统一资源定位符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRequestURL());
//http://localhost:8080/ServletRequests/test
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getRemoteHost&lt;/h4&gt;
&lt;p&gt;获取客户端的ip地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getRemoteHost());
//0:0:0:0:0:0:0:1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getHeader&lt;/h4&gt;
&lt;p&gt;获取请求头&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getHeader(&quot;Accept-Language&quot;));
//zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 取决你想要访问的头
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getMethod&lt;/h4&gt;
&lt;p&gt;获取请求的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getMethod());
//GET
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getParameter&lt;/h4&gt;
&lt;p&gt;获取请求参数&lt;/p&gt;
&lt;p&gt;我们先加入一个html页面，其中设置一个表单，名称填为18288763320，可以在doGet中通过req参数获取到username参数对应的表单项值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/ServletTest/test&quot; method=&quot;get&quot;&amp;gt;
        名称&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密码&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        爱好
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&amp;gt;C++
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&amp;gt;Java
        &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;python&quot;&amp;gt;python
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(req.getParameter(&quot;username&quot;));
//18288763320
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getParameterValues&lt;/h4&gt;
&lt;p&gt;获取请求的参数（多个值时使用，如使用勾选框的时候）返回一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String[] hobbies = req.getParameterValues(&quot;hobby&quot;);
for (String hobby : hobbies) {
    System.out.print(hobby + &quot; &quot;);
}//cpp java 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setCharacterEncoding&lt;/h4&gt;
&lt;p&gt;在Post请求中没法正确获取到表单中的中文字符（乱码）可通过在doPost中设置字符集解决，注意在打印请求前设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.setCharacterEncoding(&quot;UTF-8&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setAttribute&lt;/h4&gt;
&lt;p&gt;设置域数据&lt;/p&gt;
&lt;h4&gt;getAttribute&lt;/h4&gt;
&lt;p&gt;获取域数据&lt;/p&gt;
&lt;p&gt;和Map集合类似，这里不再过多说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;req.setAttribute(&quot;test&quot;, &quot;test&quot;);
String test = (String)req.getAttribute(&quot;test&quot;);
System.out.println(test);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;转发请求&lt;/h3&gt;
&lt;h4&gt;getRequestDispatcher&lt;/h4&gt;
&lt;p&gt;获取转发请求&lt;/p&gt;
&lt;p&gt;在第一个Servlet程序中完成请求的转发，并填入一个域数据，用以被第二个Servlet程序获取处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test1&quot;)
public class Servlet1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;doGetServlet1&quot;);
        req.setAttribute(&quot;function&quot;, &quot;target&quot;);
        //添加域数据
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/test2&quot;);
        //获取到访问地址
        requestDispatcher.forward(req, resp);
        //访问目标地址，并转发请求req
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个Servlet程序，由于也传入了req访问请求参数，可以获取到其中的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test2&quot;)
public class Servlet2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;doGetServlet2&quot;);
        System.out.println(&quot;获取到了&quot; + req.getAttribute(&quot;function&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转发请求的特点&lt;/h4&gt;
&lt;p&gt;1.浏览器地址栏没有变化&lt;/p&gt;
&lt;p&gt;2.他们是一次请求&lt;/p&gt;
&lt;p&gt;3.可以共享Request域数据&lt;/p&gt;
&lt;p&gt;4.可以转发到WEB-INF目录下（直接通过浏览器地址栏没法访问）&lt;/p&gt;
&lt;h2&gt;base标签&lt;/h2&gt;
&lt;p&gt;我们有如下一个场景，两个页面相互跳转，通过a标签设置链接完成&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;a/b/c.html&quot;&amp;gt;跳转页面&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;http://localhost:8080/ServletTest/Servlet&quot;&amp;gt;通过servlet跳转页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;../../index.html&quot;&amp;gt;跳转回index页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以正常跳转，没有问题，我们现在通过Servlet转发实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;http://localhost:8080/ServletTest/Servlet&quot;&amp;gt;通过servlet跳转页面&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Servlet&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;转发&quot;);
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/a/b/c.html&quot;);
        //获取到访问地址
        requestDispatcher.forward(req, resp);
        //访问目标地址，并转发请求req
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在index页面中可以正常跳转到c.html页面下，但是没有办法跳转回来，因为当前的地址为 http://localhost:8080/ServletTest/Servlet （转发的时候不会跳转地址） 回溯路径是 ../../index.html 而在8080工作路径下没有c.html&lt;/p&gt;
&lt;p&gt;我们这个时候可以使用到base标签：设置当前页面中所有的相对路径工作时，参照哪一个路径进行跳转&lt;/p&gt;
&lt;p&gt;更改c.html 设置base标签，标注在当前c.html跳转时参照 http://localhost:8080/ServletTest/a/b/ 进行跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;base href=&quot;http://localhost:8080/ServletTest/a/b/&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;../../index.html&quot;&amp;gt;跳转回index页面&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就没有问题了，可以正常跳回index页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/149.png&quot; alt=&quot;149&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;HttpServletResponse&lt;/h2&gt;
&lt;p&gt;​	HttpServletResponse类和HttpServletRequest类一样，每一次请求都会创建一个Response对线传递给Servlet程序使用，HttpServletRequest表示请求过来的信息，而HttpServletResponse表示所有响应的信息&lt;/p&gt;
&lt;p&gt;​	如果我们需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置&lt;/p&gt;
&lt;h3&gt;两个输出流&lt;/h3&gt;
&lt;p&gt;二者只能使用其一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/Servlet&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        //设置响应字符集为UTF-8，除此之外还要设置浏览器字符集
        resp.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);
        //设置浏览器字符集
        
        //resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        //同时设置以上的响应和服务器字符集，选其中之一即可（注意设置后再获取流对象）
        
        PrintWriter writer = resp.getWriter();
//        ServletOutputStream outputStream = resp.getOutputStream();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字节流&lt;/h4&gt;
&lt;p&gt;getOutputStream&lt;/p&gt;
&lt;p&gt;常用于下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ServletOutputStream outputStream = resp.getOutputStream();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字符流&lt;/h4&gt;
&lt;p&gt;getWriter&lt;/p&gt;
&lt;p&gt;常用于回传字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PrintWriter writer = resp.getWriter();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;PrintWriter writer = resp.getWriter();
writer.write(&quot;response&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;请求重定向&lt;/h3&gt;
&lt;p&gt;请求重定向：是指客户端给服务器发送请求，然后服务器告诉客户端说，给与新地址以访问（之前的地址可能被废弃）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/150.png&quot; alt=&quot;150&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一个访问的Servlet程序，访问第二个Servlet程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.servlet;

@WebServlet(&quot;/index.html&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setStatus(302);
        resp.setHeader(&quot;Location&quot;, &quot;http://localhost:8080/ServletTest/another&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个Servlet程序，告诉用户新的资源地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.servlet;

@WebServlet(&quot;/another&quot;)
public class Response extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter writer = resp.getWriter();
        writer.write(&quot;服务暂停，可以跳转至新的页面http://localhost:8080/ServletTest/new.html&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;1.浏览器地址发送变化&lt;/p&gt;
&lt;p&gt;2.两次请求&lt;/p&gt;
&lt;p&gt;3.不可以访问Request域数据&lt;/p&gt;
&lt;p&gt;4.不可以访问WEB-INF下资源&lt;/p&gt;
&lt;p&gt;5.可以访问工程外的资源&lt;/p&gt;
&lt;p&gt;或者直接调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/index.html&quot;)
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.sendRedirect(&quot;http://localhost:8080/ServletTest/new.html&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>JavaWeb笔记(Servlet)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservlethttp%E5%8D%8F%E8%AE%AE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0servletservlethttp%E5%8D%8F%E8%AE%AE/</guid><description>Servlet（Servlet，HTTP协议）</description><pubDate>Tue, 06 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;之前Maven没有配置好导致了JavaWeb的环境配置比较困难，去大概了解了一下Maven构建的相关知识，现在可以快速通过坐标导入相关的jar包了，马上开始Servlet的学习&lt;/p&gt;
&lt;h2&gt;Servlet&lt;/h2&gt;
&lt;h3&gt;入门使用&lt;/h3&gt;
&lt;p&gt;我使用的是Maven构建的Servlet程序，不需要web.xml进行注册，只需要使用@WebServlet注解完成绑定即可访问使用&lt;/p&gt;
&lt;p&gt;新建一个类，实现Servlet的接口方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/hello&quot;)//使用该注解可以绑定访问/hello地址的时候调用Servlet服务
public class HelloServlet implements Servlet
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig servletConfig) throws ServletException {

}

@Override
public ServletConfig getServletConfig() {
    return null;
}

@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
	//该方法在调用Servlet服务的时候会被调用
    System.out.println(&quot;Hello Servlet&quot;);
}

@Override
public String getServletInfo() {
    return &quot;&quot;;
}

@Override
public void destroy() {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在Maven构建的Servlet程序中，index.jsp要放在src/main/webapp目录下，才可以被默认访问到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/142.png&quot; alt=&quot;142&quot; /&gt;&lt;/p&gt;
&lt;p&gt;配置完毕的时候，我们运用浏览器访问 http://localhost:8080/ServletTest/hello 即可调用实现servlet接口的实现类中的相关方法&lt;/p&gt;
&lt;h3&gt;运行流程&lt;/h3&gt;
&lt;p&gt;以下是一个调用的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/143.png&quot; alt=&quot;143&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1.执行Servlet构造方法&lt;/p&gt;
&lt;p&gt;2.执行init初始化方法&lt;/p&gt;
&lt;p&gt;3.执行&lt;/p&gt;
&lt;p&gt;4.执行destroy销毁方法&lt;/p&gt;
&lt;p&gt;前两个方法在初次时调用，第二次访问/hello时，只调用service方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create Servlet
init Servlet
Servlet Running
Servlet Running
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sevice方法&lt;/h3&gt;
&lt;p&gt;用一个html页面运用submit提交，跳转到对应的路径下也会被Servlet捕获并且调用相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;http://localhost:8080/ServletTest/hello&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(&quot;Servlet Running&quot;);
    HttpServletRequest Request = (HttpServletRequest) servletRequest;
    String method = Request.getMethod();
    System.out.println(method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过ServletRequest servletRequest的子类型的getMethod方法可以得到请求的类型（Post/Get）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Servlet Running
GET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般而言，我们在处理两种不同的请求类型的时候进行方法化处理，分别调用不同的处理操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(&quot;Servlet Running&quot;);
    HttpServletRequest Request = (HttpServletRequest) servletRequest;
    String method = Request.getMethod();
    switch (method) {
        case &quot;GET&quot;:
            System.out.println(&quot;GET Method&quot;);
            doGet();//处理get请求的方法
            break;
        case &quot;POST&quot;:
            System.out.println(&quot;POST Method&quot;);
            doPost();//处理post请求的方法
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HttpServlet实现&lt;/h3&gt;
&lt;p&gt;在实际的开发中，很少通过实现servlet接口实现servlet程序，而是继承其子类HttpServlet来实现&lt;/p&gt;
&lt;p&gt;1.编写一个类去集成HttpServlet类&lt;/p&gt;
&lt;p&gt;2.根据业务需要重写doGet或者doPost方法&lt;/p&gt;
&lt;p&gt;3.到web.xml配置Servlet程序的访问地址（我通过@WebServlet(&quot;/test&quot;)完成）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/test&quot;)
public class ServletTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;Servlet Get Called&quot;);
        super.doGet(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;Servlet Post Called&quot;);
        super.doPost(req, resp);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;继承关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/144.png&quot; alt=&quot;144&quot; /&gt;&lt;/p&gt;
&lt;p&gt;GenericServlet实现了Servlet接口，并做了一些空实现，持有一个ServletConfig类的引用，并对ServletConfig的使用做一些方法&lt;/p&gt;
&lt;p&gt;HttpServlet抽取类实现了service方法，并实现了请求的分发处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String method = req.getMethod();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而其中调用的doGet和doPost默认抛出异常，不支持请求，我们在实际使用的时候根据需要重写方法实现业务逻辑即可&lt;/p&gt;
&lt;h3&gt;ServletConfig类&lt;/h3&gt;
&lt;h4&gt;注解Servlet&lt;/h4&gt;
&lt;p&gt;首先运用注解设置访问地址以及初始化参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(
        urlPatterns = &quot;/hello&quot;,  // 访问路径
        initParams = {
                @WebInitParam(name = &quot;name&quot;, value = &quot;John&quot;), 
                @WebInitParam(name = &quot;age&quot;, value = &quot;25&quot;)      
        }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从类名来看，是Servlet程序的配置信息类&lt;/p&gt;
&lt;p&gt;Servlet程序和ServletConfig对象都是由Tomcat负责创建，我们负责使用&lt;/p&gt;
&lt;p&gt;Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建的时候，就创建一个ServletConfig对象（其中封装了一些信息）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface ServletConfig {
    String getServletName();
    ServletContext getServletContext();
    String getInitParameter(String var1);
    Enumeration&amp;lt;String&amp;gt; getInitParameterNames();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;三大作用&lt;/h4&gt;
&lt;p&gt;1.可以获取Servlet程序的别名servlet-name的值&lt;/p&gt;
&lt;p&gt;2.获取初始化参数init-param&lt;/p&gt;
&lt;p&gt;3.获取ServletContext对象&lt;/p&gt;
&lt;p&gt;传递初始化参数的init方法，以及ServletConfig的使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig servletConfig) throws ServletException {
    //1.可以获取Servlet程序的别名servlet-name的值
    System.out.println(servletConfig.getServletName());
    //com.servlet.HelloServlet
    //2.获取初始化参数init-param
    System.out.println(servletConfig.getInitParameter(&quot;name&quot;));
    //John
    //3.获取ServletContext对象
    System.out.println(servletConfig.getServletContext());
    //org.apache.catalina.core.ApplicationContextFacade@15f00bcd
    System.out.println(&quot;init Servlet&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意要点&lt;/h4&gt;
&lt;p&gt;HttpServlet在重写init方法的时候需要调用super.init去获取到父类的config类，否则会发生空指针异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    System.out.println(config.getServletName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为HttpServlet的config没有被赋予GenericServlet的config信息，指向为空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ServletContext类&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;p&gt;是一个接口，表示Servlet上下文对象&lt;/p&gt;
&lt;p&gt;一个Web工程，只有一个ServletContext对象实例&lt;/p&gt;
&lt;p&gt;ServletContext是一个域对象（可以像Map一样存取数据的对象，域指的是存取数据的操作范围）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较&lt;/th&gt;
&lt;th&gt;存数&lt;/th&gt;
&lt;th&gt;取数&lt;/th&gt;
&lt;th&gt;删除数据&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Map&lt;/td&gt;
&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;域对象&lt;/td&gt;
&lt;td&gt;setAttribute&lt;/td&gt;
&lt;td&gt;getAttribute&lt;/td&gt;
&lt;td&gt;removeAttribute&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ServletContext是在Web工程部署启动的时候创建的，在Web工程停止的时候销毁&lt;/p&gt;
&lt;h4&gt;作用&lt;/h4&gt;
&lt;p&gt;1.获取web.xml中配置的上下文参数context-param&lt;/p&gt;
&lt;p&gt;2.获取当前的工作路径，格式：/工程路径&lt;/p&gt;
&lt;p&gt;3.获取工程部署后在服务器硬盘上的绝对路径&lt;/p&gt;
&lt;p&gt;4.像Map一样存取数据&lt;/p&gt;
&lt;h4&gt;实际使用&lt;/h4&gt;
&lt;p&gt;由于我的Servlet程序没有设置web.xml，全局上下文变量是通过一个WebListener完成的，其中存储了一个global和一个version&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

@WebListener
public class ContextListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        sce.getServletContext().setAttribute(&quot;global&quot;, &quot;Hello World&quot;);
        sce.getServletContext().setAttribute(&quot;version&quot;, &quot;1.0.0&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;contextDestroyed&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而要在Servlet程序中调用，则通过getServletContext获取到上下文，再通过getAttribute类似map一样的操作取出对应的值&lt;/p&gt;
&lt;p&gt;以下是HttpServlet的实现类，其中有一个getServletContext的封装方法以调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@WebServlet(&quot;/new&quot;)
public class NewServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String global = (String)getServletContext().getAttribute(&quot;global&quot;);
        String version = (String)getServletContext().getAttribute(&quot;version&quot;);
        System.out.println(&quot;Servlet Get Called&quot; + global + &quot; &quot; + version);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们还可以通过Context获取工作路径与部署绝对路径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：getRealPath方法在一些 &lt;strong&gt;非文件系统部署（比如 WAR 包部署到云服务器）中可能返回 null&lt;/strong&gt;，因此用需要额外小心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String contextPath = getServletContext().getContextPath();
    String realPath = getServletContext().getRealPath(&quot;/&quot;);
    System.out.println(contextPath);
    System.out.println(realPath);
    //ServletTest
    //C:\Users\71460\Desktop\Java\Maven\Servlet\target\Servlet-1.0-SNAPSHOT\
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HTTP协议&lt;/h3&gt;
&lt;p&gt;指客户端和服务端通信时发送数据需要遵守的规则，HTTP协议中的数据称为报文，其中的请求分为GET请求和POST请求&lt;/p&gt;
&lt;h4&gt;GET请求&lt;/h4&gt;
&lt;p&gt;1.请求行：请求的方式，请求的资源路径，请求的协议和版本号&lt;/p&gt;
&lt;p&gt;2.请求头： key:value 组成，不同的键值对表示不同的含义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/145.png&quot; alt=&quot;145&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;Post请求&lt;/h4&gt;
&lt;p&gt;1.请求行：请求的方式，请求的资源路径，请求的协议和版本号&lt;/p&gt;
&lt;p&gt;2.请求头： key:value 组成，不同的键值对表示不同的含义&lt;/p&gt;
&lt;p&gt;空行：请求头和请求体之间有空行&lt;/p&gt;
&lt;p&gt;3.请求体：===&amp;gt;&amp;gt;&amp;gt;就是发送给服务器的数据&lt;/p&gt;
&lt;p&gt;这里表单中有隐藏数据login username，将这两个信息发送给服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/146.png&quot; alt=&quot;146&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;常见的请求头&lt;/h4&gt;
&lt;p&gt;Accept：告诉服务器，客户端可以接收的数据类型&lt;/p&gt;
&lt;p&gt;Accept-Language：告诉服务器客户端可以接收的语言类型，zh_CN、zh_ENG&lt;/p&gt;
&lt;p&gt;User-Agent：浏览器的信息&lt;/p&gt;
&lt;p&gt;Accept-Encoding：告诉服务器，客户端可以接收的数据编码（压缩）格式&lt;/p&gt;
&lt;p&gt;Host：表示请求的服务器ip和端口号&lt;/p&gt;
&lt;p&gt;Connection：告诉服务器当前连接如何处理，常见的有两种，Keep-Alive和Closed&lt;/p&gt;
&lt;p&gt;Referer：表示请求发起时，浏览器地址栏中的地址从哪里来&lt;/p&gt;
&lt;p&gt;Content-Type：表示发送的数据类型（图中的表示多段数据提交，以流形式提交）&lt;/p&gt;
&lt;p&gt;Content-Length：发送的数据长度&lt;/p&gt;
&lt;p&gt;Cache-Control：表示如何控制缓存，no-cache表示不缓存&lt;/p&gt;
&lt;h4&gt;Get请求和Post请求区分&lt;/h4&gt;
&lt;p&gt;Get：&lt;/p&gt;
&lt;p&gt;form method=get  a标签  link标签引入css  script引入js文件  img标签引入图片  iframe引入html页面  在浏览器地址栏中输入访问地址回车&lt;/p&gt;
&lt;p&gt;Post：&lt;/p&gt;
&lt;p&gt;form method=post&lt;/p&gt;
&lt;h3&gt;响应HTTP协议格式&lt;/h3&gt;
&lt;h4&gt;格式&lt;/h4&gt;
&lt;p&gt;1.响应行：响应的协议与版本号  响应状态码  响应状态描述符&lt;/p&gt;
&lt;p&gt;2.响应头： key:value 不同的响应头，有不同的含义&lt;/p&gt;
&lt;p&gt;空行&lt;/p&gt;
&lt;p&gt;3.响应体：---&amp;gt;&amp;gt;&amp;gt;回传给客户端的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/147.png&quot; alt=&quot;147&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;常见响应码&lt;/h4&gt;
&lt;p&gt;200：表示请求成功&lt;/p&gt;
&lt;p&gt;302：表示请求重定向&lt;/p&gt;
&lt;p&gt;404：表示请求被服务器收到，但是预期数据不存在（请求地址出错）&lt;/p&gt;
&lt;p&gt;500：表示服务器已经收到请求，但是服务器内部错误（代码错误，发生不可预期的错误）&lt;/p&gt;
&lt;h3&gt;MIME&lt;/h3&gt;
&lt;p&gt;MIME是HTTP协议中的数据类型，全称为多功能internet邮件扩充服务，MIME类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/148.png&quot; alt=&quot;148&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>自学第二月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%BA%8C%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>结束Java</description><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第二月份总结&lt;/h1&gt;
&lt;p&gt;​	在学习Java后端开发的第二个月中，用10天的时间为Java语言基础收了个尾，结束了反射，多线程基础，IO流的学习&lt;/p&gt;
&lt;p&gt;​	学习完成Java部分的内容后又花了5天的时间回顾了MySQL数据库基础，巩固了一些数据库使用上的细节（存储引擎，事务，隔离级别等）。2天的时间完成了Java8一些新特性的学习，理解了Lambda表达式的使用，Stream API的概念以及使用方式，Optional类的学习&lt;/p&gt;
&lt;p&gt;​	之后又用了两天的时间完成JDBC的相关概念学习（SQL注入，连接池）学会了如何使用JDBC操作数据库，配置DBUtils，能够独立对于JDBC结合德鲁伊连接池，阿帕奇的Utils将SQL查询封装为Dao对象便于操作，用了两天的时间对于Redis有了一些初级的了解（数据结构，NoSQL，客户端），之后又花了一天半的时间完成了git版本控制工具的使用，能够结合远程代码托管平台（Github，Gitee），使用命令行或者IDEA集成开发环境，对于自己写的代码进行版本管理&lt;/p&gt;
&lt;p&gt;​	最后的8天稍微有些懈怠，由于课程安排有些紧凑，实际上满打满算的学习只有大概5天左右，完成了JavaWeb中的一部分学习：一些前端基础（html，CSS，JavaScript，jQuery），Web服务器（Tomcat），以及依赖管理工具Maven的基本使用，我对前端这部分的理解是在实际使用中搞清楚怎么用即可，没有花太多时间去像Java基础部分一样记录较为详细的笔记。&lt;/p&gt;
&lt;p&gt;​	五一假期打算过完生日后，抽出一天时间过一遍线代考试内容（5.10）另外两天看一下编译原理实验的作业和机器学习的大作业，假期之后再进行JavaWeb中Servlet的学习。&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记(模板)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/</guid><description>JavaWeb笔记模板</description><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
</content:encoded></item><item><title>JavaWeb笔记(Tomcat，Maven，Docker)</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0tomcatmavendocker/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0tomcatmavendocker/</guid><description>服务器部署Tomcat，jar包管理Maven，环境Docker</description><pubDate>Tue, 29 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;Tomcat&lt;/h2&gt;
&lt;p&gt;JavaWeb：所用通过Java语言编写可以通过浏览器访问的程序的总称，基于请求和响应来开发的&lt;/p&gt;
&lt;p&gt;Web资源：根据资源实现的技术和呈现的效果不同，分为静态资源和动态资源&lt;/p&gt;
&lt;p&gt;静态资源：html，css，js，txt，mp4，jpg&lt;/p&gt;
&lt;p&gt;动态资源：jsp页面，Servlet程序&lt;/p&gt;
&lt;p&gt;常见的服务器：Tomcat，Jboss，GlassFish，Resin，WebLogic&lt;/p&gt;
&lt;h3&gt;安装启动&lt;/h3&gt;
&lt;p&gt;版本对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/138.png&quot; alt=&quot;138&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我使用的是tomcat9.0+Servlet4.0+JDK8&lt;/p&gt;
&lt;p&gt;将Tomcat解压到你想要的路径下&lt;/p&gt;
&lt;p&gt;在安装的bin目录下双击startup启动tomcat服务器，在浏览器中输入以下网址开启Tomcat服务页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/139.png&quot; alt=&quot;139&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果在启动的时候出现黑框立马闪退，有可能是没有设置系统变量&lt;/p&gt;
&lt;p&gt;变量：JAVA_HOME   值：安装的JDK目录&lt;/p&gt;
&lt;p&gt;关闭：双击shutdown.bat关闭&lt;/p&gt;
&lt;p&gt;在config目录下有一个server.xml配置文件，在其中可以修改端口号8080，可以改为一个你想要用的其他端口号替换，再重启Tomcat服务器即可完成修改&lt;/p&gt;
&lt;h3&gt;部署Web&lt;/h3&gt;
&lt;h4&gt;第一种方式&lt;/h4&gt;
&lt;p&gt;是需要把Web工程目录放入Tomcat的webapps目录下即可，这种方式比较方便&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080/test/123.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入路径即可访问，其中的 http://localhost:8080 代表的就是webapps目录&lt;/p&gt;
&lt;p&gt;在其他的设备通过输入部署的网络IP地址可以远程访问Web页面，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://192.168.104.29:8080/test/123.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;第二种方式&lt;/h4&gt;
&lt;p&gt;找到Tomcat下的conf目录apache-tomcat-9.0.104\conf\Catalina\localhost，创建配置文件，在其中设置路径即可访问对应路径下的Web工程，这种方式较为灵活&lt;/p&gt;
&lt;p&gt;访问服务器的时候，只填入网址端口默认访问ROOT工程，没有地址名，访问index.html&lt;/p&gt;
&lt;h3&gt;动态web工程&lt;/h3&gt;
&lt;p&gt;使用详见&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_45791445/article/details/104574239&lt;/p&gt;
&lt;p&gt;可以在IDEA上创建动态的Web项目，并使用Tomcat部署Web服务&lt;/p&gt;
&lt;h2&gt;Maven&lt;/h2&gt;
&lt;p&gt;推荐教程：可以快速上手，理解Maven相关概念以及使用方式&lt;/p&gt;
&lt;p&gt;【一小时Maven教程】https://www.bilibili.com/video/BV1uApMeWErY?p=12&amp;amp;vd_source=586d101621a2629c1796f59df9143dff&lt;/p&gt;
&lt;p&gt;Maven是一个依赖管理工具&lt;/p&gt;
&lt;p&gt;通过Maven可以实现批量编译，组织文件结构，批量复制jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/140.png&quot; alt=&quot;140&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maven可以管理项目依赖，包括自动下载依赖库，自动下载依赖之间没有冲突，以来版本管理，用户只需要编写配置即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目构建是将源代码，配置文件，资源文件等转化为能够运行或者部署的应用程序或库的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/141.png&quot; alt=&quot;141&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Package定义规则&lt;/p&gt;
&lt;p&gt;jar：代表普通的java工程，打包为jar结尾的文件&lt;/p&gt;
&lt;p&gt;war：代表java的web工程&lt;/p&gt;
&lt;p&gt;porn：代表不会打包，用以做继承的父工程&lt;/p&gt;
&lt;p&gt;而maven通过pom.xml配置执行打包以及构建，其中仓库存放jar包（仓库又分为本地仓库，私服仓库，中央仓库）&lt;/p&gt;
&lt;p&gt;setting.xml配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
  &amp;lt;!-- 原有镜像配置保持不变 --&amp;gt;
  &amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
      &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;/mirror&amp;gt;
  &amp;lt;/mirrors&amp;gt;

  &amp;lt;!-- 新增以下配置 --&amp;gt;
  &amp;lt;profiles&amp;gt;
    &amp;lt;profile&amp;gt;
      &amp;lt;id&amp;gt;disable-remote-archetype&amp;lt;/id&amp;gt;
      &amp;lt;properties&amp;gt;
        &amp;lt;!-- 强制使用本地 archetype 缓存 --&amp;gt;
        &amp;lt;archetypeCatalog&amp;gt;internal&amp;lt;/archetypeCatalog&amp;gt;
      &amp;lt;/properties&amp;gt;
    &amp;lt;/profile&amp;gt;
  &amp;lt;/profiles&amp;gt;

  &amp;lt;!-- 激活配置 --&amp;gt;
  &amp;lt;activeProfiles&amp;gt;
    &amp;lt;activeProfile&amp;gt;disable-remote-archetype&amp;lt;/activeProfile&amp;gt;
  &amp;lt;/activeProfiles&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父子模块管理&lt;/p&gt;
&lt;p&gt;在父工程中的pom文件下添加的依赖可以被子模块中使用，所有将公共的依赖放置在父工程中可以简化依赖，也可以设置为不默认继承依赖，而是手动集成父工程依赖&lt;/p&gt;
&lt;h2&gt;Docker&lt;/h2&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;Docker是一个用于构建运行传送应用程序的平台，可以解决环境配置的问题，将第三方软件库，依赖等打包，运行在任何的环境&lt;/p&gt;
&lt;p&gt;Docker是一个容器的实现，容器是一个虚拟化技术是一个独立的环境，使用宿主机的OS操作系统，减少资源的浪费（运行多个操作系统和图形化界面）&lt;/p&gt;
&lt;p&gt;容器是Docker的一个运行实例，提供一个可以移植的环境，可以在这个环境中运行应用程序，镜像和容器的关系类似Java中的类和实例，Docker仓库可以存储Docker镜像和上传，我们打包容器为镜像上传给别人，别人就可以使用镜像创建相应的容器&lt;/p&gt;
&lt;h3&gt;大致使用&lt;/h3&gt;
&lt;p&gt;Dockerfile是构建指令，包含了如何配置环境的一些指令，用于告诉如何构建镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:14-alpine
COPY index.js /index.js
CMD [&quot;node&quot;, &quot;/index.js&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t hello-docker .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    9bea9f2796e2   5 months ago   192MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run hello-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过网页使用在线的play with docker来远程通过dockerhub下载镜像，运行容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull thrinisty/hello-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Docker Compose&lt;/h3&gt;
&lt;p&gt;用于定义和运行多容器Docker应用程序的工具，使用yaml文件来设置应用程序服务&lt;/p&gt;
&lt;p&gt;通过docker-compose.yaml配置文件将一组互相关联的容器组合在一起，形成项目，通过一条命令即可创建并启动所有的服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实际使用&lt;/h3&gt;
&lt;p&gt;我们现在在Docker上下载一个redis的镜像，并且通过镜像创建运行redis容器，之后在宿主机上用客户端连接服务器&lt;/p&gt;
&lt;p&gt;查找可用redis镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载redis镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行redis容器，并且通过-p参数将容器端口映射到宿主机端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name redis_test -p 6379:6379 -d redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在宿主机连接docker运行中的redis容器对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p 6379
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>JavaWeb笔记（jQuery）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jqueryxml/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0jqueryxml/</guid><description>jQuery，XML</description><pubDate>Sun, 27 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;计划两天完成jQuery和XML部分的学习&lt;/p&gt;
&lt;h2&gt;jQuery&lt;/h2&gt;
&lt;p&gt;定义：是JavaScript和Query查询的结合，是辅助JavaScript开发的js类库&lt;/p&gt;
&lt;p&gt;核心思想：写的更少，做的更多，实现了很多浏览器的兼容问题&lt;/p&gt;
&lt;p&gt;流行程度：流行程度高，约 &lt;strong&gt;75% 的网站&lt;/strong&gt; 仍在使用 jQuery 进行 JavaScript 开发&lt;/p&gt;
&lt;p&gt;优点：开源免费，语法便捷高效，简单易用（例如操作文档对象，选择DOM元素，制作动画效果，事件处理，使用Ajax等）&lt;/p&gt;
&lt;h3&gt;入门示例&lt;/h3&gt;
&lt;p&gt;如下是一个没有注册onclick事件的按钮，要求实现点击按钮输出Hello&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传统方式：通过获取标签对象绑定事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function () {
            var Obj = document.getElementById(&quot;button&quot;);
            Obj.onclick = function () {
                alert(&quot;Hello&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过jQuery实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {//表示onload事件
            var $button = $(&quot;#button&quot;);
            $button.click(function() {//绑定单击事件
                alert(&quot;Hello&quot;);
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;button id=&quot;button&quot;&amp;gt;Say&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$是一个函数&lt;/p&gt;
&lt;p&gt;对于框架而言jquery-3.7.1.min.js一般用于部署（快速，小），而jquery-3.7.1.js用于开发（可以方便看源码）&lt;/p&gt;
&lt;p&gt;使用jQuery查询标签对象，使用标签对象.click绑定函数&lt;/p&gt;
&lt;h3&gt;核心函数&lt;/h3&gt;
&lt;p&gt;$是jQuery核心函数，可以完成jQuery很多功能&lt;/p&gt;
&lt;p&gt;而$()就是在调用这个函数，根据传入的不同参数，实现不同的功能，以下是常见的使用方式&lt;/p&gt;
&lt;p&gt;1.当传入函数的时候，功能相当于window.onload = function() {}，在文档加载完毕后自动调用函数&lt;/p&gt;
&lt;p&gt;注意这里在加载的时间略微有区别，$内容在页面加载完毕的时候立马执行，但是原生的window.onload = function() {}还要等待标签显示内容显示完成后（例如来自网络中的图片）才会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {alert(&quot;jQuery&quot;)});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当传入HTML字符串的时候，会对我们创建这个html标签对象&lt;/p&gt;
&lt;p&gt;通过appendTo将字符串化为html标签对象添加到body，实现拼接，而非逐层添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
           $(&quot;&amp;lt;div&amp;gt;&quot;
               + &quot;&amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;&quot;
               + &quot;&amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;&quot;
               + &quot;&amp;lt;div&amp;gt;&quot;).appendTo(&quot;body&quot;);
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.传入选择器字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;#id 属性值&quot;);
$(&quot;标签名&quot;);
$(&quot;.class 属性值&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
           var length = $(&quot;div&quot;).length;
           alert(length);
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;div-span1&amp;lt;/span&amp;gt;
        &amp;lt;span&amp;gt;div-span2&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.传入DOM对象，会将DOM对象转化为jQuery对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       var Obj = document.getElementById(&quot;test&quot;);
       $Obj = $(Obj);
       $Obj.click(function() {
          alert(&quot;test&quot;);
       });
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用jQuery对象的方法，例如绑定单击&lt;/p&gt;
&lt;p&gt;jQuery对象的本质其实是数组，其中存放的是DOM对象，可以通过访问数组的方式取出DOM对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$Obj = $(Obj);
var DOM = $Obj[0];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;jQuery选择器&lt;/h3&gt;
&lt;h4&gt;基础选择器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#ID
.class
element
*
selector1,selector2,selector3...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.class表示要符合同时满足标签名和class名，使用上大体和css那部分相同&lt;/p&gt;
&lt;h4&gt;层级选择器&lt;/h4&gt;
&lt;p&gt;取标签下的所有对应标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到forn标签下的所有input标签&lt;/p&gt;
&lt;p&gt;取标签下的所有子标签（不算孙子节点）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form&amp;gt;input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取标签后面的对应标签（同一级别）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form+input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取标签后面所有的对应标签（同一级别）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&quot;form~input&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;基本过滤选择器&lt;/h4&gt;
&lt;p&gt;first&lt;/p&gt;
&lt;p&gt;筛选出集合中的第一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:first&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询到的结果是1，过滤出第一个li标签&lt;/p&gt;
&lt;p&gt;not(selector)&lt;/p&gt;
&lt;p&gt;除去集合中满足selector的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:not(:first)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为234&lt;/p&gt;
&lt;p&gt;even&lt;/p&gt;
&lt;p&gt;匹配索引值位偶数的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:even&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为13&lt;/p&gt;
&lt;p&gt;odd&lt;/p&gt;
&lt;p&gt;匹配索引值位奇数的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:odd&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;gt(index)&lt;/p&gt;
&lt;p&gt;大于索引的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:gt(0)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为234&lt;/p&gt;
&lt;p&gt;lt(index)&lt;/p&gt;
&lt;p&gt;小于索引的标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function() {
       alert($(&quot;li:lt(1)&quot;).text());
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为1&lt;/p&gt;
&lt;p&gt;head：标题元素&lt;/p&gt;
&lt;p&gt;animated：正在执行动画的元素&lt;/p&gt;
&lt;p&gt;eq(Index)：等于对应索引的元素&lt;/p&gt;
&lt;h4&gt;内容过滤器&lt;/h4&gt;
&lt;p&gt;contain(text)：匹配包含对应text的元素&lt;/p&gt;
&lt;p&gt;empty：匹配不包含text的元素（为空）&lt;/p&gt;
&lt;p&gt;has(selector)：匹配含有选择器匹配的元素的元素（外层元素）&lt;/p&gt;
&lt;p&gt;parent：匹配含有子元素或者文本的元素（非空）&lt;/p&gt;
&lt;h4&gt;属性过滤器&lt;/h4&gt;
&lt;p&gt;div[id]：含有id的div&lt;/p&gt;
&lt;p&gt;div[id=123]：含有id为123的div&lt;/p&gt;
&lt;p&gt;div[id!=123]：含有id不为123的div&lt;/p&gt;
&lt;p&gt;div[id^=123]：含有id且id为123开头的div&lt;/p&gt;
&lt;p&gt;div[id$=123]：含有id且id为123结尾的div&lt;/p&gt;
&lt;p&gt;div[id*=123]：含有id且id包含123的div&lt;/p&gt;
&lt;p&gt;复合选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input[id=123][name=&apos;hello&apos;][class=.myclass]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;表单过滤器&lt;/h4&gt;
&lt;p&gt;input：匹配所有的input，extarea，select，button元素&lt;/p&gt;
&lt;p&gt;以下都是其匹配对应表单的对应type的标签元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text：
password：
radio：
checkbox：
submit：
image：
reset：
button：
file：
hidden：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;enabled：匹配可用的元素&lt;/p&gt;
&lt;p&gt;disabled：匹配不可用的元素（加上disabled=&quot;disabled&quot;元素）&lt;/p&gt;
&lt;p&gt;checked：匹配所有选中的checkbox元素&lt;/p&gt;
&lt;p&gt;selected：匹配选中的option元素&lt;/p&gt;
&lt;h4&gt;元素的筛选&lt;/h4&gt;
&lt;p&gt;大体上和Stream流处理的方式类似，在jQuery中其实就是将 :first  换了一种方式使用  .first()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(#123:fist)
$(#123).first();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你学过流式处理的话其实还是很熟悉的，这里就不再记录笔记了，等碰到不会的根据需求即查即用&lt;/p&gt;
&lt;h3&gt;属性操作&lt;/h3&gt;
&lt;h4&gt;html&lt;/h4&gt;
&lt;p&gt;设置和获取其实标签和结束标签中的内容，和innerHTML一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            alert($(&quot;div&quot;).html());
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;div标签&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span标签&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;div&quot;).html(&quot;&amp;lt;h1&amp;gt;重设值&amp;lt;/h1&amp;gt;&quot;)
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入值代表设置值，而不传参数代表获取&lt;/p&gt;
&lt;h4&gt;text&lt;/h4&gt;
&lt;p&gt;设置和获取其实标签和结束标签中的文本，和innerText一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;div&quot;).text(&quot;text&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;val&lt;/h4&gt;
&lt;p&gt;设置和获取表单项的value属性值，和dom中的balue一致val&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            var $btn = $(&quot;#btn&quot;);
            $btn.click(function() {
                alert($(&quot;#input&quot;).val());
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;div&amp;gt;div标签&amp;lt;/div&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;input&quot;/&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;click&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多选框中设置选中可以使用$().val([&quot;num1&quot;,&quot;num2&quot;])&lt;/p&gt;
&lt;h4&gt;attr&lt;/h4&gt;
&lt;p&gt;设置或者获取属性值，不推荐操作checked，readOnly，selected，disabled&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    var attr = $(&quot;#input&quot;).attr(&quot;name&quot;);
    alert(attr);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;#input&quot;).attr(&quot;name&quot;,&quot;another&quot;);
    var attr = $(&quot;#input&quot;).attr(&quot;name&quot;);
    alert(attr);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;prop&lt;/h4&gt;
&lt;p&gt;设置或者获取属性值，使用时建议与attr互补&lt;/p&gt;
&lt;p&gt;当一个标签没有name的时候查询属性值会返回undifined，我们可以使用prop返回更为直观的false和true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            $(&quot;#btn&quot;).click(function() {
               var prop = $(&quot;#check&quot;).prop(&quot;checked&quot;);
               alert(prop);
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;input id=&quot;check&quot; type=&quot;checkbox&quot;/&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;check&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增删改&lt;/h3&gt;
&lt;h4&gt;添加&lt;/h4&gt;
&lt;p&gt;appendTo(content)：将调用者插入到content的最后一个子元素之后&lt;/p&gt;
&lt;p&gt;prependTo(content)：将调用者插入到content的最前一个子元素之前&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(function() {
    $(&quot;&amp;lt;h1&amp;gt;h1&amp;lt;h1/&amp;gt;&quot;).appendTo(&quot;body&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;外部插入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.insertAfter(b);//得到da
a.insertBefore(b);//得到ab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;替换&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.replaceWith(b);//用b替换掉a
a.replaceAll(b);//用a替换所有的b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;删除&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;a.remove();//清除a标签
a.empty();//清除a标签中的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        $(function() {
            $(&quot;#btn1&quot;).click(function() {
                $(&quot;#select1 option:selected&quot;).appendTo($(&quot;#select2&quot;));
            });
            $(&quot;#btn2&quot;).click(function() {
                $(&quot;#select1 option:selected&quot;).appendTo($(&quot;#select2&quot;));
            });
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;select id=&quot;select1&quot; multiple=&quot;multiple&quot;&amp;gt;
        &amp;lt;option value=&quot;1&quot;&amp;gt;1&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;2&quot;&amp;gt;2&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;3&quot;&amp;gt;3&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;4&quot;&amp;gt;4&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;5&quot;&amp;gt;5&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&quot;select2&quot; multiple=&quot;multiple&quot;&amp;gt;
        &amp;lt;option value=&quot;6&quot;&amp;gt;6&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;7&quot;&amp;gt;7&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;8&quot;&amp;gt;8&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;9&quot;&amp;gt;9&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;10&quot;&amp;gt;10&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;button id=&quot;btn1&quot;&amp;gt;1&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btn2&quot;&amp;gt;2&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;美化操作&lt;/h3&gt;
&lt;h4&gt;CSS样式&lt;/h4&gt;
&lt;p&gt;addClass：添加样式&lt;/p&gt;
&lt;p&gt;removeClass：移除样式&lt;/p&gt;
&lt;p&gt;toggleClass：有就删除样式，没有就添加样式&lt;/p&gt;
&lt;p&gt;offset：获取或者设置坐标&lt;/p&gt;
&lt;p&gt;以下是ai生成的网页，便于对比理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;jQuery 类与坐标操作示例&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            width: 100px;
            height: 100px;
            background-color: #3498db;
            margin: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .highlight {
            background-color: #e74c3c;
            border: 3px solid #f1c40f;
            transform: scale(1.1);
        }

        .rounded {
            border-radius: 50%;
        }

        .shadow {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
        }

        .info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;jQuery 类与坐标操作示例&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;targetBox&quot;&amp;gt;可操作的盒子&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;button id=&quot;addHighlight&quot;&amp;gt;添加高亮样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;removeHighlight&quot;&amp;gt;移除高亮样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;toggleRounded&quot;&amp;gt;切换圆形样式&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;toggleShadow&quot;&amp;gt;切换阴影样式&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;button id=&quot;getOffset&quot;&amp;gt;获取坐标&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;setOffset&quot;&amp;gt;设置新坐标(右移50px)&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;info&quot; id=&quot;offsetInfo&quot;&amp;gt;
    坐标信息将显示在这里
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
    $(document).ready(function() {
        // 添加类
        $(&quot;#addHighlight&quot;).click(function() {
            $(&quot;#targetBox&quot;).addClass(&quot;highlight&quot;);
            updateOffsetInfo();
        });

        // 移除类
        $(&quot;#removeHighlight&quot;).click(function() {
            $(&quot;#targetBox&quot;).removeClass(&quot;highlight&quot;);
            updateOffsetInfo();
        });

        // 切换类
        $(&quot;#toggleRounded&quot;).click(function() {
            $(&quot;#targetBox&quot;).toggleClass(&quot;rounded&quot;);
            updateOffsetInfo();
        });

        // 切换另一个类
        $(&quot;#toggleShadow&quot;).click(function() {
            $(&quot;#targetBox&quot;).toggleClass(&quot;shadow&quot;);
        });

        // 获取偏移坐标
        $(&quot;#getOffset&quot;).click(function() {
            updateOffsetInfo();
        });

        // 设置新坐标
        $(&quot;#setOffset&quot;).click(function() {
            var currentOffset = $(&quot;#targetBox&quot;).offset();
            $(&quot;#targetBox&quot;).offset({
                top: currentOffset.top,
                left: currentOffset.left + 50
            });
            updateOffsetInfo();
        });

        // 更新坐标信息显示
        function updateOffsetInfo() {
            var offset = $(&quot;#targetBox&quot;).offset();
            var classes = $(&quot;#targetBox&quot;).attr(&quot;class&quot;) || &quot;无&quot;;
            $(&quot;#offsetInfo&quot;).html(
                `当前坐标: top=${offset.top}px, left=${offset.left}px&amp;lt;br&amp;gt;
                     当前类: ${classes}`
            );
        }

        // 初始化显示坐标信息
        updateOffsetInfo();
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;jQuery动画&lt;/h4&gt;
&lt;p&gt;show：显示，还可以传入显式的时间&lt;/p&gt;
&lt;p&gt;hide：将元素隐藏&lt;/p&gt;
&lt;p&gt;toggle：显示/隐藏，取决于隐藏/显示&lt;/p&gt;
&lt;p&gt;fadeIn：淡入&lt;/p&gt;
&lt;p&gt;fadeOut：淡出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;jQuery 动画效果示例&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;jquery-3.7.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .box {
            width: 200px;
            height: 200px;
            background-color: #3498db;
            margin: 20px;
            padding: 20px;
            color: white;
            text-align: center;
            line-height: 200px;
            font-size: 20px;
            border-radius: 10px;
        }

        .controls {
            margin: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        button {
            margin: 5px;
            padding: 10px 15px;
            cursor: pointer;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        button:hover {
            background-color: #27ae60;
        }

        .speed-control {
            margin-top: 15px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;jQuery 动画效果演示&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;controls&quot;&amp;gt;
    &amp;lt;h2&amp;gt;基本显示/隐藏&amp;lt;/h2&amp;gt;
    &amp;lt;button id=&quot;btnShow&quot;&amp;gt;显示 (show)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnHide&quot;&amp;gt;隐藏 (hide)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnToggle&quot;&amp;gt;切换 (toggle)&amp;lt;/button&amp;gt;

    &amp;lt;div class=&quot;speed-control&quot;&amp;gt;
        动画速度：
        &amp;lt;select id=&quot;speedBasic&quot;&amp;gt;
            &amp;lt;option value=&quot;fast&quot;&amp;gt;快速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;normal&quot; selected&amp;gt;正常&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;slow&quot;&amp;gt;慢速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;1000&quot;&amp;gt;1秒&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;2000&quot;&amp;gt;2秒&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;box1&quot;&amp;gt;显示/隐藏动画效果&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;controls&quot;&amp;gt;
    &amp;lt;h2&amp;gt;淡入淡出效果&amp;lt;/h2&amp;gt;
    &amp;lt;button id=&quot;btnFadeIn&quot;&amp;gt;淡入 (fadeIn)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnFadeOut&quot;&amp;gt;淡出 (fadeOut)&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btnFadeToggle&quot;&amp;gt;淡入淡出切换&amp;lt;/button&amp;gt;

    &amp;lt;div class=&quot;speed-control&quot;&amp;gt;
        动画速度：
        &amp;lt;select id=&quot;speedFade&quot;&amp;gt;
            &amp;lt;option value=&quot;fast&quot;&amp;gt;快速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;normal&quot; selected&amp;gt;正常&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;slow&quot;&amp;gt;慢速&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;1500&quot;&amp;gt;1.5秒&amp;lt;/option&amp;gt;
            &amp;lt;option value=&quot;3000&quot;&amp;gt;3秒&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;box&quot; id=&quot;box2&quot;&amp;gt;淡入淡出动画效果&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
    $(document).ready(function() {
        // 基本显示/隐藏控制
        $(&quot;#btnShow&quot;).click(function() {
            $(&quot;#box1&quot;).show($(&quot;#speedBasic&quot;).val());
        });

        $(&quot;#btnHide&quot;).click(function() {
            $(&quot;#box1&quot;).hide($(&quot;#speedBasic&quot;).val());
        });

        $(&quot;#btnToggle&quot;).click(function() {
            $(&quot;#box1&quot;).toggle($(&quot;#speedBasic&quot;).val());
        });

        // 淡入淡出控制
        $(&quot;#btnFadeIn&quot;).click(function() {
            $(&quot;#box2&quot;).fadeIn($(&quot;#speedFade&quot;).val());
        });

        $(&quot;#btnFadeOut&quot;).click(function() {
            $(&quot;#box2&quot;).fadeOut($(&quot;#speedFade&quot;).val());
        });

        $(&quot;#btnFadeToggle&quot;).click(function() {
            $(&quot;#box2&quot;).fadeToggle($(&quot;#speedFade&quot;).val());
        });

        // 初始化隐藏第二个盒子
        $(&quot;#box2&quot;).hide();
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;事件处理&lt;/h3&gt;
&lt;p&gt;在使用上和JS差不多，加了更多的常用事件&lt;/p&gt;
&lt;h4&gt;常用的绑定方法&lt;/h4&gt;
&lt;p&gt;click：绑定单机事件以及触发的事件&lt;/p&gt;
&lt;p&gt;mouseover：鼠标移入事件&lt;/p&gt;
&lt;p&gt;bind：给元素一次性绑定一个或者多个事件&lt;/p&gt;
&lt;p&gt;one：和bind类似，但是只会触发一次&lt;/p&gt;
&lt;p&gt;live：用于绑定事件，可以绑定与选择其匹配的所有元素的事件，即使是动态创建后的元素&lt;/p&gt;
&lt;p&gt;unbind：和bind相反，解除事件绑定&lt;/p&gt;
&lt;h4&gt;冒泡&lt;/h4&gt;
&lt;p&gt;如果子元素和父元素都绑定了同一事件，当子元素被触发时，父元素也会响应，如果需要阻止则在子元素处理中返回false即可&lt;/p&gt;
&lt;h4&gt;事件对象&lt;/h4&gt;
&lt;p&gt;是封装有触发事件信息的一个JavaScript对象&lt;/p&gt;
&lt;p&gt;在给元素绑定事件的时候，在事件的function(event)参数列表中添加一个参数，这个event就是JavaScript传递参数事件处理函数的事件对象，其中包含了一些事件响应的信息&lt;/p&gt;
&lt;p&gt;有的时候需要使用到事件对象中的内容，例如获取当前操作是什么事件，并将事件打印出来&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
&lt;p&gt;xml是可扩展的标记性语言，用于保存数据，而且这些数据具有自我描述性，还可以作为项目的配置文件，另外还可以作为网络传输数据的格式（不过现在常使用json）&lt;/p&gt;
&lt;h3&gt;语法规则&lt;/h3&gt;
&lt;p&gt;XML元素命名规则：名称可以含有数字，字母，其他字符。名称不可以以数字，标点符号开始。名称不可以以xml开始。名称不可以包含空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;book sn=&quot;1124&quot;&amp;gt;
        &amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
        &amp;lt;author&amp;gt;汉顺&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;16&amp;lt;/price&amp;gt;
&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分为单标签和双标签，和html类似，写的时候建议闭合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt;
&amp;lt;book&amp;gt;&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性：和html类似，提供额外的信息给元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;book name=&quot;123&quot; id=&quot;123&quot; function=&quot;123&quot;&amp;gt;&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档必须有唯一根元素，即没有父标签的元素，例如示例中的books标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;books&amp;gt;
    &amp;lt;book sn=&quot;1123&quot;&amp;gt;
        &amp;lt;name&amp;gt;时间简史&amp;lt;/name&amp;gt;&amp;lt;!--书名--&amp;gt;
        &amp;lt;author&amp;gt;霍金&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;15&amp;lt;/price&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book sn=&quot;1124&quot;&amp;gt;
        &amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
        &amp;lt;author&amp;gt;汉顺&amp;lt;/author&amp;gt;
        &amp;lt;price&amp;gt;16&amp;lt;/price&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/books&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文本区域：不会解析其中xml格式的内容（CDATA）&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;![CDATA[内容部分，这个部分不会被解析]]&amp;gt;
&amp;lt;author&amp;gt;&amp;lt;![CDATA[内容部分，这个部分不会被解析]]&amp;gt;&amp;lt;/author&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;XML解析&lt;/h3&gt;
&lt;p&gt;无论是html文件还是xml文件都是标记型文档都可以使解析取出操作内容&lt;/p&gt;
&lt;h4&gt;常见的解析技术&lt;/h4&gt;
&lt;p&gt;DOM解析：标签在dom解析的时候生成各个对象，并以树形的格式连接&lt;/p&gt;
&lt;p&gt;SAX解析：这种解析方式可以一行一行读取xml文件，不会创建大量的dom对象，性能和内存都优于dom解析&lt;/p&gt;
&lt;p&gt;第三方解析：jdom在dom基础上封装，dom4j对jdom封装。pull主要用于安卓手机开发，和sax类似，是事件机制解析xml文件&lt;/p&gt;
&lt;h4&gt;dom4解析技术&lt;/h4&gt;
&lt;p&gt;引入dom4 jar包，添加到类库，以下是一个实例代码，获取document对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import org.dom4j.*;
import java.util.List;

public class Main {
    public static void main(String[] args) throws DocumentException {
        SAXReader reader = new SAXReader();
        Document document = reader.read(&quot;xml/test.xml&quot;);
        Element rootElement = document.getRootElement();
        //获取根标签对象
        List&amp;lt;Element&amp;gt; books = rootElement.elements(&quot;book&quot;);
        //通过根标签对象获取book子标签对象list集合
        for (Element book : books) {
            Element name = book.element(&quot;name&quot;);
            //取出book标签的name子标签对象
            System.out.println(name.asXML());
            //调用name标签对象的asXML输出标签+内容
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;name&amp;gt;时间简史&amp;lt;/name&amp;gt;
&amp;lt;name&amp;gt;C++&amp;lt;/name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他常见的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getText();//获取dom对象的内容
elementText(&quot;targetName&quot;);//获取子标签的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jQuery的学习时间拉的有点长了，明天会进入tomcat与servlet的学习&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记（JavaScript）</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0javascript%E4%BA%8B%E4%BB%B6dom%E6%A8%A1%E5%9E%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0javascript%E4%BA%8B%E4%BB%B6dom%E6%A8%A1%E5%9E%8B/</guid><description>JavaScript事件，DOM模型</description><pubDate>Sat, 26 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;h2&gt;JavaScript事件&lt;/h2&gt;
&lt;h3&gt;事件定义&lt;/h3&gt;
&lt;p&gt;事件是电脑输入设备与页面进行交互的响应，称之为事件，如点击滑动，长按等，一下是常用的事件&lt;/p&gt;
&lt;p&gt;onload 加载完成事件（页面代码初始化）&lt;/p&gt;
&lt;p&gt;onclick 点击事件（按钮点击响应操作）&lt;/p&gt;
&lt;p&gt;onblur 失去焦点事件（用于输入框去焦点后验证输入内容是否合法）&lt;/p&gt;
&lt;p&gt;onchange 内容发送改变事件（常用于下拉列表和输入框内容发送改变后）&lt;/p&gt;
&lt;p&gt;onsubmit 表单提交事件（常用于表单提交后验证表单合法性）&lt;/p&gt;
&lt;h3&gt;事件注册&lt;/h3&gt;
&lt;p&gt;定义：又称为绑定，告诉浏览器，事件响应后需要执行的操作代码，又分为静态注册和动态注册&lt;/p&gt;
&lt;p&gt;静态注册：通过html标签的时间属性直接赋予事件响应后的代码&lt;/p&gt;
&lt;p&gt;动态注册：先通过js代码得到dom对象，再通过dom对象.事件名称=function(){}这种形式赋予事件响应后的代码。其基本的步骤为  1.获取标签对象  2.标签对象.事件名称 = function() {}&lt;/p&gt;
&lt;h3&gt;常用事件&lt;/h3&gt;
&lt;h4&gt;onload&lt;/h4&gt;
&lt;p&gt;表单初始化事件&lt;/p&gt;
&lt;p&gt;静态注册示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onLoadFun() {
            alert(&apos;静态注册&apos;);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;onLoadFun();&quot;&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动态注册实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function() {
            alert(&quot;动态注册&quot;);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onclick&lt;/h4&gt;
&lt;p&gt;按钮1为静态注册&lt;/p&gt;
&lt;p&gt;按钮2为动态注册：获取标签对象，通过标签对象.事件名称 = function(){}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickFun() {
            alert(&quot;Hello World&quot;);
        }

        window.onload = function() {
            var obj = document.getElementById(&quot;Button&quot;);
            obj.onclick = onclickFun;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button onclick=&quot;onclickFun()&quot;&amp;gt;按钮1&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;Button&quot;&amp;gt;按钮2&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onblur&lt;/h4&gt;
&lt;p&gt;失去焦点：常用于输入框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnblur(){
            //console是控制台对象，用于向浏览器控制台打印
            console.log(&quot;静态注册失去焦点事件&quot;);
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;password&quot;);
            obj.onblur = function(){
                console.log(&quot;动态注册失去焦点事件&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户名：&amp;lt;input type=&quot;text&quot; onblur=&quot;funOnblur();&quot;&amp;gt;&amp;lt;br/&amp;gt;
密 码：&amp;lt;input id=&quot;password&quot; type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onchange&lt;/h4&gt;
&lt;p&gt;内容改变：常用于下拉列表，和输入框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnChange(){
            //console是控制台对象，用于向浏览器控制台打印
            console.log(&quot;静态注册内容发生更改&quot;);
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;password&quot;);
            obj.onchange = function(){
                console.log(&quot;动态注册内容发生更改&quot;);
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
用户名：&amp;lt;input type=&quot;text&quot; onchange=&quot;funOnChange();&quot;&amp;gt;&amp;lt;br/&amp;gt;
密 码：&amp;lt;input id=&quot;password&quot; type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;onsubmit&lt;/h4&gt;
&lt;p&gt;表单提交事件：用于验证表单项是否合法&lt;/p&gt;
&lt;p&gt;注意当return false的时候不提交，其中在函数中可以加入自己的判断逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function funOnSubmit(){
            alert(&quot;表单提交不合法&quot;)
            return false;
        }
        window.onload = function() {
            var obj = document.getElementById(&quot;submit&quot;);
            obj.onsubmit = function(){
                alert(&quot;表单提交不合法&quot;)
                return false;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form method=&quot;get&quot; action=&quot;https://www.baidu.com&quot;  onsubmit=&quot;return funOnSubmit();&quot;&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密 码：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;form method=&quot;get&quot; action=&quot;https://www.baidu.com&quot; id=&quot;submit&quot;&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        密 码：&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;DOM模型&lt;/h2&gt;
&lt;p&gt;Document Object Model文档对象模型&lt;/p&gt;
&lt;p&gt;将文档中的标签，属性，文本，转化为对象来管理&lt;/p&gt;
&lt;h3&gt;Document对象&lt;/h3&gt;
&lt;p&gt;一个html文档被Document对象存储，并交由Document对象管理&lt;/p&gt;
&lt;p&gt;1.Document管理了所有的HTML文档内容&lt;/p&gt;
&lt;p&gt;2.Document是一种树结构的文档，有层级关系&lt;/p&gt;
&lt;p&gt;3.Document使得所有的标签都对象化&lt;/p&gt;
&lt;p&gt;4.我们可以通过Document访问所有的标签对象&lt;/p&gt;
&lt;h3&gt;入门案例&lt;/h3&gt;
&lt;p&gt;验证输入框中内容是否符合某一个形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickFunction() {
            var userObj = document.getElementById(&quot;username&quot;);//获取输入框对象
            var value = userObj.value;//获取对象（文本框）数据
            //运用正则表达式判断数据是否合法
            var patt = /^\w{5,12}$/;
            if (!patt.test(value)) {
                Warning.innerHTML = &quot;不合法&quot;
            } else {
                Warning.innerHTML = &quot;合法&quot;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        用户名：&amp;lt;input type=&quot;text&quot; id=&quot;username&quot;&amp;gt;
        &amp;lt;span id=&quot;Warning&quot; style=&quot;color: red&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;button onclick=&quot;onclickFunction();&quot;&amp;gt;校验&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;正则表达式&lt;/h3&gt;
&lt;p&gt;以上案例中我们使用到了正则表达式，正则表达式可以为我们判断字符串是否满足某一个模板要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var patt = new RegExp(&quot;e&quot;);//判断是否含有e
    var str = &quot;still&quot;;
    alert(patt.test(str));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var patt = /e/;//判断是否含有e
    var str = &quot;still&quot;;
    alert(patt.test(str));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一些常见的正则表达式，我觉得在这里随用随取即可&lt;/p&gt;
&lt;p&gt;邮箱验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^[^\s@]+@[^\s@]+\.[^\s@]+$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手机号验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^1[3-9]\d{9}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;身份证号码验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;URL验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;密码验证：包含数字字母至少八位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复杂密码（至少1个大写字母、1个小写字母、1个数字和1个特殊字符，至少8位）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;amp;])[A-Za-z\d@$!%*?&amp;amp;]{8,}$/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Document相关方法&lt;/h3&gt;
&lt;h4&gt;getElementById&lt;/h4&gt;
&lt;p&gt;通过标签id获取标签对象，注意只获取第一个符合条件的标签对象&lt;/p&gt;
&lt;p&gt;在上面有演示这里不再过多说明&lt;/p&gt;
&lt;h4&gt;getElementsByName&lt;/h4&gt;
&lt;p&gt;通过标签名称获取标签对象，注意返回所有的标签对象，是一个集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickAll() {
            var hobbies = document.getElementsByName(&quot;hobby&quot;);
            for (var i = 0; i &amp;lt; hobbies.length; i++) {
                hobbies[i].checked = true;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;C++&quot;&amp;gt;C++
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;Java&quot;&amp;gt;Java
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;Python&quot;&amp;gt;Python&amp;lt;br/&amp;gt;
    &amp;lt;button onclick=&quot;onclickAll();&quot;&amp;gt;ALL&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getElementsByTagName&lt;/h4&gt;
&lt;p&gt;按照标签名获取多个标签对象，返回集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function onclickAll() {
            var hobbies = document.getElementsByTagName(&quot;input&quot;);
            for (var i = 0; i &amp;lt; hobbies.length; i++) {
                hobbies[i].checked = true;
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;C++&quot;&amp;gt;C++
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;Java&quot;&amp;gt;Java
    &amp;lt;input type=&quot;checkbox&quot; value=&quot;Python&quot;&amp;gt;Python&amp;lt;br/&amp;gt;
    &amp;lt;button onclick=&quot;onclickAll();&quot;&amp;gt;ALL&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意事项&lt;/h4&gt;
&lt;p&gt;1.以上的三个方法范围从小到大，在实际使用的时候尽量从上到下使用（id，name，Tag）&lt;/p&gt;
&lt;p&gt;2.以上方法需要在页面加载完毕后才可以使用，从上到下依次执行，在没有body加载的时候是没有办法获取得到没有创建的id的&lt;/p&gt;
&lt;h3&gt;节点&lt;/h3&gt;
&lt;p&gt;节点就是标签对象（狭义上讲，程序员可以操作的部分），其中有一些方法供我们使用&lt;/p&gt;
&lt;p&gt;以下是其常用方法和属性&lt;/p&gt;
&lt;h4&gt;方法&lt;/h4&gt;
&lt;p&gt;getElementsByTagName：获取当前节点的指定标签名孩子节点&lt;/p&gt;
&lt;p&gt;appendChild：添加一个子节点，参数是要添加的孩子节点&lt;/p&gt;
&lt;p&gt;createElement&lt;/p&gt;
&lt;p&gt;创建标签对象，再在body中添加子节点标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        window.onload = function () {
            var divObj = document.createElement(&quot;div&quot;);
            divObj.innerHTML = &quot;Hello World&quot;;
            document.body.appendChild(divObj);//通过body对象（自动创建调用方法，添加子节点）
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于文本也算是节点对象，我们还可以通过如下的方式加入节点内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    window.onload = function () {
        var divObj = document.createElement(&quot;div&quot;);
        var text = document.createTextNode(&quot;Hello World&quot;);
        divObj.appendChild(text);
        document.body.appendChild(divObj);
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;属性&lt;/h4&gt;
&lt;p&gt;childNodes：当前节点的所有子节点&lt;/p&gt;
&lt;p&gt;firstChild：当前节点的第一个子节点&lt;/p&gt;
&lt;p&gt;lastChild：当前节点的最后一个子节点&lt;/p&gt;
&lt;p&gt;parentNode：父节点&lt;/p&gt;
&lt;p&gt;nextSibling：下一个节点&lt;/p&gt;
&lt;p&gt;previousSibling：上一个节点&lt;/p&gt;
&lt;p&gt;className：获取或设置class属性值&lt;/p&gt;
&lt;p&gt;innerText：获取或设置起始标签和结束标签中的文本&lt;/p&gt;
</content:encoded></item><item><title>JavaWeb笔记</title><link>https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0htmlcssjavascript/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/javaweb%E7%AC%94%E8%AE%B0htmlcssjavascript/</guid><description>HTML，CSS，JavaScript</description><pubDate>Fri, 25 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JavaWeb笔记&lt;/h1&gt;
&lt;p&gt;学习Redis到了Spring集成Jedis客户端那里的时候碰壁了，学习效率奇低，复盘了一下，发现是Maven和SpringBoot没有学习导致了环境上的问题，所以更改一下学习策略，先进行Java各大框架的学习，再使用Redis进行改进，这样也符合正常的学习规律&lt;/p&gt;
&lt;p&gt;首先是JavaWeb的学习，打算分出12天完成&lt;/p&gt;
&lt;p&gt;Java开发流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/132.png&quot; alt=&quot;132&quot; /&gt;&lt;/p&gt;
&lt;p&gt;页面有三个部分内容组成：内容（html），表现（CSS），行为（JavaScript）&lt;/p&gt;
&lt;p&gt;内容是在页面上可以看到的数据，表现是这些内容在页面上的展示形式（布局颜色大小等），行为是指页面中元素与输入设备交互的响应&lt;/p&gt;
&lt;h2&gt;HTLM&lt;/h2&gt;
&lt;p&gt;Hyper Text Markup Language&lt;/p&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;HTML通过标签来标记显示网页中的各个部分，网页文件本身就是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器中如何显示其中的内容&lt;/p&gt;
&lt;h3&gt;创建HTML文件&lt;/h3&gt;
&lt;p&gt;1.创建一个Web工程&lt;/p&gt;
&lt;p&gt;2.在工程下创建html文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;!-- 约束声明 --&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;!--html表示html开始，lang=zh表示中文，分为head和body--&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;!--头部信息，一般包含title，css，js--&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;!--字符集--&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;&amp;lt;!--标题区域--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    hello world
    你好
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在IDEA下运行html文件打开网页(html文件不需要编译，只需要浏览器解析即可)&lt;/p&gt;
&lt;p&gt;这里我设置的是edge浏览器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Program Files (x86)\Microsoft\Edge\Application\msedge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/133.png&quot; alt=&quot;133&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;标签&lt;/h3&gt;
&lt;p&gt;1.标签的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;标签名&amp;gt;封装的数据&amp;lt;/标签名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.标签名大小写不敏感&lt;/p&gt;
&lt;p&gt;3.标签拥有自己的属性，分为基本属性（修改简单的样式效果）和实践属性（可以直接设置事件响应后的代码）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body bgcolor=&quot;aqua&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    hello world
    你好
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/134.png&quot; alt=&quot;134&quot; /&gt;&lt;/p&gt;
&lt;p&gt;4.标签又分为，单标签、双标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt; &amp;lt;!--换行--&amp;gt;
&amp;lt;hr/&amp;gt; &amp;lt;!--水平线--&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;标签语法&lt;/h3&gt;
&lt;p&gt;标签不可以交叉嵌套&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;&amp;lt;2&amp;gt;内容&amp;lt;/2&amp;gt;&amp;lt;/1&amp;gt; &amp;lt;!--正确--&amp;gt;
&amp;lt;1&amp;gt;&amp;lt;2&amp;gt;内容&amp;lt;/1&amp;gt;&amp;lt;/2&amp;gt; &amp;lt;!--错误，但有些浏览器可以解析--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标签必须要闭合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;br/&amp;gt;&amp;lt;!--正确--&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;!--错误--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性必须要有值，属性值必须有“”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body bgcolor=&quot;aqua&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注释不可以嵌套&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--&amp;lt;!----&amp;gt;--&amp;gt;  &amp;lt;!--错误--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用标签&lt;/h3&gt;
&lt;h4&gt;font标签&lt;/h4&gt;
&lt;p&gt;font改变字体颜色，大小，字体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;/head&amp;gt;
&amp;lt;body onclick=&quot;alert(&apos;警告信息&apos;)&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;hello world&amp;lt;br/&amp;gt;你好&amp;lt;/font&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;特殊字符&lt;/h4&gt;
&lt;p&gt;如果我们想要在浏览器上显示如下特殊字符&amp;lt;br&amp;gt;则&amp;lt;&amp;gt;会被解析，我们需要使用&amp;amp;lt 与 &amp;amp;gt代替&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;
    你好&amp;lt;br&amp;gt;你好
    你好&amp;amp;lt;br&amp;amp;gt;你好
&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与此类似的还有html会裁掉，我们需要保留空格，我们需要使用到&amp;amp;nbsp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body onclick=&quot;alert(&apos;警告信息&apos;)&quot;&amp;gt;&amp;lt;!--主体内容--&amp;gt;
&amp;lt;font color=&quot;#a52a2a&quot; face=&quot;宋体&quot; size=&quot;7&quot;&amp;gt;
    你好&amp;amp;nbsp;&amp;amp;lt;br&amp;amp;gt;&amp;amp;nbsp;你好
&amp;lt;/font&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标题标签&lt;/h4&gt;
&lt;p&gt;h1-h6，h7会显示原文本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;标题&amp;lt;/h2&amp;gt;
    &amp;lt;h3&amp;gt;标题&amp;lt;/h3&amp;gt;
    &amp;lt;h4&amp;gt;标题&amp;lt;/h4&amp;gt;
    &amp;lt;h5&amp;gt;标题&amp;lt;/h5&amp;gt;
    &amp;lt;h6&amp;gt;标题&amp;lt;/h6&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以为标签添加属性，使其左右居中对齐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;h1 align=&quot;left&quot;&amp;gt;标题&amp;lt;/h1&amp;gt;
    &amp;lt;h2 align=&quot;center&quot;&amp;gt;标题&amp;lt;/h2&amp;gt;
    &amp;lt;h3 align=&quot;right&quot;&amp;gt;标题&amp;lt;/h3&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;超链接&lt;/h4&gt;
&lt;p&gt;指定href 连接对象，也可以增加target属性设置点击操作（默认为self）&lt;/p&gt;
&lt;p&gt;blank会打开新的标签页&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标签列表&lt;/h4&gt;
&lt;p&gt;还可以修改列表前的符号，加上type=&quot;none&quot;&lt;/p&gt;
&lt;p&gt;无序列表ul&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;赵四&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;刘能&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;沈阳&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;小宝&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有序列表ol&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;ol&amp;gt;
        &amp;lt;li&amp;gt;赵四&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;刘能&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;沈阳&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;小宝&amp;lt;/li&amp;gt;
    &amp;lt;/ol&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;img标签&lt;/h4&gt;
&lt;p&gt;显示图片&lt;/p&gt;
&lt;p&gt;border是边框大小，alt是找不到显示的文本内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;2.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; border=&quot;1&quot; alt=&quot;404&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/135.png&quot; alt=&quot;135&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;表格标签&lt;/h4&gt;
&lt;p&gt;做一个代表头的，三行三列表格，显示边框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;4&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;5&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;6&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;7&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;8&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;9&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改长宽，边框（border）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table border=&quot;1&quot; width=&quot;400&quot; height=&quot;300&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加th显示表头加增粗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;tr&amp;gt;
    &amp;lt;th&amp;gt;1&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;2&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;3&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cellspacing可以调节格子间的间距一般就使用0即可&lt;/p&gt;
&lt;p&gt;跨行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td colspan=&quot;2&quot;&amp;gt;4&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跨列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td rowspan=&quot;2&quot;&amp;gt;6&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以叠加使用&lt;/p&gt;
&lt;h4&gt;iframe标签&lt;/h4&gt;
&lt;p&gt;可以在html页面上打开一个小窗口加载单独的页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    主页面
    &amp;lt;iframe src=&quot;123.html&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;div、span、p&lt;/h4&gt;
&lt;p&gt;div标签默认独占一行&lt;/p&gt;
&lt;p&gt;span标签长度是封装数据的长度&lt;/p&gt;
&lt;p&gt;p段落标签会在上下各空出一行，如果有则不空&lt;/p&gt;
&lt;h3&gt;表单&lt;/h3&gt;
&lt;h4&gt;入门使用&lt;/h4&gt;
&lt;p&gt;form标签就是表单&lt;/p&gt;
&lt;p&gt;表单用于收集用户信息，把信息发送给服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/136.png&quot; alt=&quot;136&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;!--主体内容--&amp;gt;
    &amp;lt;form&amp;gt;
        用户名称：&amp;lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        用户密码：&amp;lt;input type=&quot;password&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        性别：&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;&amp;gt;男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot;&amp;gt;女&amp;lt;br/&amp;gt;
        兴趣爱好：&amp;lt;input type=&quot;checkbox&quot;&amp;gt;Java&amp;lt;input type=&quot;checkbox&quot;&amp;gt;C++&amp;lt;input type=&quot;checkbox&quot;&amp;gt;Python&amp;lt;input type=&quot;checkbox&quot;&amp;gt;C&amp;lt;br/&amp;gt;
        国籍：&amp;lt;select&amp;gt;
        &amp;lt;option&amp;gt;国籍&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;美国&amp;lt;/option&amp;gt;
        &amp;lt;option selected=&quot;selected&quot;&amp;gt;中国&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;日本&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;&amp;lt;br/&amp;gt;
        自我介绍：&amp;lt;br/&amp;gt;
        &amp;lt;textarea rows=&quot;5&quot; cols=&quot;20&quot;&amp;gt;自我介绍
        &amp;lt;/textarea&amp;gt;
        &amp;lt;input type=&quot;reset&quot; value=&quot;reset&quot;/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;file&quot;/&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的网页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/137.png&quot; alt=&quot;137&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在实际使用的时候可以将所有的表单行放入表格对齐，更加的美观&lt;/p&gt;
&lt;h4&gt;表单提交&lt;/h4&gt;
&lt;p&gt;注意需要将提交表单的对应行都添加上name才能发送到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=https://www.baidu.com method=&quot;get或者post&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get：浏览器浏览器的地址是（action属性[+?+请求参数]），参数是(name=value&amp;amp;name=value...)&lt;/p&gt;
&lt;p&gt;post：可传送requuest主体的表单内容 浏览器地址中只有action，安全，长度无限制&lt;/p&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;p&gt;CSS是层叠样式表单，是用于增强控制网页样式并允许将样式信息和网页内容分离的一种标记性语言&lt;/p&gt;
&lt;h3&gt;语法规则&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;选择器{
	属性: 值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择器：浏览器根据选择器决定受CSS样式影响的HTML元素（标签）&lt;/p&gt;
&lt;p&gt;属性(property)：要改变的样式名，并且每个属性都有一个值，用：隔开，并被{}包围，这样就组成了一个完成的样式声明(declaration) 例如 p{color:blue}&lt;/p&gt;
&lt;p&gt;多个声明：如果定义的不只有一个声明，则需要用分号将每个声明分开&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p {
    color:red;
	font-size:80px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*注释内容*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HTML结合使用&lt;/h3&gt;
&lt;p&gt;入门使用&lt;/p&gt;
&lt;p&gt;设置div和span的样式，这样的可读性差，没复用性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div style=&quot;border: aqua solid 1px&quot;&amp;gt;CSS说明&amp;lt;/div&amp;gt;
    &amp;lt;span style=&quot;border: red solid 1px&quot;&amp;gt;CSS说明&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义样式&lt;/p&gt;
&lt;p&gt;我们可以自定义样式，对所有的特定标签生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style style=&quot;height: auto&quot;&amp;gt;
        div{
            border: 1px solid black;
        }
        span{
            color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;CSS说明&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;CSS说明&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码也是有缺陷的，只可以在同一个页面编辑head内容创建style设置样式，不可以多个页面复用css代码，且维护不方便，我们可以通过如下的方式多页使用&lt;/p&gt;
&lt;p&gt;link引入&lt;/p&gt;
&lt;p&gt;把css样式写成一个单独的css文件，再通过link标签引入即可复用&lt;/p&gt;
&lt;p&gt;编写.css文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div{
    border: 1px solid black;
}
span{
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续修改在.css改即可&lt;/p&gt;
&lt;h3&gt;选择器&lt;/h3&gt;
&lt;h4&gt;标签名选择器&lt;/h4&gt;
&lt;p&gt;可以决定哪些标签被动的使用这个样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        span{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;id选择器&lt;/h4&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#id 属性值{
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id选择器，可以让我们通过id属性选择性的去使用样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        #id001{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        #id002{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;id001&quot;&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span id=&quot;id002&quot;&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;class选择器&lt;/h4&gt;
&lt;p&gt;使用建议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;class&lt;/strong&gt;来定义可重复使用的样式&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;id&lt;/strong&gt;来标识唯一的页面元素（通常用于JS操作或页面锚点）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class 属性值{
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .class01{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }
        .class02{
            border: 5px solid #050505;
            color: red;
            font-size: 20px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;class01&quot;&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span class=&quot;class02&quot;&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组合选择器&lt;/h4&gt;
&lt;p&gt;可以用多个标签去共享样式，id和class也可以&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选择器1, 选择器2, 选择器... {
	属性:值;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;CSS&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div, span{
            border: 1px solid #050505;
            color: #3dc6b1;
            font-size: 20px;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
    &amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用样式&lt;/h3&gt;
&lt;p&gt;color字体颜色，border像素框，weight宽，height高，backgroud-color背景颜色，margin-left（auto）框格式左对齐，text-align（center、right、left）文字设置，text-decoration:none去除超链接&lt;/p&gt;
&lt;h2&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;JavaScript语言最开始最要是为了完成页面的数据验证，运行在客户端，需要运行浏览器来解释执行JavaScript代码&lt;/p&gt;
&lt;h3&gt;特点&lt;/h3&gt;
&lt;p&gt;交互性：可以做信息的动态交互&lt;/p&gt;
&lt;p&gt;安全性：不允许直接访问本地硬盘空间&lt;/p&gt;
&lt;p&gt;跨平台性：只要是可以解释JS的浏览器都可以执行，和平台无关&lt;/p&gt;
&lt;h3&gt;HTML结合使用&lt;/h3&gt;
&lt;p&gt;第一种，在head标签中或者body标签中，使用script标签来书写Javascript代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    alert(&quot;Hello World!&quot;);
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种，为了复用可以将Javascript代码写为一个文件，再导入这个文件到html中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(&quot;Hello World!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;JavaScript&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;Javaweb.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上两者二选一，不可以既选择js，又在同样的标签下写js代码&lt;/p&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;变量可以存放某些值得内存名称，其中JavaScript中有如下的变量类型&lt;/p&gt;
&lt;p&gt;数值类型：number&lt;/p&gt;
&lt;p&gt;字符串类型：string&lt;/p&gt;
&lt;p&gt;对象类型：object&lt;/p&gt;
&lt;p&gt;布尔类型：boolean&lt;/p&gt;
&lt;p&gt;函数类型：function&lt;/p&gt;
&lt;p&gt;以下是JavaScript中特殊的值&lt;/p&gt;
&lt;p&gt;undefined：未定义，所有js变量未赋于初始值的时候，默认都是该类型&lt;/p&gt;
&lt;p&gt;null：空值&lt;/p&gt;
&lt;p&gt;NAN：非数字&lt;/p&gt;
&lt;p&gt;JS定义变量类型格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称;
var 变量名称 = 值
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var i;
alert(i);/*undefined*/
i = 12;
alert(typeof (i));/*number*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运算符&lt;/h3&gt;
&lt;h4&gt;比较运算符&lt;/h4&gt;
&lt;p&gt;相比较于Java中增加了===全等于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i;
i = (12 == &quot;12&quot;);
alert(i);/*true*/
i = (12 === &quot;12&quot;);
alert(i);/*flase*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而所有的变量都可以作为一个boolean类型的变量去使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0,null,undefined,&quot;&quot; /*false*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;逻辑运算符&lt;/h4&gt;
&lt;p&gt;返回确定表达式真假的第一个表达式的值&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;当表达式全为真的情况下，返回最后一个表达式的值&lt;/p&gt;
&lt;p&gt;当表达式有一个为假的时候，返回第一个为假的表达式值&lt;/p&gt;
&lt;p&gt;||&lt;/p&gt;
&lt;p&gt;当表达式全为假的时候，返回最后一个表达式的值&lt;/p&gt;
&lt;p&gt;当表达式有一个为真的时候，返回第一个为真的表达式值&lt;/p&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;var 数组名称 = [];//空数组
var 数组名称 = [1,&apos;abc&apos;,true];//定义数组时赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var arr = [123, 133, 133];
alert(arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用上基本上和java没有区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var arr = [123, 133, 133];
for (var i = 0; i &amp;lt; 2; i++) {
    alert(arr[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;区别&lt;/h4&gt;
&lt;p&gt;JavaScript中的数组，只要通过数组下表赋值，那么数组下标的最大值就会给数组做扩容操作，没有赋值的内容类型是undefined&lt;/p&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;在Javascript中有两种方式定义函数&lt;/p&gt;
&lt;p&gt;第一种：使用function关键字来定义函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function 函数名称(形参列表){
	函数体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    var arr = [123, 133, 1323];
    for (var i = 0; i &amp;lt; 3; i++) {
        alert(arr[i]);
    }
}

fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun(a, b, c) {
    alert(a + &quot; &quot; + b + &quot; &quot; + c);
}

var arr = [123, 133, 1323];
fun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种：由于function在JavaScript中是一种类型，可以进行赋值操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 函数名称 = function(形参列表) {
	函数体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun(a, b, c) {
    alert(a + &quot; &quot; + b + &quot; &quot; + c);
}

anotherFun = fun;
var arr = [123, 133, 1323];
anotherFun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在，Javascript中不允许解析函数的重载，如果函数名称重名会覆盖上一次定义&lt;/p&gt;
&lt;h4&gt;隐形参数&lt;/h4&gt;
&lt;p&gt;在Javascript中存在一个arguments隐藏参数，在function函数体中不需要定义，但是可以获取所有参数的变量，很像Java中的可变参数，操作类似数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    alert(&quot;无参函数fun&quot;);
    alert(arguments[0] + &quot; &quot; + arguments[1] + &quot; &quot; + arguments[2]);
}

anotherFun = fun;
var arr = [123, 133, 1323];
anotherFun(arr[0], arr[1], arr[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function fun() {
    var result = 0;
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        result += arguments[i];
    }
    return result;
}

var number = fun(1, 2, 3, 4, 5);
alert(number);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义对象&lt;/h3&gt;
&lt;h4&gt;Object&lt;/h4&gt;
&lt;p&gt;Object形式自定义对象&lt;/p&gt;
&lt;p&gt;定义格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称 = new Object();//定义空对象
变量名称.属性名 = 值;
变量名称.函数名 = function() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;变量名称.属性名
变量名称.函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var obj = new Object();
obj.id = Math.random();
obj.fun = function(){
    alert(obj.id);
}
obj.fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;{}&lt;/h4&gt;
&lt;p&gt;{}形式的自定义对象&lt;/p&gt;
&lt;p&gt;定义格式（注意各行之间用 , 间隔开，而最后一行不加 , ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 变量名称 = {
    属性名称:值，
    属性名称:值，
    函数名:function(){}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = {
    id:Math.random(),
    fun:function () {alert(obj.id);}
}
obj.fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;今天为JavaWeb开了一个头，感觉学起来还是非常轻松的，尤其是在JavaScript上由于语法和Java大体类似，只需要过一遍就可以很快的掌握语法，并加以使用，而CSS和HTML部分的学习我觉得作为主攻后端开发来说做到随超随用就行，大概了解使用方式即可&lt;/p&gt;
&lt;p&gt;明天会结束JavaScript部分的内容（事件），并开始jQuery的学习&lt;/p&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0java%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>Java客户端，待学部分，等到Java框架学习完成后进行</description><pubDate>Thu, 24 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;h2&gt;Jedis&lt;/h2&gt;
&lt;p&gt;我们学Redis最终还是要回到编码上，我们需要使用到Redis提供的客户端，推荐的有Jedis、lettuce、Redisson&lt;/p&gt;
&lt;p&gt;Jedis，以Redis命令作为方法名称，学习成本较低，简单实用，但是Jedis实例线程不安全，多线程环境下需要基于连接池来使用&lt;/p&gt;
&lt;p&gt;Lettuce，是基于Netty实现的，支持同步，异步，响应式编程方式，线程安全，支持Redis的哨兵模式，集群模式，管道模式&lt;/p&gt;
&lt;p&gt;Redisson，是基于Redis实现的分布式，可伸缩的Java数据结构集合，包含了Map、Queue、Lock、Semaphore、AtomicLong等强大功能&lt;/p&gt;
&lt;p&gt;而其中Spring Data Redis支持jedis和lettuce&lt;/p&gt;
&lt;h3&gt;Jedis使用&lt;/h3&gt;
&lt;p&gt;用Maven添加如下的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.8.1&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;JedisTest&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;JedisTest&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package org.example;

public class Main {
    public static void main(String[] args) {
        JedisTest jedis = new JedisTest();
        jedis.setUP();
        jedis.testString();
        jedis.tearDown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class JedisTest {
    private Jedis jedis;

    public void setUP(){
        jedis = new Jedis(&quot;192.168.104.52&quot;, 6379);
        jedis.auth(&quot;654321&quot;);
        jedis.select(0);
    }

    public void testString() {
        jedis.hset(&quot;hash&quot;, &quot;test&quot;, &quot;value&quot;);
        Map&amp;lt;String, String&amp;gt; hash = jedis.hgetAll(&quot;hash&quot;);
        Set&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entrySet = hash.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Map.Entry&amp;lt;String, String&amp;gt; entry = iterator.next();
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }
    }

    public void tearDown() {
        if(jedis != null) {
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;fieldString1 HelloWorld1
test value
fieldInt 1
fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，所有的jedis指令名称和参数都和redis中的对应，使用起来异常的方便，Hash数据结构中的hgetAll也使用HashMap的形式返回，方便用迭代器进行处理&lt;/p&gt;
&lt;h3&gt;Jedis连接池&lt;/h3&gt;
&lt;p&gt;Jedis本身是线程不安全的，而且频繁地创建和销毁连接会有性能上的损耗，推荐使用Jedis地连接池来替代Jedis地直接连接方式&lt;/p&gt;
&lt;p&gt;封装连接池类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JedisConnectionFactory {
    private static final JedisPool jedisPool;

    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //设置最大连接数
        jedisPoolConfig.setMaxTotal(8);
        //设置最大空闲连接
        jedisPoolConfig.setMaxIdle(8);
        //设置最小空闲连接
        jedisPoolConfig.setMinIdle(8);
        //设置最长等待时间ms
        jedisPoolConfig.setMaxWait(Duration.ofMillis(2000));
        jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.104.52&quot;, 6379, 1000, &quot;654321&quot;);
    }
    //1000 是连接 Redis 服务器的超时时间（毫秒）

    public static Jedis getJedis() {
        return jedisPool.getResource();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Jedis jedis = JedisConnectionFactory.getJedis();
        jedis.set(&quot;key&quot;, &quot;value&quot;);
        String s = jedis.get(&quot;key&quot;);
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SpringDataRedis&lt;/h2&gt;
&lt;p&gt;SpringData是Spring中数据操作的模块，包含对于各种数据库的集成，其中对Redis的集成模块就是SpringDataRedis，总的来说包含了以下的功能&lt;/p&gt;
&lt;p&gt;1.提供了对不同Redis客户端的整合（Lettuce和Jedis）&lt;/p&gt;
&lt;p&gt;2.提供了RedisTemplate统一API操作Redis&lt;/p&gt;
&lt;p&gt;3.支持Redis的发布订阅模型&lt;/p&gt;
&lt;p&gt;4.支持Redis哨兵和Redis集群&lt;/p&gt;
&lt;p&gt;5.支持基于Lettuce的响应式编程&lt;/p&gt;
&lt;p&gt;6.支持基于JDK，JSON，字符串，Spring对象的数据序列化和反序列化&lt;/p&gt;
&lt;p&gt;7.支持基于Redis的JDKCollection实现&lt;/p&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/131.png&quot; alt=&quot;131&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;问题解决&lt;/h3&gt;
&lt;p&gt;IDEA下创建项目SpringBoot发生如下问题，而没有Java更低版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目 SDK &apos;1.8&apos; 不支持所选版本的 Java 17。请选择较低版本的 Java，或设置较高版本的 SDK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以尝试替换源，选择更低版本Java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://start.aliyun.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Maven获取依赖&lt;/p&gt;
&lt;p&gt;如果在使用Maven获取依赖项的时候用时太久可以尝试替换&lt;/p&gt;
&lt;p&gt;配置阿里云镜像&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;~/.m2/settings.xml&lt;/code&gt; 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mirrors&amp;gt;
    &amp;lt;mirror&amp;gt;
        &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
        &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
        &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉学到这里有点寸步难行，redis的各种相关配置，用到的SpringBoot，Maven之类，我都没有接触过，还是得回到Java的开发框架进行学习，Redis教程的进度先耽搁一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
class RedisDataApplicationTests {

    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    void testString() {
        redisTemplate.opsForValue().set(&quot;dataTest&quot;, &quot;李四&quot;);
        Object dataTest = redisTemplate.opsForValue().get(&quot;dataTest&quot;);
        System.out.println(dataTest);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Redis</title><link>https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/redis%E7%AC%94%E8%AE%B0nosqlredis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>NoSQL，Redis数据结构</description><pubDate>Wed, 23 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Redis笔记&lt;/h1&gt;
&lt;p&gt;花了大概两天完成，Java8内容的学习，比预期的要上了短一些，本来打算按照学习计划先进行Java开发框架的学习，但是发现面试的时候Redis考点会更多一点，所以将Redis部分的学习提前，预定大概10天完成（黑马Redis教程）&lt;/p&gt;
&lt;p&gt;教程包括了：八种不同的数据结构，两个消息队列，四个相关的运维操作，Scrip脚本，事务操作&lt;/p&gt;
&lt;h2&gt;NoSQL&lt;/h2&gt;
&lt;p&gt;SQL是关系型数据库，而NoSQL是非关系型数据库&lt;/p&gt;
&lt;h3&gt;与SQL的区别&lt;/h3&gt;
&lt;h4&gt;结构化&lt;/h4&gt;
&lt;p&gt;SQL高度结构化，每个字段每个值都会有严格的要求，一般难以修改。而NoSQL是非结构化的，对于key没有严格要求，支持自定义，还可以键值类型，列类型，文档存储，Graph存储，相对SQL，结构便于修改&lt;/p&gt;
&lt;h4&gt;关联性&lt;/h4&gt;
&lt;p&gt;SQL有外键的约束，数据是相关联的，NoSQL没有关联（程序员手动维护）&lt;/p&gt;
&lt;h4&gt;SQL查询&lt;/h4&gt;
&lt;p&gt;只要是SQL都可以使用相同的查询语句查询，而NoSQL没有固定的语法格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/124.png&quot; alt=&quot;124&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每一个类型的数据查询方式不同&lt;/p&gt;
&lt;h4&gt;事务&lt;/h4&gt;
&lt;p&gt;SQL有事务满足ACID，而NoSQL只满足BASE&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/125.png&quot; alt=&quot;125&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库，以下是Redis的基本特征&lt;/p&gt;
&lt;p&gt;键值型：value支持多种不同数据结构，功能丰富&lt;/p&gt;
&lt;p&gt;单线程：每个命令具备原子性（Redis 6可以多线程处理网络请求）&lt;/p&gt;
&lt;p&gt;高性能：低延迟，速度快（基于内存，IO多路复用，良好的编码【C语言编写】）&lt;/p&gt;
&lt;p&gt;持久化：内存以往是不持久化的，而Redis定期存入磁盘，支持持久化&lt;/p&gt;
&lt;p&gt;高可用：支持主从集群，分片集群&lt;/p&gt;
&lt;p&gt;语言支持：支持多种语言的客户端&lt;/p&gt;
&lt;h3&gt;常用命令&lt;/h3&gt;
&lt;p&gt;我们一般的redis数据库会配置在Linux环境下，之后可以使用Windows的GUI软件RESP来使用Linux下的数据库&lt;/p&gt;
&lt;p&gt;再Linux下装好redis后，可以使用如下的指令&lt;/p&gt;
&lt;p&gt;命令行客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哨兵启动脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在redis.conf中设置，允许访问的地址，密码，是否后台运行等&lt;/p&gt;
&lt;p&gt;再用如下的指令指定配置文件启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用如下指令查找开启的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;杀死对应端口的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -9 2574
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用命令行客户端连接redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;连接成功后，ping和服务端交互&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping
PONG
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以进行存取数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set name jack
OK
127.0.0.1:6379&amp;gt; set age 21
OK
127.0.0.1:6379&amp;gt; get name
&quot;jack&quot;
127.0.0.1:6379&amp;gt; get age
&quot;21&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再windows宿主机使用如下指令连接（虚拟机网络适配器改为桥接连接模式）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli -h 192.168.104.52 -p 6379 -a ******
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用GUI客户端连接&lt;/p&gt;
&lt;p&gt;网址链接： https://github.com/lework/RedisDesktopManager-Windows&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/126.png&quot; alt=&quot;126&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis是一个键值对形式存储的数据库，key一般是String类型的，不过Value的类型非常多种多样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/127.png&quot; alt=&quot;127&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前五种是基本数据类型，后三种是特殊数据类型&lt;/p&gt;
&lt;p&gt;数据类型的具体使用详见 https://redis.io/docs/latest/commands&lt;/p&gt;
&lt;p&gt;如果在连接到redis下的客户端中可以使用如下指令获取帮助&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @数据类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如查看String的相关指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help @String
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Key的层级格式&lt;/h3&gt;
&lt;p&gt;Redis没有类似MySQL中的Table概念，而所有的键值对都是存储在一起的，怎么区分不同类型的key？&lt;/p&gt;
&lt;p&gt;例如需要存储用户，商品信息到redis，一个用户的id是1，而另一个商品id也为1&lt;/p&gt;
&lt;p&gt;而为了解决这类的问题，redis引入了key的层级结构：Redis的key允许有多个单词形成层级结构，多个单词之间用：隔开，格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目名称:业务名称:类型:id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式并非固定不变，可以根据需求删除或者添加词条&lt;/p&gt;
&lt;p&gt;user相关的key：com.user:1&lt;/p&gt;
&lt;p&gt;product相关的key：com.product:1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/128.png&quot; alt=&quot;128&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Redis通用命令&lt;/h3&gt;
&lt;p&gt;虽然有非常多的数据类型以及相关操作，但是其中也有一些通用的命令&lt;/p&gt;
&lt;h4&gt;KEYS&lt;/h4&gt;
&lt;p&gt;查看符合模板的所有key，不建议在Redis服务器端使用，会阻塞所有的其他指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS pattern
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：返回所有的键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回a开头的所有键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS a*
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DEL&lt;/h4&gt;
&lt;p&gt;删除一个指定的键值(例如age)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL age
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以删除多个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEL k1 k2 k3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量插入键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET k1 v1 k2 v2 k3 v3 k4 v4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXISTS&lt;/h4&gt;
&lt;p&gt;判断是否存在键值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXISTS k4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;EXPIRE&lt;/h4&gt;
&lt;p&gt;给一个key设置有效期，有效期到达时key会被删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE key second
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE name 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;TTL&lt;/h4&gt;
&lt;p&gt;查看一个键的有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中返回-1代表永久有效 -2为无效，其余为有效的秒数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TTL k1
(integer) -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;String类型&lt;/h3&gt;
&lt;p&gt;是字符串类型，是Redis中最简单的存储类型，value是字符串，根据不同的格式又分为了三类：String 普通字符串  int 整数类型  float  浮点类型&lt;/p&gt;
&lt;p&gt;无论是哪一种格式存储，底层都是字节数组形式，只是编码方式不同，字符串类型的最大空间不可以超过512M&lt;/p&gt;
&lt;p&gt;以下是String类型常见的命令&lt;/p&gt;
&lt;h4&gt;SET&lt;/h4&gt;
&lt;p&gt;添加或者修改一个存在的String类型的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; set k1 123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;GET&lt;/h4&gt;
&lt;p&gt;根据key获取String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get k1
&quot;123&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MSET&lt;/h4&gt;
&lt;p&gt;批量添加多个String类型的的键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MSET t1 1 t2 2 t3 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MGET&lt;/h4&gt;
&lt;p&gt;根据多个key获取多个String类型的value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MGET k1 k2 k3
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCR&lt;/h4&gt;
&lt;p&gt;让一个整型的key自增1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get 1
&quot;23&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INCR 1
(integer) 24
get 1
&quot;24&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBY&lt;/h4&gt;
&lt;p&gt;让一个整形的key自增并指定步长，例如incrby num 2让num自增2&lt;/p&gt;
&lt;p&gt;在INCR的基础上增加步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INCRBY 1 4
(integer) 28
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;INCRBYFLOAT&lt;/h4&gt;
&lt;p&gt;让一个浮点类型的数字自增并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;append 2 3.1415296
(integer) 9
get 2
&quot;3.1415296&quot;
INCRBYFLOAT 2 1.1
&quot;4.2415296&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETNX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，前提是这个key不存在，否则不执行&lt;/p&gt;
&lt;p&gt;k1以及存在，不执行语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETNX k1 1
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SETEX&lt;/h4&gt;
&lt;p&gt;添加一个String类型的键值对，并且指定有效期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX key seconds value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置键3值12，持续30每秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SETEX 3 30 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者可以这么写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set 3 12 ex 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Hash类型&lt;/h3&gt;
&lt;p&gt;Hash类型，又称为散列，它的value是一个无序字典，类似于Java中的HashMap结构，String结构是将对象序列化为JSON字符串后存储，当需要修改某个字段的时候很不方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/129.png&quot; alt=&quot;129&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而Hash结构可以将对象中的每个字段独立存储，可以针对单个字段作增删改查&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/130.png&quot; alt=&quot;130&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;HSET&lt;/h4&gt;
&lt;p&gt;添加或者修改hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hset key field value
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hset hash1 field value
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGET&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGET key field
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;hget hash1 field
&quot;value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMSET&lt;/h4&gt;
&lt;p&gt;批量添加多个hash类型key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMSET hash1 field2 value2 field3 value3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMGET&lt;/h4&gt;
&lt;p&gt;批量获取多个hash类型的key的field值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMGET hash1 field field1 field2
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HDEL&lt;/h4&gt;
&lt;p&gt;删除指定hash中的某个字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HDEL hash fieldString
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HGETALL&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的key中所有的field和value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HGETALL hash1
1) &quot;field&quot;
2) &quot;value&quot;
3) &quot;field1&quot;
4) &quot;value2&quot;
5) &quot;field2&quot;
6) &quot;value2&quot;
7) &quot;field3&quot;
8) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HKEYS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有field&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HKEYS hash1
1) &quot;field&quot;
2) &quot;field1&quot;
3) &quot;field2&quot;
4) &quot;field3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HVALS&lt;/h4&gt;
&lt;p&gt;获取一个hash类型的所有value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HVALS hash1
1) &quot;value&quot;
2) &quot;value2&quot;
3) &quot;value2&quot;
4) &quot;value3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HINCRBY&lt;/h4&gt;
&lt;p&gt;让一个hash类型key的字段值自增，并指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSET hash fieldInt 1
(integer) 1
HINCRBY hash fieldInt 3
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HSETNX&lt;/h4&gt;
&lt;p&gt;添加一个hash类型key的field值，前提是field不存在，否则不执行（就是不允许修改存在的键的值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HSETNX hash fieldString HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;List类型&lt;/h3&gt;
&lt;p&gt;对于List而言，可以使用该数据类型进行模拟栈：只需要入口和出口在同一边，如LPUSH+LPOP或者RPUSH+RPOP&lt;/p&gt;
&lt;p&gt;也可以模拟一个队列：需要入口和出口在不同边即可，如RPUSH+LPOP或者RPUSH+LPOP&lt;/p&gt;
&lt;p&gt;阻塞队列的模拟：入口出口不同边，取出采用BLPOP或者BRPOP&lt;/p&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p&gt;Redis中的List类型，和Java中的LinkedList类似，可以看作是一个双向链表的结构，既支持正向检索也可以支持反向检索&lt;/p&gt;
&lt;p&gt;特征：有序，元素可以重复，插入和删除较快，查询效率一般&lt;/p&gt;
&lt;p&gt;以下是List的常见命令&lt;/p&gt;
&lt;h4&gt;LPUSH&lt;/h4&gt;
&lt;p&gt;向列表左侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPUSH key element ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPUSH list a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表左侧的第一个元素，没有则返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LPOP key 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LPOP list
&quot;g&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPUSH&lt;/h4&gt;
&lt;p&gt;向列表右侧插入一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPUSH list a b c d e f g h
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RPOP&lt;/h4&gt;
&lt;p&gt;移除并返回列表右侧的第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RPOP list
&quot;h&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;LRANGE&lt;/h4&gt;
&lt;p&gt;返回一段角标范围内的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LRANGE key star end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LRANGE list 1 3
1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BLPOP与BRPOP&lt;/h4&gt;
&lt;p&gt;和LPOP，RPOP类似，只是在没有元素时等待指定时间，而不是返回nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BLPOP list 60
1) &quot;list&quot;
2) &quot;target&quot;
(15.01s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中list本来没有值，进入阻塞等待最多60s，新创建的客户端加入list 数据 target数据被读到&lt;/p&gt;
&lt;h3&gt;Set类型&lt;/h3&gt;
&lt;p&gt;Redis的Set结构和Java中的HashSet类似，可以看为是一个value为null的HashMap，因为是一个hash表，因此具备和HashSet类似的特征：无序，元素不可重复，查找快，支持交集、并集、差集的功能&lt;/p&gt;
&lt;p&gt;以下是Set类型常见的命令&lt;/p&gt;
&lt;h4&gt;SADD&lt;/h4&gt;
&lt;p&gt;向set中添加一个或者多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SADD set a b c d e f g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SREM&lt;/h4&gt;
&lt;p&gt;移除set中的指定元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SREM key member ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SREM set a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SCARD&lt;/h4&gt;
&lt;p&gt;返回set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SCARD set
(integer) 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SISMEMBER&lt;/h4&gt;
&lt;p&gt;判断一个元素是否存在于set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SISMEMBER set g
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SMEMBERS&lt;/h4&gt;
&lt;p&gt;获取set中的所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMEMBERS set
1) &quot;g&quot;
2) &quot;d&quot;
3) &quot;f&quot;
4) &quot;e&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前置操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SADD set1 a b c d e f
SADD set2 a b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SINTER&lt;/h4&gt;
&lt;p&gt;求两个集合的交集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SINTER set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SDIFF&lt;/h4&gt;
&lt;p&gt;求两个集合的差集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDIFF set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;c&quot;
2) &quot;e&quot;
3) &quot;f&quot;
4) &quot;d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SUNION&lt;/h4&gt;
&lt;p&gt;求两个集合的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SUNION set1 set2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;
3) &quot;d&quot;
4) &quot;c&quot;
5) &quot;e&quot;
6) &quot;f&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SortedSet类型&lt;/h3&gt;
&lt;p&gt;Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但是底层数据结构差别巨大，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层是一个跳表（Skip List）加上hash表&lt;/p&gt;
&lt;p&gt;以下是SortedSet的特征：可排序 元素不重复  查询速度快&lt;/p&gt;
&lt;p&gt;因为SortedSet的可排序性，经常用于实现排行榜等功能&lt;/p&gt;
&lt;p&gt;以下是Sorted的常见命令，所有排名默认为升序，降序在命令Z后加REV即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREVRANGE 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZADD&lt;/h4&gt;
&lt;p&gt;添加一个或者多个元素到sorted set，如果与存在则更新其score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZADD key score member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZADD sortedset 1 Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZREM&lt;/h4&gt;
&lt;p&gt;删除sorted set中的一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZREM key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zrem sortedset HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZSCORE&lt;/h4&gt;
&lt;p&gt;获取sorted set中指定元素的score值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZSCORE sortedset Hello
&quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANK&lt;/h4&gt;
&lt;p&gt;获取sorted set中的指定元素排名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANK key member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANK sortedset Hello
(integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCARD&lt;/h4&gt;
&lt;p&gt;获取sorted set中的元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCARD key
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;zcard sortedset
(integer) 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZCOUNT&lt;/h4&gt;
&lt;p&gt;统计指定范围内元素的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZCOUNT sortedset 2 5
(integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZINCRBY&lt;/h4&gt;
&lt;p&gt;让sorted set 中指定score元素自增，指定步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY key increment member
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZINCRBY sortedset 4 1
&quot;22&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定排名范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGE sortedset 0 1
1) &quot;Hello&quot;
2) &quot;World&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZRANGEBYSCORE&lt;/h4&gt;
&lt;p&gt;按照score排序后，获取指定score范围内的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE key min max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ZRANGEBYSCORE sortedset 0 44
1) &quot;Hello&quot;
2) &quot;World&quot;
3) &quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ZDIFF、ZINTER、ZUNION&lt;/h4&gt;
&lt;p&gt;求差集、交集、并集&lt;/p&gt;
&lt;p&gt;和Set类中的类似，不再过多叙述&lt;/p&gt;
</content:encoded></item><item><title>Java8笔记</title><link>https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java8%E7%AC%94%E8%AE%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fstream-apioptional/</guid><description>Lambda表达式，函数式接口，Stream API，Optional</description><pubDate>Sun, 20 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java8笔记&lt;/h1&gt;
&lt;p&gt;拖了一天，本来打算从昨天就开始Java8特性的学习。但是有门事多题难分少的编译原理实验课把自己搞得心烦，晚上就没有精力学习了。&lt;/p&gt;
&lt;p&gt;第二天还要体测，38度的高温，就隔这室外干站着，等半天跑1000米，跑前本来想着4分30以内及格就好，压着脚步跑，结果才4分37，还贼累，险些没给自己跑死。&lt;/p&gt;
&lt;p&gt;到了期中以后了，感觉时间也是慢慢的变得紧张了起来，还是尽量多学一会把，刚回宿舍躺了一小会，算是复活了，总而言之开始今天的学习吧&lt;/p&gt;
&lt;h2&gt;Java8&lt;/h2&gt;
&lt;p&gt;为什么要学习Java8？&lt;/p&gt;
&lt;p&gt;Java8是当今企业中开发最主流的稳定版本，这个版本中出现了很多的新特性，虽然考点不多，但是可以提升Java后端开发程序员的编程效率，值得学习&lt;/p&gt;
&lt;p&gt;相关知识有Lambda表达式、Stream API、Optional&lt;/p&gt;
&lt;p&gt;计划加上今天晚上，明天，后天，一共三天完成相关知识的学习&lt;/p&gt;
&lt;h2&gt;Lambda表达式&lt;/h2&gt;
&lt;p&gt;Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，使用它可以写出更为简洁灵活的代码，代码风格更加紧凑&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;我们用一串代码举例子&lt;/p&gt;
&lt;p&gt;多线程接口Runnable，实现一个类，重写run方法，start调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Thread thread = new Thread(cat);
        thread.start();
    }
}

class Cat implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;cat&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就是用一次这个猫猫类，我们可以稍微用匿名内部类简写一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;cat&quot;);
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们使用以下Lambda表达式来进行改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子，比较类的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = new Comparator&amp;lt;Integer&amp;gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o1, o2);
            }
        };
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda改造&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以直接便捷的实现一个类的实例，如此方便，很人性化不是吗&lt;/p&gt;
&lt;p&gt;其中 -&amp;gt; 就是Lambda操作符，在实际操作中这么写非常的快速，而且很帅，很装&lt;/p&gt;
&lt;h3&gt;具体使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用说明&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(形参列表) -&amp;gt; 重写的抽象方法体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-&amp;gt; 左边Lambda形参列表（是接口中抽象方法的形参列表）&lt;/p&gt;
&lt;p&gt;-&amp;gt; 右边是Lambda体（是重写的抽象方法的方法体）&lt;/p&gt;
&lt;p&gt;Lambda表达式在Java中的本质是接口的实例（万事万物皆对象）&lt;/p&gt;
&lt;p&gt;Lambda表达式的使用，分为六种情况&lt;/p&gt;
&lt;p&gt;1.无参，无返回结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;() -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Runnable runnable = () -&amp;gt; System.out.println(&quot;cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.需要一个参数，没有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (String s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.数据类型可以省略，因为可以由编译器推断得出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(名称) -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = (s) -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.若Lambda只需要一个参数，参数小括号也可以省略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;名称 -&amp;gt; {重写方法体}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; con = s -&amp;gt; {System.out.println(s);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.Lambda需要两个或以上的参数，执行多条语句，有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; {重写方法语句; return ...;}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; {
    System.out.println(o1);
    System.out.println(o2);
    return Integer.compare(o1, o2);}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.当Lambda只有一条语句的时候，大括号可以省略，对return语句return也不用写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(类型 名称, 类型 名称, ...) -&amp;gt; [return] 重写方法体;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Comparator&amp;lt;Integer&amp;gt; comparator = (Integer o1, Integer o2) -&amp;gt; Integer.compare(o1, o2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda表达式的本质实际上是接口的实例，依赖于函数式接口的实现&lt;/p&gt;
&lt;h2&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;如果一个接口中只有一个方法声明，那么这个接口就是函数式接口，可以使用Lambda表达式来进行代码优化（简化）&lt;/p&gt;
&lt;p&gt;接口一般用注解@FunctionalInterface来标示，只允许声明一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Test test = (String o) -&amp;gt; {
            System.out.println(o);
        };
        test.write(&quot;Jerry&quot;);
    }
}

@FunctionalInterface
interface Test{
    void write(String str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以匿名内部类实例的创建，都可以用Lambda表达式来创建，在java.utils.function包下定义了Java8的函数式接口&lt;/p&gt;
&lt;h3&gt;内置核心函数式接口&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;消费型接口Consumer&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;方法void accept(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;供给型接口Supplier&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;方法T get()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;函数型接口Function&amp;lt;T,R&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;方法R apply(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;断定型接口Predicate&amp;lt;T&amp;gt;&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;方法boolean test(T t)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Consumer&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; comsumer = (s) -&amp;gt; System.out.println(s);
        comsumer.accept(&quot;Jerry&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Supplier&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Supplier&amp;lt;Integer&amp;gt; supplier = () -&amp;gt; new Integer(13);
        System.out.println(supplier.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Function&amp;lt;T,R&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Function&amp;lt;Character, Integer&amp;gt; function = (s) -&amp;gt; new Integer(s);
        System.out.println(function.apply(&apos;a&apos;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Predicate&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; {
            if (&quot;hello&quot;.equals(s)) {
                return true;
            }
            return false;
        };
        System.out.println(predicate.test(&quot;he&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法引用&lt;/h3&gt;
&lt;p&gt;当要传递给Lambda体的操作以及有实现的方法了，就可以使用方法引用&lt;/p&gt;
&lt;p&gt;要求：实现接口的抽象方法的参数列表和返回值的类型，必须和方法引用的参数列表和返回值保持一致&lt;/p&gt;
&lt;p&gt;格式：使用&quot;::&quot;将类与方法名隔开&lt;/p&gt;
&lt;p&gt;使用场景&lt;/p&gt;
&lt;p&gt;当接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;h4&gt;情况一&lt;/h4&gt;
&lt;p&gt;对象::实例方法&lt;/p&gt;
&lt;p&gt;Consumer 中的 void accept(T t)&lt;/p&gt;
&lt;p&gt;PrintStream 中的 void println(T t)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; System.out.println(str);
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类对象为System.out 实例方法是println&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Consumer&amp;lt;String&amp;gt; consumer = System.out :: println;
        consumer.accept(&quot;Hello world&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况二&lt;/h4&gt;
&lt;p&gt;类::静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = (o1, o2) -&amp;gt; Integer.compare(o1, o2);
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) {
        Comparator&amp;lt;Integer&amp;gt; comparator = Integer :: compare;
        System.out.println(comparator.compare(1,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;情况三&lt;/h4&gt;
&lt;p&gt;类::实例方法&lt;/p&gt;
&lt;p&gt;前两种使用方式要求：接口中的抽象方法的形参列表和返回值与方法引用的方法的形参列表和返回值类型相同&lt;/p&gt;
&lt;p&gt;而第三种方式可以不严格要求如上的条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = (s1, s2) -&amp;gt; s1.compareTo(s2);
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改造为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Comparator&amp;lt;String&amp;gt; comparator = String :: compareTo;
        System.out.println(comparator.compare(&quot;adf&quot;, &quot;dgb&quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;构造器引用&lt;/h3&gt;
&lt;p&gt;和方法引用类似，函数式接口的抽象方法的形参类型和构造器的形参列表一致&lt;/p&gt;
&lt;p&gt;通过构造器引用可以简化接口返回对应类对象的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = () -&amp;gt; new Employee();
        System.out.println(emp.get());
    }
}

class Employee {
    @Override
    public String toString() {
        return &quot;Employee&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Supplier&amp;lt;Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再举一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = (id) -&amp;gt; new Employee(id);
        System.out.println(emp.apply(123));
    }
}

class Employee {
    private int id;

    public Employee(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return &quot;Employee &quot; + id;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, Employee&amp;gt; emp = Employee :: new;
        System.out.println(emp.apply(123));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组引用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = (id) -&amp;gt; new String[id];
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test02 {
    public static void main(String[] args) {
        Function&amp;lt;Integer, String[]&amp;gt; emp = String[] :: new;
        String[] arr = emp.apply(10);
        System.out.println(arr.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Stream API&lt;/h2&gt;
&lt;h3&gt;前置知识&lt;/h3&gt;
&lt;p&gt;Stream API (java.util.stream)把真正的函数式编程风格引入到Java中，可以用Stream API写出高效、干净、简洁的代码&lt;/p&gt;
&lt;p&gt;Stream是Java8中处理集合的关键抽象概念，可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤和映射数据操作，类似于SQL对数据库的操作（过滤，排序，映射，规约）&lt;/p&gt;
&lt;p&gt;Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的，前者主要面向内存（存储在内存），后者主要面向CPU（通过CPU计算）&lt;/p&gt;
&lt;h3&gt;注意要点&lt;/h3&gt;
&lt;p&gt;1.Stream自己不会存储元素&lt;/p&gt;
&lt;p&gt;2.Stream不会改变源对象，而会返回一个持有结果的Stream&lt;/p&gt;
&lt;p&gt;3.Stream操作是延迟执行的，意味着他们会等到需要结果的时候才会执行&lt;/p&gt;
&lt;p&gt;大体上分为三个步骤 1.创建流 2.中间操作 3.终止操作&lt;/p&gt;
&lt;h3&gt;Stream创建&lt;/h3&gt;
&lt;h4&gt;获取集合流对象&lt;/h4&gt;
&lt;p&gt;Java8中的Collection接口被扩展，提供两个获取流的方法&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; stream() : 返回一个顺序流&lt;/p&gt;
&lt;p&gt;default Stream&amp;lt;E&amp;gt; parallelStream() : 返回一个并行流&lt;/p&gt;
&lt;p&gt;我们现在有如下的ArrayList集合对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        list.add(person1);
        list.add(person2);
        list.add(person3);
        System.out.println(list.size());
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过两个方法获取流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
//获取顺序流（按照顺序取）
Stream&amp;lt;Employee&amp;gt; employeeStream = list.parallelStream();
//获取并行流（按照多个线程取值）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;获取数组流对象&lt;/h4&gt;
&lt;p&gt;以下是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        Employee[] employee = new Employee[3];
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        employee[0] = person1;
        employee[1] = person2;
        employee[2] = person3;
    }
}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Arrays.stream(employee);
//通过Arrays的静态方法调用stream创建流实例
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;静态方法创建流&lt;/h4&gt;
&lt;p&gt;用于直接用数据创建流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = Stream.of(person1, person2, person3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无限流&lt;/p&gt;
&lt;p&gt;迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Integer&amp;gt; limit = Stream.iterate(0, t -&amp;gt; t + 2).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.iterate(0, t -&amp;gt; t + 2).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Double&amp;gt; limit = Stream.generate(Math::random).limit(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Stream.generate(Math :: random).limit(10).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream中间操作&lt;/h3&gt;
&lt;h4&gt;筛选与切片&lt;/h4&gt;
&lt;h5&gt;filter 筛选流&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.filter(e -&amp;gt; e.age &amp;gt; 11);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用filter传入一个判断的Predicate函数式接口，筛选出年龄大于11的Employee对象&lt;/p&gt;
&lt;p&gt;再用终结操作forEach输出结果，这也是一个方法引用&lt;/p&gt;
&lt;h5&gt;limit 截断流&lt;/h5&gt;
&lt;p&gt;只保留几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.limit(2);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里一旦执行了forEach流就结束，不可以再使用中间操作&lt;/p&gt;
&lt;h5&gt;skip 跳过元素&lt;/h5&gt;
&lt;p&gt;跳过前面几个数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.skip(1);
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;distinct 筛选&lt;/h5&gt;
&lt;p&gt;和数据库筛选一样，去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Stream&amp;lt;Employee&amp;gt; employeeStream = stream.distinct();
employeeStream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;映射&lt;/h4&gt;
&lt;h5&gt;map(Function f)&lt;/h5&gt;
&lt;p&gt;接收一个函数作为参数将元素转化为其他形式提取信息（类比于add）&lt;/p&gt;
&lt;p&gt;将List中字符串大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
Stream&amp;lt;String&amp;gt; stream = list.stream();
stream.map(str -&amp;gt; str.toUpperCase()).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;过滤出名字长度大于2的名字（先用map取出name，再用filter过滤）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.map(e -&amp;gt; e.name).filter(str -&amp;gt; str.length() &amp;gt; 2).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;flatMap(Function f)&lt;/h5&gt;
&lt;p&gt;将流中的每一个值都换成另一个流，再将所有的流连接成一个流（类比于addALL）&lt;/p&gt;
&lt;p&gt;和上面的map相比将每个元素取出，转换后再连接&lt;/p&gt;
&lt;p&gt;在对于集合里面嵌套集合的时候使用方便&lt;/p&gt;
&lt;h4&gt;排序&lt;/h4&gt;
&lt;h5&gt;sorted()&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按自然顺序排序（对于实现Comparable接口的对象可以使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted().forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照类中的接口方法排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public int compareTo(Object o) {
    Employee e = (Employee) o;
    return this.age - e.age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;sorted(Comparator com)&lt;/h5&gt;
&lt;p&gt;产生一个新流，其中按比较器顺序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Stream终止操作&lt;/h3&gt;
&lt;h4&gt;匹配查找&lt;/h4&gt;
&lt;p&gt;allMatch&lt;/p&gt;
&lt;p&gt;检查是否匹配所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;anyMatch&lt;/p&gt;
&lt;p&gt;检查一个匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.allMatch(e -&amp;gt; e.age &amp;gt; 15);
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;noneMatch&lt;/p&gt;
&lt;p&gt;检查是否没有匹配元素，例如是否有员工姓“尚”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
boolean b = stream.noneMatch(e -&amp;gt; e.name.startsWith(&quot;尚&quot;));
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findFirst&lt;/p&gt;
&lt;p&gt;返回第一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findFirst();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;findAny&lt;/p&gt;
&lt;p&gt;返回任意一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; first = stream.findAny();
System.out.println(first);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count&lt;/p&gt;
&lt;p&gt;求个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
long count = stream.count();
System.out.println(count);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;min&lt;/p&gt;
&lt;p&gt;返回元素最小值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Employee&amp;gt; min = stream.min(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max&lt;/p&gt;
&lt;p&gt;返回元素最大值（要求传入Comparator）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; max = stream.max(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
);
System.out.println(max);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;forEach&lt;/p&gt;
&lt;p&gt;内部迭代&lt;/p&gt;
&lt;p&gt;传入Consumer c，以下是经典的输出遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
stream.forEach(System.out :: println);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;规约&lt;/h4&gt;
&lt;p&gt;reduce(T identity, BinaryOperator)&lt;/p&gt;
&lt;p&gt;可以将流中的元素反复结合起来，得到一个值，返回这个值&lt;/p&gt;
&lt;p&gt;计算1-10的和（其中0为初始值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream1 {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Integer reduce = list.stream().reduce(0, (i1, i2) -&amp;gt; i1 + i2);
        //Integer reduce = list.stream().reduce(0, Integer::sum);
        System.out.println(reduce);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reduce(BinaryOperator)&lt;/p&gt;
&lt;p&gt;计算所有员工年龄总和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;Employee&amp;gt; stream = list.stream();
Optional&amp;lt;Integer&amp;gt; reduce = stream.map(e -&amp;gt; e.age).reduce(Integer::sum);
System.out.println(reduce);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;collect(Collector c)&lt;/p&gt;
&lt;p&gt;将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法&lt;/p&gt;
&lt;p&gt;放入List中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放入Set中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set&amp;lt;Employee&amp;gt; collect = stream.sorted(
        (e1, e2) -&amp;gt; {
            return e1.age - e2.age;
        }
).collect(Collectors.toSet());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Optional类&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;之前在使用Stream API的时候使用到了Optional类来存储流输出的对象&lt;/p&gt;
&lt;p&gt;Optional&amp;lt;T&amp;gt;是一个容器类，他可以保存类型T的值，代表这个值存在，或者保存null，表示这个值不存在&lt;/p&gt;
&lt;p&gt;原本的null表示一个值不存在，现在Optional可以更好地表示这个概念，并避免空指针异常&lt;/p&gt;
&lt;p&gt;Optional类的Javadoc描述如下：这是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Optional&amp;lt;T&amp;gt; {
    private static final Optional&amp;lt;?&amp;gt; EMPTY = new Optional&amp;lt;&amp;gt;();
    private final T value;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;相关方法&lt;/h3&gt;
&lt;h4&gt;创建方法&lt;/h4&gt;
&lt;p&gt;Optional.of(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t必须非空&lt;/p&gt;
&lt;p&gt;Optional.empty()&lt;/p&gt;
&lt;p&gt;创建一个空的Optional实例&lt;/p&gt;
&lt;p&gt;Optional.ofNullable(T t)&lt;/p&gt;
&lt;p&gt;创建一个Optional实例，t可以为空&lt;/p&gt;
&lt;h4&gt;判断包含&lt;/h4&gt;
&lt;p&gt;boolean isPresent()&lt;/p&gt;
&lt;p&gt;判断是否包含对象&lt;/p&gt;
&lt;p&gt;void isPresent(Consumer&amp;lt;? super T&amp;gt; consumer)&lt;/p&gt;
&lt;p&gt;如果包含对象，就执行Consumer接口的实现代码，并且将该值作为参数传递给它&lt;/p&gt;
&lt;h4&gt;获取对象&lt;/h4&gt;
&lt;p&gt;T get()&lt;/p&gt;
&lt;p&gt;如果调用对象包含值，则返回该值，否则抛出异常&lt;/p&gt;
&lt;p&gt;T orElse(T other)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则返回指定的other对象&lt;/p&gt;
&lt;p&gt;T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)&lt;/p&gt;
&lt;p&gt;如果有值则返回，否则调用Supplier接口实现提供的对象&lt;/p&gt;
&lt;p&gt;T orElse Throw(Supplier&amp;lt;? extends X exceptionSupplier&amp;gt;)&lt;/p&gt;
&lt;p&gt;如果有值则将其返回，否则抛出由Supplier接口实现提供的异常&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;在没有Optional类的时候，我们需要通过if判断语句判断对象不为空，再去调用方法，防止空指针异常，我们在学了Optional类后我们就可以用Optional去包装类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;Employee&amp;gt; optional = Optional.of(new Employee(&quot;李&quot;, 10));
optional.orElse(new Employee(&quot;王&quot;, 10)).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有数据，就用新创建的Employee，调用相关方法&lt;/p&gt;
&lt;p&gt;Optional其实在实际使用上没有多少的内容，主要是有一些底层框架上会使用到Optional来返回结果，懂得如何操作数据对象，看得懂相关操作即可。&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E6%89%B9%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%B1%A0dbutilsbasicdao/</guid><description>批处理，连接池，DBUtils，BasicDao</description><pubDate>Fri, 18 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;批处理&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.当需要成批插入或者更新记录的时候，可以使用Java批处理，这一机制允许多条语句一次性提交给数据库批量处理，通常情况下比单独提交更有效率&lt;/p&gt;
&lt;p&gt;2.JDBC的批量处理语句包括了以下的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;addBatch&lt;/td&gt;
&lt;td&gt;添加需要批量处理的SQL语句或者参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;executeBatch&lt;/td&gt;
&lt;td&gt;执行批量处理语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearBatch&lt;/td&gt;
&lt;td&gt;清空批处理包的语句&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3.JDBC连接MySQL时，如果要使用批处理，需要在url中添加参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?rewriteBatchedStatements=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.批处理往往与PreparedStatement一起搭配使用，可以及减少编译次数又减少运行次数，效率大大提升&lt;/p&gt;
&lt;h3&gt;传统的添加方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.executeUpdate();
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;耗时还是挺久的大概6、7秒钟完成，感兴趣可以输出运行时间测试一下&lt;/p&gt;
&lt;h3&gt;批处理运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;insert into balance values (?,?,?)&quot;;
        PreparedStatement statement = connection.prepareStatement(sql);

        for (int i = 1; i &amp;lt; 1000; i++) {
            statement.setInt(1, i);
            statement.setString(2, &quot;TomCat&quot;);
            statement.setDouble(3, i * 2);
            statement.addBatch();
            if((i + 1) % 1000 == 0) {
                statement.executeBatch();
                statement.clearBatch();
            }
        }
        JDBCUtils.close(null, statement, connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在JDBCUtils工具类中的url添加相关参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase + &quot;?rewriteBatchedStatements=true&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用批处理在处理大量的SQL语句的时候，速度相较于单条执行要快很多，大概的用时只需要1、2秒钟&lt;/p&gt;
&lt;h2&gt;连接池&lt;/h2&gt;
&lt;h3&gt;连接池的引入&lt;/h3&gt;
&lt;p&gt;在传统的连接方式中往往程序和数据库进行网络的连接是多次的，这张方式的连接数上限往往是有限制的，在太多的连接的时候和数据库连接取得Connection的时候会抛出Too many connection的异常，就算及时关闭连接，连接的时长也会很长&lt;/p&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;p&gt;1.传统的JDBC数据库连接使用DriverManager来获取，每一次向数据库建立连接的时候都要将Connection加载到内存中，再验证IP地址，用户名，密码（0.05-1s）。需要数据库链接的时候，就会向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃&lt;/p&gt;
&lt;p&gt;2.每一次数据库连接，使用完后都得断开，如果程序出现异常未能关闭，将导致数据库内存泄漏，最终导致重启数据库&lt;/p&gt;
&lt;p&gt;3.传统获取连接的方式，不能控制创建的连接数量，如果连接过多，也可能导致内存泄漏，数据库崩溃&lt;/p&gt;
&lt;p&gt;4.解决传统开发中的数据库连接问题，可以采用数据库连接池技术（connection pool）&lt;/p&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.预先在缓冲池中放入一定数量的连接，当需要建立数据据库连接的时候，只需要从缓冲池中取出连接，使用完毕的时候再将连接放回缓冲池中即可&lt;/p&gt;
&lt;p&gt;2.数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用现有的数据库连接，而不是重新建立一个&lt;/p&gt;
&lt;p&gt;3.当应用程序向连接池请求的连接数超过最大连接数的时候，这些请求将被添加入等待队列&lt;/p&gt;
&lt;h3&gt;数据库连接池种类&lt;/h3&gt;
&lt;p&gt;1.JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方来实现&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;C3P0&lt;/strong&gt;数据库连接池，速度相对较慢，但是稳定性不错（hibernate，spring）&lt;/p&gt;
&lt;p&gt;3.DBCP数据库连接池，速度相比于C3P0较快，但是不稳定&lt;/p&gt;
&lt;p&gt;4.Proxool数据库连接处，有监控连接池状态的功能，稳定性较C3P0差一点&lt;/p&gt;
&lt;p&gt;5.BoneCP数据库连接池，速度快&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;Druid&lt;/strong&gt;（德鲁伊）是由阿里提供的数据库连接池，集以上（C3P0、DBCP、Proxool）数据库优点于一体的数据库连接池&lt;/p&gt;
&lt;p&gt;C3P0和德鲁伊连接池是目前经常会使用的连接池，我们接下来使用的也是这两个&lt;/p&gt;
&lt;h3&gt;C3P0连接池&lt;/h3&gt;
&lt;p&gt;注意在连接池中的close不是指的是将连接断开，而是将连接放回到连接池中，供下一个getConnection使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void test01() throws Exception{
    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
    String agreement = &quot;jdbc:mysql:&quot;;
    String address = &quot;localhost&quot;;
    String port = &quot;3306&quot;;
    String dataBase = &quot;jdbc&quot;;
    String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
    String user = &quot;root&quot;;
    String password = &quot;654321&quot;;
    String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;

    //设置连接池基础信息
    comboPooledDataSource.setDriverClass(driver);
    comboPooledDataSource.setJdbcUrl(url);
    comboPooledDataSource.setUser(user);
    comboPooledDataSource.setPassword(password);

    //初始化连接数
    comboPooledDataSource.setInitialPoolSize(10);
    comboPooledDataSource.setMaxPoolSize(50);

    //从连接池中获取连接
    Connection connection = comboPooledDataSource.getConnection();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过这种方式创建连接相比于JDBC的从DriverManager获取连接要快很多&lt;/p&gt;
&lt;p&gt;除此之外你还可以使用配置文件设置连接池的基础信息（在创建连接池对象的时候指定配置文件参数），感兴趣的可以下去了解&lt;/p&gt;
&lt;h3&gt;Druid连接池&lt;/h3&gt;
&lt;h4&gt;连接池基本配置&lt;/h4&gt;
&lt;p&gt;我们在使用Druid连接池的时候需要使用到配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 数据库连接配置
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/tableselect?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;characterEncoding=utf8
username=root
password=654321

# 连接池核心参数
initialSize=10
maxActive=50
minIdle=5
maxWait=60000
#maxWait指的是等待队列中最长的等待时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;连接池使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        testDruid();
    }

    public static void testDruid() throws Exception {
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
        //创建连接池对象
        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
        //过去Connection连接
        Connection connection = dataSource.getConnection();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Druid速度非常快，目前而言能用Druid尽量别用C3P0，除非要进行兼容&lt;/p&gt;
&lt;h4&gt;工具类封装&lt;/h4&gt;
&lt;p&gt;便于使用者使用，我们将德鲁伊连接池做成一个工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.utils;
import com.alibaba.druid.pool.DruidDataSourceFactory;
import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用测试方法调用，这样做会方便很多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void testUtils() {
    Connection connection = JDBCUtilsDruid.getConnection();
    JDBCUtilsDruid.close(null, null, connection);
    //这里用的是工具类的close方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再多说一嘴，其实这种情况下使用connection.close()方法关闭连接也没有问题，因为通过动态绑定机制，connection实际上调用的是德鲁伊的close方法。这个方法和通过DriverManager创建的连接调用的close方法有本质的区别，不会将链接关闭，而是将连接放回连接池中&lt;/p&gt;
&lt;h2&gt;DBUtils&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;当我们关闭connection后，resultSet结果集无法使用（二者相关联），而有的时候我们需要复用resultSet中的数据，关闭connection后任需要结果集&lt;/p&gt;
&lt;p&gt;resultSet不利于数据的管理，使用起来也不太方便，这个时候我们需要再Java程序中创建一个类（JavaBean）与数据库的记录做一个映射，再创建一个结果集记录封装在ArrayList&amp;lt;JavaBean&amp;gt;下，每一个集合元素对应一条记录&lt;/p&gt;
&lt;p&gt;这样的话我们使用类来获取数据就会方便一些，而且生命期更加持久，可以在不用的时候再将ArrayList集合对象释放（以上的思路可以去自己实现，以下是一个Apache提供的一个工具类，相比于自己写的更加完善方便）&lt;/p&gt;
&lt;h3&gt;commons-dbutils&lt;/h3&gt;
&lt;h4&gt;基本介绍&lt;/h4&gt;
&lt;p&gt;commons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils可以极大地简化JDBC编码的工作量&lt;/p&gt;
&lt;h4&gt;DBUtils类&lt;/h4&gt;
&lt;p&gt;1.QueryRunner类：该类封装了SQL的执行，是线程安全的，可以实现增删改查，批处理&lt;/p&gt;
&lt;p&gt;2.ResultSetHandler接口：该接口用于处理ResultSet，将数据按要求转化为另一种形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/123.png&quot; alt=&quot;123&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;构造返回记录类型&lt;/h4&gt;
&lt;p&gt;要使这个自动映射正常工作，&lt;code&gt;Balance&lt;/code&gt;类需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个标准的JavaBean（有无参构造函数）&lt;/li&gt;
&lt;li&gt;有与数据库列名对应的属性&lt;/li&gt;
&lt;li&gt;有这些属性的setter方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造一个Balance接收返回结果的类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查询结果&lt;/h4&gt;
&lt;p&gt;利用QueryRunner对象查询数据库返回结果&lt;/p&gt;
&lt;p&gt;返回单条单列的记录（返回一个Object对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select `name` from balance where id = ?;&quot;;
        String name = (String) queryRunner.query(connection, sql, new ScalarHandler(), 100);
        System.out.println(name);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回单条记录（返回一个对应的Balance对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ?;&quot;;
        Balance balance = queryRunner.query(connection, sql, new BeanHandler&amp;lt;&amp;gt;(Balance.class), 100);
        System.out.println(balance);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回多条结果（返回一个存放了Balance对象的ArrayList）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;select * from balance where id = ? or id = ?;&quot;;
        List&amp;lt;Balance&amp;gt; list = queryRunner.query(connection, sql, new BeanListHandler&amp;lt;&amp;gt;(Balance.class), 100, 200);
        //这里的100和200是可变参数，代表填入的替换？的内容
        Iterator&amp;lt;Balance&amp;gt; iterator = list.iterator();
        while(iterator.hasNext()) {
            Balance balance = iterator.next();
            System.out.println(balance);
        }
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果步入源码中我们可以发现在query方法执行获取ArrayList结果集的过程中用到的Statement和ResultSet就已经被关闭&lt;/p&gt;
&lt;p&gt;而返回的结果类型取决于第三个参数的类型，其中result返回结果底层运用到了泛型来确定result的返回类型（更具不同的参数类型有不同的处理逻辑）&lt;/p&gt;
&lt;h4&gt;增删改&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;delete from balance;&quot;;
        int update = queryRunner.update(connection, sql);
        System.out.println(update);
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Druid_ {
    public static void main(String[] args) throws Exception {
        Connection connection = JDBCUtilsDruid.getConnection();
        QueryRunner queryRunner = new QueryRunner();
        //通过使用queryRunner就可以查询数据库，返回结果
        String sql = &quot;update balance set name = &apos;Cat&apos;&quot;;
        int update = queryRunner.update(connection, sql);
        //返回的结果是受影响的行数
        System.out.println(update);//2
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;BasicDao&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;1.SQL语句是固定的，不可以通过参数传入，使用起来不灵活&lt;/p&gt;
&lt;p&gt;2.对于select操作，返回类型不确定，需要使用到泛型&lt;/p&gt;
&lt;p&gt;3.对于很多表而言，业务负责不可能单靠一个Java类完成&lt;/p&gt;
&lt;h3&gt;Dao&lt;/h3&gt;
&lt;p&gt;data access object 数据访问对象&lt;/p&gt;
&lt;p&gt;我们对于每一个表都会有相应的操作，我们可以将这一些操作的共有部分提到BasicDao中，这样做可以简化代码，维护可读性&lt;/p&gt;
&lt;p&gt;1.这样的通用类我们称为BasicDao，是专门和数据库交互的，即完成数据库的增删改查操作&lt;/p&gt;
&lt;p&gt;2.再BasicDao的基础上，实现一张表对应一个Dao，可以更好的完成功能&lt;/p&gt;
&lt;p&gt;接下来我们就通过代码实际实现Dao&lt;/p&gt;
&lt;h3&gt;Dao实现&lt;/h3&gt;
&lt;p&gt;设计com.dao&lt;/p&gt;
&lt;h4&gt;com.dao.utils&lt;/h4&gt;
&lt;p&gt;工具类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtilsDruid {
    private static DataSource ds;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if (result != null) {
                result.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.domain&lt;/h4&gt;
&lt;p&gt;javabean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Balance {
    private int id;
    private String name;
    private String money;
    public Balance(){}

    @Override
    public String toString() {
        return id + &quot; &quot; + name + &quot; &quot; + money;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setMoney(String money) {
        this.money = money;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;com.dao.dao&lt;/h4&gt;
&lt;p&gt;存放BasicDao&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BasicDao&amp;lt;T&amp;gt; {//使用泛型指定具体类型
    private QueryRunner qr = new QueryRunner();

    //开发通用的dml方法，针对任意的表
    public int update(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.update(connection, sql, parameters);
            //返回受影响的行数，执行语句
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回对个查询对象
    public List&amp;lt;T&amp;gt; queryMulti(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //返回查询单行结果
    public T querySingle(String sql, Class&amp;lt;T&amp;gt; cls, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler&amp;lt;T&amp;gt;(cls), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }

    //查询单行单列的方法
    public Object queryScalar(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler(), parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsDruid.close(null, null, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们根据BasicDao来开发针对于balance表的Dao，制定了前面我们设计的BasicDao的泛型T为Balance类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BalanceDao extends BasicDao&amp;lt;Balance&amp;gt;{
    //拥有BasicDao方法
    //除此之外还可以自定义其他的方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出在没有特殊要求的情况下，我们只需要在继承的时候指定泛型类型即可创建出新的对应表Dao，非常的方便&lt;/p&gt;
&lt;h4&gt;com.dao.test&lt;/h4&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestDao {
    public static void main(String[] args) {
        BalanceDao balanceDao = new BalanceDao();

        String sql = &quot;select * from balance&quot;;
        List&amp;lt;Balance&amp;gt; balances = balanceDao.queryMulti(sql, Balance.class);
        for(Balance balance : balances) {
            System.out.println(balance);
        }

        sql = &quot;select * from balance where id = ?&quot;;
        Balance balance = balanceDao.querySingle(sql, Balance.class, 100);
        System.out.println(balance);

        sql = &quot;select name from balance where id = 100&quot;;
        String name =(String) balanceDao.queryScalar(sql);
        System.out.println(name);

        sql = &quot;insert into balance values (300, &apos;Tom&apos;, 4000), (400, &apos;King&apos;, 5000);&quot;;
        int update = balanceDao.update(sql);
        System.out.println(update);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看的出来还是非常方便的啊&lt;/p&gt;
&lt;h4&gt;补充&lt;/h4&gt;
&lt;p&gt;其实你要在方便一点（不想要传入Balance.class）的话还可以在BasicDao中用反射获取T类对象，将类对象传入&lt;/p&gt;
&lt;h1&gt;JDBC结语&lt;/h1&gt;
&lt;p&gt;两天的时间，学的还是挺快的，过了一遍代码，学会了使用方式，对于JDBC，连接池，DB工具，自建BasicDao有了初步的认识，对于底层的代码看了一眼，不算完全掌握&lt;/p&gt;
&lt;p&gt;反思了以下自己泛型的部分掌握还不足，决定回宿舍复习一下泛型相关的内容&lt;/p&gt;
&lt;p&gt;明天打算开始Java8特性的学习，计划三天完成，估计我的有一个面试在三天之后，面试结束再决定Java8后学哪一个开发框架，在此之前先准备下面试，背下八股之类的&lt;/p&gt;
</content:encoded></item><item><title>JDBC笔记</title><link>https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/jdbc%E7%AC%94%E8%AE%B0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1sql%E6%B3%A8%E5%85%A5%E5%B0%81%E8%A3%85%E4%BA%8B%E5%8A%A1/</guid><description>快速入门，执行对象，SQL注入，封装，事务</description><pubDate>Thu, 17 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;JDBC笔记&lt;/h1&gt;
&lt;h2&gt;JDBC&lt;/h2&gt;
&lt;p&gt;JDBC是JAVA程序操作数据库的一种技术，在绝大多数的框架中JDBC一般都被封装在了各式各样的框架之中，这些框架之后也会学习。但是掌握JDBC是如何连接数据库，操作数据库，返回数据库结果，使用数据库返回结果这也是一个后端开发者应该掌握的基础，掌握了之后对后续框架的理解也是一种帮助&lt;/p&gt;
&lt;p&gt;Java对于各大数据库厂商提供了一个连接操作的统一接口，其中定义的方法包括了连接、curd、关闭连接等。而数据库工资负责实现这一些接口，方便Java的开发者利用数据库接口去创建对应数据库实例的创建，再通过动态绑定机制调用数据库实现的相关方法，以下是一个代码示例方便理解（仅仅是模拟，不代表实际开发）&lt;/p&gt;
&lt;p&gt;Java数据库接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface JdbcInterface {
    public Object getConnection();
    public void crud();
    public void close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库实现接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MysqlJdbcImpl implements JdbcInterface{
    @Override
    public Object getConnection() {
        System.out.println(&quot;连接数据库&quot;);
        return null;
    }

    @Override
    public void crud() {
        System.out.println(&quot;增删改查&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;关闭数据库&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际操作的时候可以创建数据库的对象实例，再调用相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        JdbcInterface jdbc = new MysqlJdbcImpl();
        jdbc.getConnection();
        jdbc.crud();
        jdbc.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也是接口编程的一个极大优势，无需要更改接口定义，只需要让各自的工具实现公开的接口，就可以完成调用&lt;/p&gt;
&lt;h2&gt;JDBC快速入门&lt;/h2&gt;
&lt;p&gt;其中我们要用到的有两个包，一个是 java.sql 另一个是 javax.sql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/121.png&quot; alt=&quot;121&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/122.png&quot; alt=&quot;122&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;JDBC编写的步骤&lt;/h3&gt;
&lt;p&gt;1.注册驱动-加载Driver类&lt;/p&gt;
&lt;p&gt;2.获取连接-得到Connection&lt;/p&gt;
&lt;p&gt;3.执行增删改查-执行sql语句&lt;/p&gt;
&lt;p&gt;4.释放资源-关闭释放&lt;/p&gt;
&lt;h3&gt;程序示例&lt;/h3&gt;
&lt;p&gt;我们通过jdbc对dept表进行增删改查操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们首先需要对于项目安装驱动详细内容见教程&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/pan_junbiao/article/details/86626741&lt;/p&gt;
&lt;p&gt;将得到的驱动添加到库中&lt;/p&gt;
&lt;p&gt;在引入包的时候注意版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.mysql.cj.jdbc.Driver;  // MySQL 8.x
// 或
import com.mysql.jdbc.Driver;     // MySQL 5.x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class JDBC01 {
    public static void main(String[] args) throws SQLException {
        //将驱动文件添加入库
        //1.注册驱动-加载Driver类
        Driver driver = new Driver();

        //2.获取连接-得到Connection
        String agreement = &quot;jdbc:mysql:&quot;;
        String address = &quot;localhost&quot;;
        String port = &quot;3306&quot;;
        String dataBase = &quot;jdbc&quot;;
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        //将用户密码放入properties
        Properties properties = new Properties();
        properties.setProperty(&quot;user&quot;, &quot;root&quot;);
        properties.setProperty(&quot;password&quot;, &quot;654321&quot;);
        Connection connect = driver.connect(url, properties);

        //3.执行增删改查-执行sql语句
        String sql = &quot;INSERT INTO dept VALUES (10,&apos;ACCOUNTING&apos;,&apos;NEW YORK&apos;);&quot;;
        //创建一个Statement对象
        Statement statement = connect.createStatement();
        int rows = statement.executeUpdate(sql);
        //返回生效的行数，这个时候返回1代表成功
        System.out.println(rows &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

        //4.释放资源-关闭释放
        statement.close();
        connect.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看数据库发现数据库中成功的添加了相关数据&lt;/p&gt;
&lt;h4&gt;动态加载&lt;/h4&gt;
&lt;p&gt;其实上述的代码中的静态加载方式可以改进为利用反射动态链接，可以更加灵活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
Driver driver = (Driver)cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且通过动态加载，我们实际上可以不用创建Driver实例加载，因为静态代码块在类加载的时候，底层以及将Driver驱动已经帮我们加载好了&lt;/p&gt;
&lt;h4&gt;DriverManager&lt;/h4&gt;
&lt;p&gt;用DriverManager替代Manager，好处是不用Properties以及扩展性好一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String user = &quot;root&quot;;
String password = &quot;654321&quot;;
DriverManager.registerDriver(driver);
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综上所述，我们的代码可以更改为如下（推荐使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//1.注册驱动-加载Driver类
Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

//2.获取连接-得到Connection
String agreement = &quot;jdbc:mysql:&quot;;
String address = &quot;localhost&quot;;
String port = &quot;3306&quot;;
String dataBase = &quot;jdbc&quot;;
String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;

String user = &quot;root&quot;;
String password = &quot;654321&quot;;
Connection connect = DriverManager.getConnection(url, user, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;甚至在驱动更高级的版本（5.1.7）中你甚至可以不用Driver加载，但还是建议写上，避免多个驱动混用混乱&lt;/p&gt;
&lt;h4&gt;最终推荐的方案&lt;/h4&gt;
&lt;p&gt;我们除了使用动态加载驱动，用DriverManager管理连接，我们还可以将我们的连接数据库写的更加灵活一点，写一个配置文件，让程序从配置文件中读取连接对象，用户密码等&lt;/p&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;agreement=jdbc:mysql:
address=localhost
port=3306
dataBase=jdbc
user=root
password=654321
driver=com.mysql.cj.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    @SuppressWarnings ({&quot;all&quot;})
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);
        Statement statement = connection.createStatement();
        String sql = &quot;select deptno,dname,loc from dept&quot;;
        ResultSet resultSet = statement.executeQuery(sql);

        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;结果集&lt;/h3&gt;
&lt;p&gt;我们在使用JDBC执行查询语句的时候需要用结果集ResultSet来存储返回的结果&lt;/p&gt;
&lt;p&gt;ResultSet表示数据库结果集数据表，通常由执行查询数据库的语句生成，ResultSet对象保持一个光标指向其当前行的数据行&lt;/p&gt;
&lt;p&gt;最初，光标只想第一行之前，next方法将光标指向下一行，并且在没有行的时候返回false，可以使用while循环来遍历结果集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//3.执行增删改查-执行sql语句
//创建一个Statement对象
Statement statement = connect.createStatement();
String sql = &quot;select ename,job,deptno from emp&quot;;
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    String ename = result.getString(1);
    String job = result.getString(2);
    int deptno = result.getInt(3);
    System.out.println(ename + &quot;\t&quot; + job + &quot;\t&quot; + deptno);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMITH	CLERK		20
ALLEN	SALESMAN	30
WARD	SALESMAN	30
JOOES	MANAGER		20
MARTIN	SALESMAN	30
BLAKE	MANAGER		30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实结果集的底层是一个ArrayList，包含了一个对象数组包含了各行的数据&lt;/p&gt;
&lt;h2&gt;执行对象&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.Statement对象用于执行静态SQL语句并返回其生成的结果对象&lt;/p&gt;
&lt;p&gt;2.在建立连接后，需要对数据库进行访问，执行命令或者是SQL语句可以通过Statement PreparedStatement CallableStatement（依次继承前者）来完成&lt;/p&gt;
&lt;p&gt;3.Statement对象执行SQL语句，存在SQL注入风险&lt;/p&gt;
&lt;p&gt;4.SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，在用户输入数据中注入非法的SQL语句段或者命令，以此恶意攻击数据库&lt;/p&gt;
&lt;p&gt;5.要防范SQL注入只要用PreparedStatement取代Statement即可&lt;/p&gt;
&lt;h3&gt;SQL注入&lt;/h3&gt;
&lt;p&gt;在历史中曾有运用SQL注入来攻破数据库的案例，例如如下是一个用户登陆的案例，我们需要使用用户名称以及用户密码来查找出用户用以登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;user&apos; and pwd = &apos;password&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中target用我们用户输入的内容替换，正常的情况中输入正确的用户以及密码即可找到对应的用户，但是通过SQL注入我们输入的用户密码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = 1&apos; or
password = or &apos;1&apos; = &apos;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将用户以及密码替换到数据库语句中就会发生以下情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&apos;1&apos; = &apos;1&apos;显然是满足条件的，以此我们得到了所有用户的记录，以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.print(&quot;输入用户名称：&quot;);
String inputName = scanner.nextLine();
System.out.print(&quot;输入用户密码：&quot;);
String inputPwd = scanner.nextLine();
String sql = &quot;select id,name,pwd from admin where name = &apos;&quot; + inputName + &quot;&apos; and pwd = &apos;&quot; + inputPwd + &quot;&apos;;&quot;;
System.out.println(sql);
//使用executeQuery返回结果集
ResultSet result = statement.executeQuery(sql);
//通过while循环输出结果集
while(result.next()) {
    int id = result.getInt(1);
    String name = result.getString(2);
    String pwd = result.getString(3);

    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + pwd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：1&apos; or
输入用户密码：or &apos;1&apos; = &apos;1
select id,name,pwd from admin where name = &apos;1&apos; or&apos; and pwd = &apos;or &apos;1&apos; = &apos;1&apos;;
2	user1	password1
3	user2	password2
4	user3	password3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你想要查看一个指定的用户（密码随意）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入用户名称：user2&apos; -- 
输入用户密码：123
select id,name,pwd from admin where name = &apos;user2&apos; -- &apos; and pwd = &apos;123&apos;;
3	user2	password2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是非常危险的，这个时候我们就需要使用到新的PreparedStatement对象来防止SQL注入的发生&lt;/p&gt;
&lt;h3&gt;PreparedStatement&lt;/h3&gt;
&lt;p&gt;1.PreparedStatement执行的SQL语句中的参数用?来表示，调用PreparedStatement对象的setXxx()方法来设置这些参数，setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引，从1开始，第二个是设置SQL语句中的参数值&lt;/p&gt;
&lt;p&gt;2.调用executeQuery() 返回ResultSet对象&lt;/p&gt;
&lt;p&gt;3.调用executeUpdate() 来执行增删改操作&lt;/p&gt;
&lt;p&gt;通过这样的对象我们不用+进行sql的拼接，减少语法错误的概率，还可以解决sql注入的问题，大大减少了编译的次数，效率较高&lt;/p&gt;
&lt;p&gt;具体使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        String driver = properties.getProperty(&quot;driver&quot;);

        String agreement = properties.getProperty(&quot;agreement&quot;);
        String address = properties.getProperty(&quot;address&quot;);
        String port = properties.getProperty(&quot;port&quot;);
        String dataBase = properties.getProperty(&quot;dataBase&quot;);

        Class.forName(driver);
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        Connection connection = DriverManager.getConnection(url, user, password);

        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        //其中的？代表占用符号
        PreparedStatement statement = connection.prepareStatement(sql);
        //PreparedStatement是Java提供的接口，具体的实现类看数据库厂商如何实现
        statement.setInt(1, 10);
        ResultSet resultSet = statement.executeQuery();
        //执行查询时不写sql，因为创建preparedstatement时使用sql创建
        while(resultSet.next()) {
            int deptno = resultSet.getInt(1);
            String dname = resultSet.getString(2);
            String loc = resultSet.getString(3);
            System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
        }
        resultSet.close();
        statement.close();
        connection.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;10 ACCOUNTING NEW YORK
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三者对比&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Statement&lt;/th&gt;
&lt;th&gt;PreparedStatement&lt;/th&gt;
&lt;th&gt;CallableStatement&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SQL预编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;防SQL注入&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数化查询&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调用存储过程&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用频率&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;JDBC封装&lt;/h2&gt;
&lt;p&gt;在jdbc操作中其实获取链接和释放操作都是我们会经常用到的，每一次都重写一遍其实非常的浪费时间，我们这个时候就有必要封装一个JDBC的工具模块来供自己调用&lt;/p&gt;
&lt;h3&gt;封装示例&lt;/h3&gt;
&lt;p&gt;以下是一个封装示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JDBCUtils {
    //定义相关属性
    private static final String user;
    private static final String password;
    private static final String driver;
    private static final String agreement;
    private static final String address;
    private static final String port;
    private static final String dataBase;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));
            user = properties.getProperty(&quot;user&quot;);
            password = properties.getProperty(&quot;password&quot;);
            driver = properties.getProperty(&quot;driver&quot;);
            agreement = properties.getProperty(&quot;agreement&quot;);
            address = properties.getProperty(&quot;address&quot;);
            port = properties.getProperty(&quot;port&quot;);
            dataBase = properties.getProperty(&quot;dataBase&quot;);
            Class.forName(driver);
        } catch (Exception e) {
            //在实际开发中往往转为一个运行时异常抛出
            throw new RuntimeException(e);
            //调用者可以选择捕获异常或者默认处理
        }
    }

    public static Connection getConnection() {
        String url = agreement + &quot;//&quot; + address + &quot;:&quot; + port + &quot;/&quot; + dataBase;
        try {
            return DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public static void close(ResultSet result, Statement statement, Connection connection) {
        try {
            if(result != null) {
                result.close();
            }
            if(statement != null) {
                statement.close();
            }
            if(connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;测试代码&lt;/h3&gt;
&lt;p&gt;接下来我们用测试代码进行调用测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql = &quot;select deptno,dname,loc from dept where deptno = ?&quot;;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql);
            statement.setInt(1, 10);
            resultSet = statement.executeQuery();
            while(resultSet.next()) {
                int deptno = resultSet.getInt(1);
                String dname = resultSet.getString(2);
                String loc = resultSet.getString(3);
                System.out.println(deptno + &quot; &quot; + dname + &quot; &quot; + loc);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样相较于前文中的全部代码不光简单了很多，而且异常处理也非常的合理&lt;/p&gt;
&lt;h2&gt;JDBC事务&lt;/h2&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;1.JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务，每次执行一个SQL语句时如果执行成功，就会像数据库中自动提交事务，不可以回滚&lt;/p&gt;
&lt;p&gt;2.JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务，这里是事务acid中的原子性&lt;/p&gt;
&lt;p&gt;3.调用Connection的setAutoCommit(false) 可以取消自动提交事务&lt;/p&gt;
&lt;p&gt;4.在所有的SQL语句都执行成功后，调用commit方法进行提交事务&lt;/p&gt;
&lt;p&gt;5.在其中某个操作失败或者出现异常的时候，调用rollback方法进行回滚事务&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;以下代码完成了账户中转账的操作，但是假设在第二条SQL语句执行失败的情况下，异常被捕获第二条语句的转账没有收到，就会少了100块钱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 2&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            System.out.println(row &amp;gt; 0 ? &quot;success&quot; : &quot;fail&quot;);
            
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就需要运用到事务来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Prepared {
    public static void main(String[] args){

        Connection connection = JDBCUtils.getConnection();
        String sql1 = &quot;update balance set money = money - 100 where id = 1&quot;;
        String sql2 = &quot;update balance set money = money + 100 where id = 3&quot;;

        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            connection.setAutoCommit(false);//设置为不自动提交
            statement = connection.prepareStatement(sql1);
            int row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }

            statement = connection.prepareStatement(sql2);
            row = statement.executeUpdate();
            if(row &amp;lt;= 0) {
                throw new SQLException();
            }
            connection.commit();//提交事务

        } catch (SQLException e) {
            //当发生执行SQL语句的时候，我们可以在异常处理回滚
            try {
                connection.rollback();
                //当没有存档点的情况下我们回滚到事务开始时，即设置自动提交的地方
            } catch (SQLException ex) {
                throw new RuntimeException(ex);
            }
            throw new RuntimeException(e);
        } finally {
            JDBCUtils.close(resultSet, statement, connection);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话，即使我们的第二条语句执行了一个不存在的用户3，用户1账户的钱也不会消失，注意当row=0时主动抛出异常，以便catch处理回滚&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/git%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</guid><description>Git 学习笔记（加强版本）代码管理，本地库，分支，团队协作</description><pubDate>Wed, 16 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;GIT&lt;/h1&gt;
&lt;p&gt;Mysql基础部分内容结束，本来打算直接进入JDBC的学习，但是一来我有点小累，学不动Java了，二来我的编译原理课程需要使用到Git，实习的公司也要求熟练运用Git，所以就先看看这一个部分的知识，整理笔记并实际运用，预计今天（15号）一个晚自习和明天把这一块知识拿下（熟练使用Git、Github、GitLab、Gitee）&lt;/p&gt;
&lt;p&gt;之前的博客中我也介绍了一下Git大体是个什么玩意，但是使用的是VsCode链接到的Github，而我现在学Java改用IDEA了，又需要重新配置一下才可以方便使用。&lt;/p&gt;
&lt;p&gt;找的课程也就4~5个小时，就当过一遍教程了，对不了解的代码分支，分支合并学习一下，以下是该课程涉及的一些知识点（代码推送、代码拉取、代码克隆、IDEA集成Github、分支合并）&lt;/p&gt;
&lt;h2&gt;重要概念&lt;/h2&gt;
&lt;h3&gt;版本控制&lt;/h3&gt;
&lt;p&gt;版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统&lt;/p&gt;
&lt;p&gt;其中最重要的就是可以记录文件修改历史，从而让用户能够查看历史版本，方便切换版本&lt;/p&gt;
&lt;p&gt;对于个人而言或许不太需要版本控制，但是如果一旦上升到公司集体，为了方便安全的对于代码进行修改（对于多个修改进行正确的合并），版本控制的使用就异常重要&lt;/p&gt;
&lt;h3&gt;分布式和集中式&lt;/h3&gt;
&lt;p&gt;对于早期的集中式管理系统，多个用户针对于中央服务器进行代码提交修改，这样做方便管理者来集中控制权限，但是如果中央服务器崩溃，项目就无法查看版本记录，而本地工作副本仅保存当前文件状态，无法形成有效的本地版本历史，而如今的分布式可以很好的解决这一点，通过拉取到本地，推送来统一进度，当中央发生故障的时候，任可以在自己的主机上做本地的版本控制&lt;/p&gt;
&lt;h3&gt;Git的工作机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/113.png&quot; alt=&quot;113&quot; /&gt;&lt;/p&gt;
&lt;p&gt;工作区：指的是本地存放代码的地方，也是直接编写代码的本地区域&lt;/p&gt;
&lt;p&gt;暂存区：是为了git识别，将工作区通过git add添加到的一个特定区域&lt;/p&gt;
&lt;p&gt;本地库：将暂存区的代码commit提交到本地库就会生成历史版本，无法删除记录（除非删除本地代码重新拉取云端的版本）&lt;/p&gt;
&lt;h3&gt;代码托管中心&lt;/h3&gt;
&lt;p&gt;代码托管中心是基于网络服务器的远程代码仓库，一般简单地称为远程库，在上述工作机制中，我们还可以把本地库运用push将本地库推送到远程库中，以下是一些常见的代码托管中心&lt;/p&gt;
&lt;p&gt;局域网 GitLab&lt;/p&gt;
&lt;p&gt;互联网 Github     Gitee 码云&lt;/p&gt;
&lt;h2&gt;本地库操作&lt;/h2&gt;
&lt;h3&gt;相关命令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.name 用户名称&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git config --global user.email 邮箱&lt;/td&gt;
&lt;td&gt;设置用户签名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git init&lt;/td&gt;
&lt;td&gt;初始化本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git status&lt;/td&gt;
&lt;td&gt;查看本地库状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git add 文件名&lt;/td&gt;
&lt;td&gt;添加到暂存区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git commit -m &quot;日志信息&quot; 文件名&lt;/td&gt;
&lt;td&gt;提交到本地库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reflog&lt;/td&gt;
&lt;td&gt;查看历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reset --hard 版本号&lt;/td&gt;
&lt;td&gt;版本穿梭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Git操作&lt;/h3&gt;
&lt;h4&gt;设置用户签名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name thrinisty
git config --global user.email 714605471@qq.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;签名的作用是区分不同的操作者的身份，用户的签名信息在每一个版本的提交信息中能够看到，以确认本次提交是谁做的，Git首次安装必须要设置一下用户签名，否则无法提交代码&lt;/p&gt;
&lt;p&gt;注意，这里设置用户签名和将来登录Github的帐号没有任何的关系&lt;/p&gt;
&lt;h4&gt;初始化本地库&lt;/h4&gt;
&lt;p&gt;找到你要git提交的文件进入，输入以下指令创建空的git本地库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/114.png&quot; alt=&quot;114&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;查看本地库状态&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认是在master分支下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
No commits yet
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/
        src/

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的images和src还没有被添加到暂存区，没有被追踪&lt;/p&gt;
&lt;h4&gt;添加至暂存区&lt;/h4&gt;
&lt;p&gt;添加所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加image文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们也可以使用git status来查看新添加进入的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/115.png&quot; alt=&quot;115&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;提交本地库&lt;/h4&gt;
&lt;p&gt;生成历史版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &quot;init commit&quot; [可选字段 默认提交所有暂存区中内容]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/116.png&quot; alt=&quot;116&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个时候再次查看git本地库状态，看见所有在暂存区的内容被提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看版本信息&lt;/h4&gt;
&lt;p&gt;我们也可以通过一下的指令来查看版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现有一个提交过的版本名为init commit&lt;/p&gt;
&lt;p&gt;以下是一个更为详细的版本信息查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log
commit c3418c789ad7bfb246a65f88f26f37764a011764 (HEAD -&amp;gt; master)
Author: thrinisty &amp;lt;714605471@qq.com&amp;gt;
Date:   Wed Apr 16 14:57:49 2025 +0800

	init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改文件&lt;/h4&gt;
&lt;p&gt;修改文件之后我们需要将修改的文件再次添加到暂存区，以及提交到本地库&lt;/p&gt;
&lt;p&gt;例如我们在images文件夹下新增了一张图片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        images/2.jpg

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们就需要重新将这张图片存储到到暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
On branch master
Changes to be committed:
  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
        new file:   images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再重新提交到本地库，从而生成第二个版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -m &quot;New picture&quot;
[master 8c69e8c] New picture
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 images/2.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们再查看版本信息，就可以看到第二次提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
8c69e8c (HEAD -&amp;gt; master) HEAD@{0}: commit: New picture
c3418c7 HEAD@{1}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;版本切换&lt;/h4&gt;
&lt;p&gt;Git切换版本，底层实际上就是移动的Head指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard c3418c7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们的版本指针指向的就是第一次提交的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c3418c7 (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to c3418c7
8c69e8c HEAD@{1}: commit: New picture
c3418c7 (HEAD -&amp;gt; master) HEAD@{2}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而我们添加的工作区中的第二次新添加的图片也会消失不见&lt;/p&gt;
&lt;p&gt;当然我们也可以版本穿梭回去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard 8c69e8c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们工作区中的图片就会被添加回来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/117.png&quot; alt=&quot;117&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;p&gt;在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响到主线分支的运行&lt;/p&gt;
&lt;p&gt;而对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支的底层的实现也是通过指针完成）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/118.png&quot; alt=&quot;118&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分支优点：同时并行推进多个功能的开发，提高开发效率&lt;/p&gt;
&lt;p&gt;在各个分支的开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支重新删除即可&lt;/p&gt;
&lt;h3&gt;分支相关指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git branch 分支名&lt;/td&gt;
&lt;td&gt;创建分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch -v&lt;/td&gt;
&lt;td&gt;查看分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout 分支名&lt;/td&gt;
&lt;td&gt;切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git merge 分支名&lt;/td&gt;
&lt;td&gt;把指定的分支合并到当前分支上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们有的时候需要对于工作代码进行热修补，我们可以创建一个hot-fix分支，切换到分支，在分支上对于代码进行修改，完成之后切换到master分支下就可以使用git merge进行合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch hot-fix
git checkout hot-fix
相关的热修复
git checkout master
git merge hot-fix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的本地库状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{0}: merge hot-fix: Fast-forward
8c69e8c HEAD@{1}: checkout: moving from hot-fix to master
37195a2 (HEAD -&amp;gt; master, hot-fix) HEAD@{2}: commit: commit 1.jpg
8c69e8c HEAD@{3}: checkout: moving from master to hot-fix
8c69e8c HEAD@{4}: reset: moving to 8c69e8c
c3418c7 HEAD@{5}: reset: moving to c3418c7
8c69e8c HEAD@{6}: commit: New picture
c3418c7 HEAD@{7}: commit (initial): init commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并冲突&lt;/h3&gt;
&lt;p&gt;以上的例子是在master没有修改的情况下完成的合并，所以可以合并成功，在企业中我们在合并分支的时候往往遇到冲突&lt;/p&gt;
&lt;p&gt;合并分支的时候，两个分支在同一个文件的同一个位置有两套完全不同的修改，而Git无法替我们决定使用哪一个，必须要认为决定新代码内容&lt;/p&gt;
&lt;p&gt;例如我们在master中创建了一个1.txt 然后创建一个another分支，在两个分支下分别修改这个1.txt，分别提交，尝试在master中合并another，发现没有办法正常自动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge another
Auto-merging 1.txt.txt
CONFLICT (content): Merge conflict in 1.txt.txt
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而用git status指令查看，发现了1.txt合并冲突&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;On branch master
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution)
        both modified:   1.txt.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而打开冲突的文件，会发现git帮我们完成了冲突的标注&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
master中的修改
=======
分支中的修改
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; another
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要手动合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;master中的修改
分支中的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要重新添加提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &quot;merge test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;71460@thrinisty MINGW64 ~/多用户通讯系统 (master|MERGING)
$ git commit -m &quot;merge test&quot;
[master 0f34b4c] merge test

71460@thrinisty MINGW64 ~/多用户通讯系统 (master)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现两个分支合并成功，其实无论master还是another都是版本记录的指针，而所在的分支，其实是由Head决定的，所以创建分支的本质就是多创建一个指针，切换Head就是切换分支&lt;/p&gt;
&lt;h2&gt;团队协作&lt;/h2&gt;
&lt;p&gt;我们在实际开发的过程中不光有本地的仓库，还应该将代码同步到云端（代码托管平台）&lt;/p&gt;
&lt;p&gt;远程仓库命令&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git remote -v&lt;/td&gt;
&lt;td&gt;查看当前所有远程地址别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git remote add 别名 远程地址&lt;/td&gt;
&lt;td&gt;起一个别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push 别名 分支&lt;/td&gt;
&lt;td&gt;推送本地分支上的内容到远程仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git clone 远程地址&lt;/td&gt;
&lt;td&gt;将远程仓库的内容克隆到本地&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git pull 别名 远程分支名&lt;/td&gt;
&lt;td&gt;将远程仓库对于分支最新内容拉取与本地分支直接合并&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;远程仓库操作&lt;/h3&gt;
&lt;h4&gt;创建远程仓库&lt;/h4&gt;
&lt;p&gt;在github创建一个远程仓库名为Multi-user-communication-system（举例）&lt;/p&gt;
&lt;p&gt;其中 https://github.com/thrinisty/Multi-user-communication-system.git&lt;/p&gt;
&lt;p&gt;是我们的仓库链接，我们可以对于这个链接起一个别名system&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add system 
https://github.com/thrinisty/Multi-user-communication-system.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;推送本地仓库到远程仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git push system master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们就将代码推送到了远程仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/119.png&quot; alt=&quot;119&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;拉取代码&lt;/h4&gt;
&lt;p&gt;如果需要拉取云端的代码对本地的代码进行合并（请注意保持本地库的代码是最新的状态）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;git pull system master
From https://github.com/thrinisty/Multi-user-communication-system
 * branch            master     -&amp;gt; FETCH_HEAD
Already up to date.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;克隆仓库&lt;/h4&gt;
&lt;p&gt;如果没有本地库代码，我们还可以使用git clone完成项目的克隆，别名默认为origin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/thrinisty/Multi-user-communication-system
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;团队内协作&lt;/h3&gt;
&lt;p&gt;在克隆的本地仓库可以用另外一个人的帐号，进行推送，但是需要赋予相关的权限，需要将这个人的账号添加进入团队&lt;/p&gt;
&lt;h4&gt;添加团队人员&lt;/h4&gt;
&lt;p&gt;在仓库的拥有者中仓库设置的Collaborators可以选取添加仓库的相关人员，而添加的相关人员就会有push代码的权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/120.png&quot; alt=&quot;120&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;团队成员修改提交&lt;/h4&gt;
&lt;p&gt;之后团队内成员可以拉取合并代码，并修改提交，参与到项目的研发中&lt;/p&gt;
&lt;h3&gt;跨团队协作&lt;/h3&gt;
&lt;p&gt;有的时候我们需要找一个外来人员更改代码，但是我们又不想要让这个外来人员进入团队，我们就需要跨团队协作&lt;/p&gt;
&lt;p&gt;这个时候外来人员可以通过项目链接选择使用fork看到代码，修改代码，提交修改，但是只是修改自己的本地仓库&lt;/p&gt;
&lt;p&gt;外来人员想要将修改的代码合并到对应的项目中可以使用pull request发送请求，而仓库的管理人员就可以审核申请，之后还可以查看修改，如果没有问题就可以确认合并。&lt;/p&gt;
&lt;h2&gt;IDEA集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt;  &lt;strong&gt;Gitee&lt;/strong&gt;  &lt;strong&gt;GitLab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分的内容照着尚硅谷的B站课程过一遍就好，一般都记得住，不会用的时候再去复习一下就好，用的多就会了，没必记录笔记&lt;/p&gt;
&lt;p&gt;在公司中代码保护非常的常见，之前我在讯飞得生产实习就有明确要求只准许使用公司内网连接，网络实时监控，不允许向网络上提交代码相关的内容&lt;/p&gt;
&lt;p&gt;而一个项目的开发中代码的保护也是很重要，这个时候就需要使用到GitLab自建代码托管平台，在局域网是进行代码管理&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;Git到这里告一段落，明天开始JDBC的学习，计划两天完成，目的是掌握基础语法，JDBC大体结构，JDBC实战项目暂时不打算做了，得快点把概念和实际操作过熟练了，计划之后学完JDBC的高层框架（Mybatis）后实战运用，就不用底层的JDBC做项目了&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%B9%A0%E9%A2%98%E8%AF%BE/</guid><description>习题练习</description><pubDate>Tue, 15 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL习题&lt;/h1&gt;
&lt;p&gt;我们系统的学完了MySQL相关知识，我们现在来用例题巩固一下我们的知识&lt;/p&gt;
&lt;h2&gt;练习一&lt;/h2&gt;
&lt;p&gt;1.显示所有部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,dname from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有雇员名以及全年收入（12*薪水 + 奖金）取名为年收入&lt;/p&gt;
&lt;p&gt;这里道题注意null+数字为空，需要使用判断语句处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, (sal*12 + if(comm is null,0,comm))
as&apos;年收入&apos; from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示工资超过2850雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示工资不再1500到2850之间雇员的姓名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 2850 and sal &amp;lt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.显示编号为7796的雇员名称以及所在部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,deptno from emp where empno=7796;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.显示部门在20，30中工资超过1500的雇员名以及工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal &amp;gt; 1500 
and deptno in(20,30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.显示无管理者的雇员名称以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job from emp where mgr is null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.显示在1991-2-1日到1991-5-1日之间雇佣的员工名，岗位以及雇佣日期，并以雇佣日期降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,hiredate from emp 
where hiredate between 1991-02-01 
and 1991-05-01 
order by hiredate desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习二&lt;/h2&gt;
&lt;p&gt;1.选出部门30中的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出所有CLERK的姓名，编号和部门编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, empno, deptno from emp where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.找出佣金高于平均薪水60%的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp 
where sal&amp;gt;(0.6*(select avg(sal) from emp));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.找出部门30中所有MANNAGER和部门20中所有CLERK的详细资料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where(deptno = 20 and job = &apos;CLERK&apos;) 
or (deptno = 30 and job = &apos;MANNAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = 20 and job = &apos;CLERK&apos; 
union select * from emp 
where deptno = 30 and job = &apos;MANNAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询20部门中既不是MANAGER又不是CLERK而薪水小于等于2000的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 30 
and sal &amp;lt;= 2000 and (job &amp;lt;&amp;gt; &apos;MANAGER&apos; and job &amp;lt;&amp;gt; &apos;CLERK&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.找出不收奖金或奖金低于100的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where comm is null or ifnull(comm,0)&amp;lt;100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.找出每月倒数第三天受雇的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where last_day(hiredate) - 2 = hiredate;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.找出至今工作12年以上的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where date_add(hiredate, interval 12 year) &amp;lt; now();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.以首字母小写的方式显示所有员工的姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select concat(
lcase(substring(ename,1,1))
,substring(ename,2)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10.显示名字长度为5的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where length(ename)=5;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习三&lt;/h2&gt;
&lt;p&gt;1.显示不带有R的员工姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where ename not like &apos;%R%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示所有员工姓名的前三个字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select left(ename,3) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示所有的员工姓名，a用A替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select replace(ename,&apos;A&apos;,&apos;a&apos;) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习四&lt;/h2&gt;
&lt;p&gt;1.列出一个至少有一个员工的所有部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct dname from dept,emp 
where dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水比smith多的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where sal &amp;gt; (select sal from emp where ename = &apos;SMITH&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出受雇日期晚于其直接上级的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emy.* from emp as emy,emp as boss 
where emy.hiredate &amp;gt; boss.hiredate 
and emy.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出部门名称和这些部门的员工信息，同时列出没有员工的部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.* from dept left join emp 
on dept.deptno = emp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出所有CLERK的姓名以及部门的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,emp.ename from dept left join emp 
on dept.deptno = emp.deptno where job = &apos;CLERK&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.列出最低薪水大于1500的各种工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal)as min_sal,job from emp 
group by job 
having min_sal &amp;gt; 1500;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.列出部门在SALES工作的员工名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename from emp,dept 
where emp.deptno = dept.deptno and dname = &apos;SALES&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;练习五&lt;/h2&gt;
&lt;p&gt;1.列出与SMITH从事相同工作的所有员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where job = (select job from emp where ename = &apos;SMITH&apos;) 
and ename &amp;lt;&amp;gt; &apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出薪水高于在部门30工作的所有员工的薪水的员工姓名和薪水&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where sal&amp;gt;all(select sal from emp where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出在每个部门工作的员工数量，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,count(emp.deptno),avg(sal) from dept 
left join emp on dept.deptno = emp.deptno 
group by dname;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.列出所有部门的详细信息以及部门人数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*,temp.con from dept left join 
(select count(*) as con,deptno 
 from dept group by deptno)temp 
 on dept.deptno = temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.列出MANAGER的最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select min(sal) from emp where job = &apos;MANAGER&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;综合练习&lt;/h2&gt;
&lt;p&gt;设学校环境如下：一个系有若干个专业，每个专业一年只招一个班，每个班有若干个学生，先要建立于系、班级、学生数据库&lt;/p&gt;
&lt;p&gt;关系模式如下：&lt;/p&gt;
&lt;p&gt;班级class（班号classid，课程名subject，系名deptname，入学年份time，人数num）&lt;/p&gt;
&lt;p&gt;学生student（学号studentid，姓名name，年龄age，班号classid）&lt;/p&gt;
&lt;p&gt;系department（系号departmentid，系名deptname）&lt;/p&gt;
&lt;h3&gt;建表&lt;/h3&gt;
&lt;p&gt;定义每个表的主外码&lt;/p&gt;
&lt;p&gt;deptname唯一约束&lt;/p&gt;
&lt;p&gt;学生姓名不可以为空&lt;/p&gt;
&lt;p&gt;班级class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table class(
`classid` int primary key,
`subject` varchar(32),
`deptname` varchar(32),
`time` int,
`num` int
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生student&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table student(
`studentid` int,
`name` varchar(32) not null default &apos;&apos;,
`age` int,
`classid` int,
primary key(`studentid`),
foreign key(`classid`) references class(classid)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系department&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table department(
`departmentid` int primary key,
`deptname` varchar(32) unique not null
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;插入数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-- 插入系部数据
INSERT INTO department VALUES
(1, &apos;计算机科学系&apos;),
(2, &apos;电子工程系&apos;),
(3, &apos;机械工程系&apos;),
(4, &apos;外国语学院&apos;),
(5, &apos;经济管理学院&apos;);

-- 插入班级数据
INSERT INTO class VALUES
(101, &apos;数据结构&apos;, &apos;计算机科学系&apos;, 64, 45),
(102, &apos;数据库原理&apos;, &apos;计算机科学系&apos;, 48, 40),
(201, &apos;电路分析&apos;, &apos;电子工程系&apos;, 56, 38),
(202, &apos;数字电子技术&apos;, &apos;电子工程系&apos;, 48, 42),
(301, &apos;机械制图&apos;, &apos;机械工程系&apos;, 64, 36),
(401, &apos;英语语言学&apos;, &apos;外国语学院&apos;, 32, 28),
(501, &apos;微观经济学&apos;, &apos;经济管理学院&apos;, 48, 50);

-- 插入学生数据
INSERT INTO student VALUES
(1001, &apos;张三&apos;, 20, 101),
(1002, &apos;李四&apos;, 21, 101),
(1003, &apos;王五&apos;, 19, 102),
(1004, &apos;赵六&apos;, 20, 102),
(1005, &apos;钱七&apos;, 22, 201),
(1006, &apos;孙八&apos;, 20, 201),
(1007, &apos;周九&apos;, 21, 202),
(1008, &apos;吴十&apos;, 19, 301),
(1009, &apos;郑十一&apos;, 20, 401),
(1010, &apos;王十二&apos;, 21, 501);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询&lt;/h3&gt;
&lt;p&gt;完成如下查询&lt;/p&gt;
&lt;p&gt;1.找出所有姓李的学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from student where name like &apos;李%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.列出开设超过一个课程的系的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptname,count(*)as class_count 
from class group by deptname 
having class_count &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+
| deptname     | class_count |
+--------------+-------------+
| 计算机科学系  |           2 |
| 电子工程系    |           2 |
+--------------+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.列出人数大于等于50，系的编号和名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select department.*,temp.sum_num from department,(select deptname,sum(num) as sum_num from class group by deptname having sum_num &amp;gt;= 50)temp where temp.deptname = department.deptname;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------------+--------------+---------+
| departmentid | deptname     | sum_num |
+--------------+--------------+---------+
|            2 | 电子工程系   | 80       |
|            5 | 经济管理学院 | 50       |
|            1 | 计算机科学系 | 85       |
+--------------+--------------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;移除学生&lt;/h3&gt;
&lt;p&gt;我们现在需要移除一名张三学生，考虑的地方有以下两点，使张三所在班级的人数减一，再将张三从student表中移除，而这个过程我们要由事务来完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction;
update class set num = num-1 where classid = (select classid from student where name = &apos;张三&apos;);
delete from student where name = &apos;张三&apos;;
commit;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86/</guid><description>索引，事务，隔离级别，存储引擎，视图，管理</description><pubDate>Mon, 14 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;自增长&lt;/h2&gt;
&lt;p&gt;我们再插入记录的时候有的时候需要有的数据从1开始自动增长，我们这个时候就要运用到自增长&lt;/p&gt;
&lt;p&gt;基本使用方式：在定义的时候设置auto_increment字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字段名称 整形 primary key auto_increment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入记录的时候填入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT primary key auto_increment,
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(null, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你需要自增需要从10开始，你也可以修改auto_increment设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE dept AUTO_INCREMENT = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据的时候子增值字段也可以不使用null，而插入一个具体的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into dept values(50, &apos;ddd&apos;, &apos;beijing&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充：设置自增步长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- 1. 首先设置全局自增步长
SET @@auto_increment_increment = 10;

-- 2. 然后修改表的自增值
ALTER TABLE dept AUTO_INCREMENT = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;p&gt;索引可以在添加一定的代价后(占据更大大空间)，极大地增加查询（90%）的速度，而对于增删改（10%）会有一定的速率影响&lt;/p&gt;
&lt;h3&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;添加索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [UNIQUE] INDEX 索引名称 on 表名(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table 表名 add index 索引名称(字段);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop index 索引名称 on 表名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter table dept drop primary key;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;索引的类型&lt;/h3&gt;
&lt;p&gt;1.主键索引，主键自动的为主键添加索引（primary key）&lt;/p&gt;
&lt;p&gt;2.唯一索引（unique），在创建表的时候，添加为唯一索引&lt;/p&gt;
&lt;p&gt;3.普通索引（index）&lt;/p&gt;
&lt;p&gt;4.全文索引（fulltext）在实际使用的时候一般不使用自带的全文索引往往切换为Solr或者ElasticSearch&lt;/p&gt;
&lt;p&gt;显示来自于dept的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show index from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show keys from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show indexes from dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;练习&lt;/h3&gt;
&lt;p&gt;为以下的表格添加主键索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table `order` (
`id` int,
`name` varchar(32),
`p_name` varchar(32),
`count` int
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table `order` add unique index id_index (id);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;create index id_index on `order`(id);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建索引规则&lt;/h3&gt;
&lt;p&gt;1.较为频繁作为查询条件字段应该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：一个学校中的学生id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.唯一性太差的字段不适合单独创建索引，即使查询频繁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生的性别
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.更新非常频繁的字段不适合创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生账号的登录次数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.不会出现在where子句中的字段不该创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：学生信息表中的详细的家庭住址
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;h3&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务用于保证数据的一致性，它由一组相关的dml语句组成，改组的dml语句要么全部执行，要么全部失败，例如在转账的时候就需要使用事务来处理，以保证数据的一致性&lt;/p&gt;
&lt;p&gt;事务和锁&lt;/p&gt;
&lt;p&gt;当执行事务操作的时候，mysql会在表上加锁，防止其他用户修改表的数据，这对于用户而言非常重要&lt;/p&gt;
&lt;h3&gt;引用示例&lt;/h3&gt;
&lt;p&gt;我们现在有一个运用场景，有如下的一张表格代表两个用户的银行账户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
)

insert into balance values
(100,&apos;tom&apos;,3000.00),
(200,&apos;king&apos;,6000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在有如下需求：&lt;/p&gt;
&lt;p&gt;将tom的100块钱转移到king的账户下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update balance set money = money-100 where id=100;
update balance set money = money+100 where id=200;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是假如我们的数据库运行出现问题：第一条转账语句成功但是第二条失败，则tom转出的100块钱就凭空消失了，这个时候我们就需要运用到事务操作，将两条语句当为一个整体执行（要么全部执行成功，要么失败）&lt;/p&gt;
&lt;h3&gt;事务基本操作&lt;/h3&gt;
&lt;h4&gt;start transaction&lt;/h4&gt;
&lt;p&gt;开始一个事务&lt;/p&gt;
&lt;h4&gt;savepoint&lt;/h4&gt;
&lt;p&gt;保存点名--设置保存点&lt;/p&gt;
&lt;h4&gt;rollback to&lt;/h4&gt;
&lt;p&gt;保存点名--回退事务&lt;/p&gt;
&lt;h4&gt;rollback&lt;/h4&gt;
&lt;p&gt;回退全部的事务&lt;/p&gt;
&lt;h4&gt;commit&lt;/h4&gt;
&lt;p&gt;提交事务，所有的操作生效，不可以回退&lt;/p&gt;
&lt;p&gt;我们现在回到我们的实际案例上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start transaction; --设置了事物的开始

savepoint a;  --保存点a
update balance set money = money-100 where id=100;--dml

savepoint b;  --保存点a
update balance set money = money+100 where id=200;--dml

ROLLBACK;  --回滚
commit;  --提交
select * from balance;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行这样一段代码的话，数据不会被更改，因为进行了回滚，如果删除回滚在进行提交，执行成功，tom的100元给到了king&lt;/p&gt;
&lt;p&gt;回退事务：当执行回退事物的时候，通过指定的保存点就可以回退到指定的点&lt;/p&gt;
&lt;p&gt;提交事务：使用commit进行提交，执行了commit后就会确认事务的变化，结束事务，删除保存点，释放锁，数据生效。当使用commit语句结束事务以后，其他的会话可以查看到事物变化后的新数据&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;1.如果不开始事务，默认情况下，dml操作是自动提交的，不可以进行回滚&lt;/p&gt;
&lt;p&gt;2.如果开始一个事务，没有创建保存点，可以执行rollback操作，默认回滚到事务开始的状态&lt;/p&gt;
&lt;p&gt;3.可以在事务还没有提交的时候，创建多个保存点&lt;/p&gt;
&lt;p&gt;4.可以在事务还没有提交的时候，选择回退到哪个保存点&lt;/p&gt;
&lt;p&gt;5.mysql事务机制需要innodb存储引擎，myisam不可以使用事务机制&lt;/p&gt;
&lt;h3&gt;事务的acid特性&lt;/h3&gt;
&lt;p&gt;（atomicity）原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生&lt;/p&gt;
&lt;p&gt;（consistency）一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;/p&gt;
&lt;p&gt;（isolation）隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离&lt;/p&gt;
&lt;p&gt;（durability）持久性：持久性是指一个事务一旦被提交，他对于数据库中的数据的改变就是永久的，接下来即使数据库发生故障可而不应该对其有任何的影响&lt;/p&gt;
&lt;h2&gt;隔离级别&lt;/h2&gt;
&lt;p&gt;脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读&lt;/p&gt;
&lt;p&gt;不可重复读：同一查询在同一事物中多次进行，由于其他提交事务所做的修改或者删除，每次返回结果不同的结果集，产生不可重复读&lt;/p&gt;
&lt;p&gt;幻读：同意查询在同一事物中多次进行，由于其他提交事务的插入操作，每次返回不同的结果集，产生了幻读&lt;/p&gt;
&lt;h3&gt;事务隔离表格&lt;/h3&gt;
&lt;p&gt;事务隔离级别：MySQL隔离级别定义了事物与事务之间的隔离程度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;丢失修改&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Mysql中解决幻读&lt;/h3&gt;
&lt;p&gt;Mysql中的默认隔离级别是可重复读，但是在使用innodb引擎的时候不会发生幻读，原因如下&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎通过多版本并发控制(MVCC, Multi-Version Concurrency Control)机制，在&quot;可重复读&quot;(Repeatable Read)隔离级别下有效解决了幻读问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;普通SELECT操作(快照读)
通过ReadView判断哪些版本对当前事务可见
总是读取事务开始时的一致性快照
其他事务的插入操作不会影响当前事务的查询结果

当前读操作
对于SELECT ... FOR UPDATE、UPDATE、DELETE等操作：
InnoDB会加Next-Key Lock(记录锁+间隙锁)
防止其他事务在查询范围内插入新记录
从而彻底解决幻读问题
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;START TRANSACTION;
SELECT * FROM t WHERE id &amp;gt; 1; -- 看到3,5
-- 此时事务B插入id=4并提交
SELECT * FROM t WHERE id &amp;gt; 1; -- 仍然只看到3,5(快照读)
SELECT * FROM t WHERE id &amp;gt; 1 FOR UPDATE; -- 会看到3,4,5(当前读)
COMMIT;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在可重复读隔离级别下，普通SELECT不会看到事务B插入的id=4，而加锁的SELECT会看到并锁定这些记录。&lt;/p&gt;
&lt;h3&gt;读已提交和可重复读&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;读已提交(Read Committed)&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数据可见性规则&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;总是看到最新已提交的数据&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;看到事务开始时的数据快照&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁机制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;语句级锁(执行完立即释放)&lt;/td&gt;
&lt;td&gt;事务级锁(保持到事务结束)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可能发生&lt;/td&gt;
&lt;td&gt;不会发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;可重复读和可串行化&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;可重复读(Repeatable Read)&lt;/th&gt;
&lt;th&gt;可串行化(Serializable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并发控制原理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;MVCC(多版本并发控制)为主&lt;/td&gt;
&lt;td&gt;严格的二阶段封锁协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;读取行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快照读(非锁定读)&lt;/td&gt;
&lt;td&gt;所有读自动转为锁定读(S锁)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;写入行为&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要时加X锁&lt;/td&gt;
&lt;td&gt;总是加X锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;锁范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;仅锁定实际访问的行和间隙&lt;/td&gt;
&lt;td&gt;更大范围的锁(更保守)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高并发，读不阻塞写&lt;/td&gt;
&lt;td&gt;低并发，读写相互阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;常用代码&lt;/h3&gt;
&lt;h4&gt;查看隔离级别&lt;/h4&gt;
&lt;p&gt;可以通过以下代码查看数据库设置的隔离级别&lt;/p&gt;
&lt;p&gt;MySQL 5.7及之前版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL 8.0及之后版本&lt;/p&gt;
&lt;p&gt;查看系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT @@transaction_isolation;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见Mysql的默认隔离级别为可重复读&lt;/p&gt;
&lt;h4&gt;设置隔离级别&lt;/h4&gt;
&lt;p&gt;设置当前会话隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统当前隔离级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET global TRANSACTION ISOLATION LEVEL 隔离级别;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读未提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;读已提交&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL read committed;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可重复读&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;可串行化&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL serializable;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;1.MySQL的表类型由存储引擎决定，主要包括MYISAM，InnoDB，Memory&lt;/p&gt;
&lt;p&gt;2.MySQL数据表只要支持六种类型：CSV，Memory，ARCHIVE，MRG_MYISAM，MYISAM，InnoDB&lt;/p&gt;
&lt;p&gt;3.这两种存储又分为两种：一类是事务安全型，例如InnoDB，其余为第二类，称为非事务安全型&lt;/p&gt;
&lt;p&gt;在MySQL中可以使用如下的指令查看存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW ENGINES;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;引擎比较&lt;/h3&gt;
&lt;p&gt;接下来来比较InnoDB、Myisam、Memory、Archive之间的优缺点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;InnoDB&lt;/th&gt;
&lt;th&gt;MyISAM&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;th&gt;Archive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;事务支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;锁定级别&lt;/td&gt;
&lt;td&gt;行级锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;表锁&lt;/td&gt;
&lt;td&gt;行锁(仅插入)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外键支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储位置&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;磁盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;压缩能力&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;极高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;崩溃恢复&lt;/td&gt;
&lt;td&gt;优秀&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;无(数据丢失)&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全文索引&lt;/td&gt;
&lt;td&gt;5.6+支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;高并发OLTP&lt;/td&gt;
&lt;td&gt;读密集型&lt;/td&gt;
&lt;td&gt;临时/缓存&lt;/td&gt;
&lt;td&gt;归档存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;1.MyISAM不支持事务、也不支持外键、但是访问速度极快、对于事物完整性没有要求&lt;/p&gt;
&lt;p&gt;2.InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全、但是相比于MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的从磁盘空间以保留数据和索引&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件，该类型的表访问速度极快，因为数据是存放在内存中的，并且默认使用了Hash索引，但是MySQL服务关闭，表中的数据就会丢失，表的结构还在&lt;/p&gt;
&lt;h3&gt;使用案例&lt;/h3&gt;
&lt;p&gt;修改存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter talble 表名 engine = 存储引擎;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alter table balance engine = innodb;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个MyISAM存储引擎的表，无法使用事务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE MYISAM;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个Memory存储引擎的表，支持Hash索引，执行速度很快&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table balance (
`id` int primary key,
`name` varchar(32),
`money` double
) ENGINE Memory;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1.如果应用不需要事务，处理的只是基本的增删改查，那么MyISAM是绝佳的选择，速度快&lt;/p&gt;
&lt;p&gt;2.需要事务支持，就选择InnoDB&lt;/p&gt;
&lt;p&gt;3.Memory存储引擎将数据存在内存中，由于没有磁盘的IO等待，速度非常快，但数据不持久&lt;/p&gt;
&lt;h2&gt;视图&lt;/h2&gt;
&lt;p&gt;我们有的时候需要将表中的某几个字段显示使用（有权限需要，不能够每个人都使用select查询整一张表格），我们可以将这几个字段拿出来做成一个视图，还可以将视图的查看权限赋予某个用户&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;p&gt;视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含列，数据来自于对应的真实表（基表）&lt;/p&gt;
&lt;p&gt;1.视图是根据基表（可以多个基表）来创建的，视图是虚拟的表&lt;/p&gt;
&lt;p&gt;2.视图也有列，数据来自于基表&lt;/p&gt;
&lt;p&gt;3.通过修改视图可以修改基表的数据&lt;/p&gt;
&lt;p&gt;4.基表的改变也会影响到视图的数据&lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;创建视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alter view 视图名称 as select语句;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示视图是如何创建的（select语句）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show create view 视图名;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view 视图1,视图2...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要对于员工表创建一个名为emp_view的视图（数据包含empno,ename,job,deptno）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as 
select empno,ename,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在来查看一下这个视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+--------+
| empno | ename  | job      | deptno |
+-------+--------+----------+--------+
|  7396 | SMITH  | CLERK    |     20 |
|  7499 | ALLEN  | SALESMAN |     30 |
|  7596 | WARD   | SALESMAN |     30 |
|  7696 | JOOES  | MANAGER  |     20 |
|  7796 | MARTIN | SALESMAN |     30 |
|  7896 | BLAKE  | MANAGER  |     30 |
+-------+--------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop view emp_view;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题：针对emp，dept，salgrade 三张表格创建一个emp_view视图，可以显示雇员编号，雇员名称，雇员部门名称，薪水级别&lt;/p&gt;
&lt;p&gt;相关的select语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create view emp_view as
select empno,ename,dname,grade from emp, dept, salgrade 
where emp.deptno = dept.deptno
and sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;视图细节&lt;/h3&gt;
&lt;p&gt;1.创建视图后，到数据库看，对应的视图只有一个视图结构文件(视图名.frm)&lt;/p&gt;
&lt;p&gt;2.视图和基表的修改相互影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update emp_view set deptno = 40 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;update emp set deptno = 20 where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.视图中可以再次使用视图&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;安全：一些数据表有着重要的信息，某些字段需要保密，不可以让用户直接看到，这个时候我们就可以创建一个视图，在这个视图中保留安全的字段，而不包含保密的字段&lt;/p&gt;
&lt;p&gt;性能：关系数据库常常会分表存储，使用外键建立这一些表的关系，这个时候，数据库查询通常会用到join连接，这么做不但麻烦，效率也比较低，如果建立一个视图，将相关表的字段组合在一起，就可以避免使用join查询数据&lt;/p&gt;
&lt;p&gt;灵活：如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃，然而，很多表都是基于这一张表，不方便修改，这个时候就可以建立一张视图，视图中的数据直接映射到新建的表，这样就可以做很少的改动，也达到了升级数据表的目的&lt;/p&gt;
&lt;h2&gt;Mysql管理&lt;/h2&gt;
&lt;h3&gt;user表&lt;/h3&gt;
&lt;p&gt;mysql中的用户，都存储在系统数据库mysql中的user表&lt;/p&gt;
&lt;p&gt;其中有一些重要的字段&lt;/p&gt;
&lt;p&gt;host：允许登录的位置，localhost表示该用户只允许本机登录，也可以指定ip&lt;/p&gt;
&lt;p&gt;user：用户名称&lt;/p&gt;
&lt;p&gt;authentication_string：密码，通过mysql的password()函数加密后的密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select host,user,authentication_string from user;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-----------+------------------+------------------------------------------------------------------------+
| host      | user             | authentication_string                                                  |
+-----------+------------------+------------------------------------------------------------------------+
| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.session    | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | mysql.sys        | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |
| localhost | root             | $A$005$ xgY]U4ieS
8Q+#hB9QVmRfma9kzzSPEIJ1FgvgP7VMuobh4V.rZD0mc7FD  |
+-----------+------------------+------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;用户管理&lt;/h3&gt;
&lt;p&gt;当做项目开发的时候，Mysql数据库管理人员可以根据不同的开发人员，赋给相应的Mysql操作权限，供人员使用&lt;/p&gt;
&lt;h4&gt;创建用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;create user &apos;thrinisty&apos; @&apos;localhost&apos; identified by &apos;123456&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select host,user from user;
+-----------+------------------+
| host      | user             |
+-----------+------------------+
| localhost | mysql.infoschema |
| localhost | mysql.session    |
| localhost | mysql.sys        |
| localhost | root             |
| localhost | thrinisty        |
+-----------+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在Navicat中可以用新的用户连接数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/111.png&quot; alt=&quot;111&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们新用户表和root用户的表不太一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/112.png&quot; alt=&quot;112&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这是因为不同的数据库用户，登录到DBMS，根据相应的权限，可以操作的数据库，数据对象（表、视图、触发器）都不一样&lt;/p&gt;
&lt;h4&gt;删除用户&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;drop user &apos;用户名&apos; @&apos;允许登录的位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改密码&lt;/h4&gt;
&lt;p&gt;注意以下修改方式是5.7.5版本以下的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set password = password(&apos;密码&apos;);--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;set password for &apos;用户名&apos; @&apos;登录位置&apos; = password(&apos;密码&apos;);
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我用的8.0版本需要使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER USER() IDENTIFIED BY &apos;654321&apos;;--修改自身密码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;username&apos;@&apos;hostname&apos; IDENTIFIED BY &apos;654321&apos;;
--修改他人的密码，需要有用户密码的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;权限管理&lt;/h3&gt;
&lt;p&gt;MySQL中有非常多的权限可以赋予用户，我们来使用以下常见的权限&lt;/p&gt;
&lt;h4&gt;常见的权限&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;全选&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GRANT OPTION&lt;/td&gt;
&lt;td&gt;允许授予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALL PRIVIEGES&lt;/td&gt;
&lt;td&gt;设置除GRANT OPTTION之外的简单权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ALTER&lt;/td&gt;
&lt;td&gt;允许使用 ALTER TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE&lt;/td&gt;
&lt;td&gt;允许使用 CREATE TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE USER&lt;/td&gt;
&lt;td&gt;允许使用增删改用户、移除所有权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATE VIEW&lt;/td&gt;
&lt;td&gt;允许使用CREATE VIEW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;允许使用DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DROP&lt;/td&gt;
&lt;td&gt;允许使用DROP TABLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INDEX&lt;/td&gt;
&lt;td&gt;允许创建删除索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSERT&lt;/td&gt;
&lt;td&gt;允许使用INSERT插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SELECT&lt;/td&gt;
&lt;td&gt;允许使用查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW DATABASES&lt;/td&gt;
&lt;td&gt;允许显示所有数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USAGE&lt;/td&gt;
&lt;td&gt;无权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;p&gt;赋权指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant 权限列表 on 库.对象名 to 
&apos;用户名&apos;@&apos;登录位置&apos; [identified by &apos;密码&apos;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回收权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;revoke 权限列表 on 库.对象名 from 
&apos;用户名&apos;@&apos;登录位置&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷新权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋给thrinisty全部表全部对象的all权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant all on *.* to &apos;thrinisty&apos;@&apos;localhost&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;管理细节&lt;/h3&gt;
&lt;p&gt;1.在创建用户的时候，如果不指定host，则为%，表示所有ip都有链接的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create user jack;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在删除用户的时候，如果host不是%，需要明确指定‘用户’@‘host值’&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A2%9E%E5%BC%BA%E6%9F%A5%E8%AF%A2%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BA%A6%E6%9D%9F/</guid><description>增强查询，多表查询，外连接，子查询，约束</description><pubDate>Sun, 13 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;h2&gt;MySQL表查询&lt;/h2&gt;
&lt;p&gt;在实际开发的过程中，我们需要用到的查询不只有前面的简单查询，我们还需要学习一些更为符合实际的查询方式，如日期查询，多表查询等&lt;/p&gt;
&lt;h3&gt;相关表格&lt;/h3&gt;
&lt;p&gt;我们先来建立几个表格，填入响应数据&lt;/p&gt;
&lt;h4&gt;员工表emp&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE emp (
	`empno` INT,
	`ename` VARCHAR ( 30 ),
	`job` VARCHAR ( 20 ),
	`mgr` INT,
	`hiredate` DATE,
	`sal` DOUBLE,
	`comm` DOUBLE,
`deptno` INT 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO emp
VALUES
	( 7396, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1990-12-17&apos;, 800.00, NULL, 20 ),
	( 7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7902, &apos;1991-02-20&apos;, 1600.00, 300.00, 30 ),
	( 7596, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7896, &apos;1993-02-07&apos;, 1250.00, 500.00, 30 ),
	( 7696, &apos;JOOES&apos;, &apos;MANAGER&apos;, 7839, &apos;1980-02-01&apos;, 2975.00, NULL, 20 ),
	( 7796, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1999-04-17&apos;, 1250.00, 1400.00, 30 ),
	( 7896, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1990-12-17&apos;, 2850.00, NULL, 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;工作部门表dept&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE dept ( 
`deptno` INT, 
`dname` VARCHAR ( 30 ), 
`loc` VARCHAR ( 30 ) 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO dept
VALUES
	( 10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos; ),
	( 20, &apos;RESEARCH&apos;, &apos;DALLAS&apos; ),
	( 30, &apos;SALES&apos;, &apos;CHICAGO&apos; ),
	( 40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;薪水表格salgrade&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE salgrade ( 
    `grade` INT, 
    `losal` DOUBLE, 
    `hisal` DOUBLE 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO salgrade
VALUES
	( 1, 700.00, 1200.00 ),
	( 2, 1200.00, 1400.00 ),
	( 3, 1400.00, 3000.00 ),
	( 4, 3000.00, 9000.00 );
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询加强&lt;/h3&gt;
&lt;h4&gt;where筛选日期&lt;/h4&gt;
&lt;p&gt;查找1992.1.1后入职的员工&lt;/p&gt;
&lt;p&gt;需要至于格式01-01&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,hiredate from emp where hiredate &amp;gt; &apos;1992-01-01&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+
| ename  | hiredate   |
+--------+------------+
| WARD   | 1993-02-07 |
| MARTIN | 1999-04-17 |
+--------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;like模糊查询&lt;/h4&gt;
&lt;p&gt;​	%：表示0到多个任意字符&lt;/p&gt;
&lt;p&gt;​	_ ：表示单个任意字符&lt;/p&gt;
&lt;p&gt;如何显示首字符为s的员工共姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;s%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-----+
| ename | sal |
+-------+-----+
| SMITH | 800 |
+-------+-----+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何显示第三个字符为大写o的所有员工姓名和工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal from emp where ename like &apos;__o%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+
| ename | sal  |
+-------+------+
| JOOES | 2975 |
+-------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;order by排序&lt;/h4&gt;
&lt;p&gt;从工资低到高显示员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by sal asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照部门编号升序，员工工资降序排序（中间用，隔开）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno |
+-------+--------+----------+------+------------+------+------+--------+
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 | NULL |     20 |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |
+-------+--------+----------+------+------------+------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;分页查询&lt;/h4&gt;
&lt;p&gt;在实际开发中我们数据量往往很大，我们会用到分页来进行查询，这里介绍一个关键字limit&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ... limit start, rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示从start + 1 行开始取，取出rows行，例如上述的例子中，我们需要取出前5行结果使用如下的语句即可，从第1行开始取5行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们是实际中使用我们就可以运用limit限制每一次查询的范围&lt;/p&gt;
&lt;p&gt;要将一个大表范围若干个小表可以这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp order by deptno asc , sal desc limit 0, 4;
select * from emp order by deptno asc , sal desc limit 4, 4;
select * from emp order by deptno asc , sal desc limit 8, 4;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;group by分组&lt;/h4&gt;
&lt;p&gt;我们有如下的几个题目&lt;/p&gt;
&lt;p&gt;1.显示每种岗位的雇员总数，平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), avg(sal), job from emp group by job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示雇员的总数，以及获得补助的雇员数&lt;/p&gt;
&lt;p&gt;这里输入comm，comm字段为空则不参与统计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们扩展一下&lt;/p&gt;
&lt;p&gt;没有获得补助的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(*)-count(comm) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select count(*), count(if(comm is null, 1, null)) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示管理者的总人数&lt;/p&gt;
&lt;p&gt;先count再去重&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(distinct mgr) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.显示雇员工资的最大差值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select max(sal)-min(sal) from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多子句查询&lt;/h4&gt;
&lt;p&gt;顺序：如果一个select语句同时包含了group by，having，limit，order by，那么它们的顺序应该为：group by，having，order by，limit&lt;/p&gt;
&lt;p&gt;例如统计各个部门的平均工资，并且是大于1000的，按照平均工资从高到低排序，取出前两行记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal),deptno from emp 
group by deptno 
having avg(sal)&amp;gt;1000 
order by avg(sal) desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实更建议使用as重命名，可以增快速度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select avg(sal) as asql, deptno from emp 
group by deptno 
having asql&amp;gt;1000 
order by asql desc 
limit 0, 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| avg(sal) | deptno |
+----------+--------+
|   1887.5 |     20 |
|   1737.5 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多表查询&lt;/h3&gt;
&lt;p&gt;多表查询是指基于两个和两个以上的表的查询，在实际的应用中，查询单个表可能不能满足需求&lt;/p&gt;
&lt;p&gt;例如说显示雇员名，雇员工资，所在部门的名字，就需要员工表和工作部门表&lt;/p&gt;
&lt;h4&gt;多表笛卡尔集&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见笛卡尔集需要将两种表做笛卡尔积（在不加条件的结果非常夸张）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname      | loc      |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     40 | OPERATIONS | BOSTON   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     30 | SALES      | CHICAGO  |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH   | DALLAS   |
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     10 | ACCOUNTING | NEW YORK |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     40 | OPERATIONS | BOSTON   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES      | CHICAGO  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     20 | RESEARCH   | DALLAS   |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     40 | OPERATIONS | BOSTON   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES      | CHICAGO  |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     20 | RESEARCH   | DALLAS   |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     40 | OPERATIONS | BOSTON   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     30 | SALES      | CHICAGO  |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH   | DALLAS   |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     10 | ACCOUNTING | NEW YORK |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     40 | OPERATIONS | BOSTON   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES      | CHICAGO  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     20 | RESEARCH   | DALLAS   |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     10 | ACCOUNTING | NEW YORK |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     40 | OPERATIONS | BOSTON   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES      | CHICAGO  |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     20 | RESEARCH   | DALLAS   |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     10 | ACCOUNTING | NEW YORK |
+-------+--------+----------+------+------------+------+------+--------+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当不加限制的情况下，两张表的查询规则：&lt;/p&gt;
&lt;p&gt;把第一张表的每一条记录和第二张表的每一条记录组合，返回结果是两张表的所有列，一共返回的记录数是第一张表的行数和第二张表的行数的乘积，而组成的表称为笛卡尔集&lt;/p&gt;
&lt;p&gt;我们需要使用where对于笛卡尔集进行过滤，需要进行分析&lt;/p&gt;
&lt;p&gt;当两张表的deptno编号相等的时候才是我们需要的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
| empno | ename  | job      | mgr  | hiredate   | sal  | comm | deptno | deptno | dname    | loc     |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
|  7396 | SMITH  | CLERK    | 7902 | 1990-12-17 |  800 | NULL |     20 |     20 | RESEARCH | DALLAS  |
|  7499 | ALLEN  | SALESMAN | 7902 | 1991-02-20 | 1600 |  300 |     30 |     30 | SALES    | CHICAGO |
|  7596 | WARD   | SALESMAN | 7902 | 1993-02-07 | 1250 |  500 |     30 |     30 | SALES    | CHICAGO |
|  7696 | JOOES  | MANAGER  | 7839 | 1980-02-01 | 2975 |  100 |     20 |     20 | RESEARCH | DALLAS  |
|  7796 | MARTIN | SALESMAN | 7698 | 1999-04-17 | 1250 | 1400 |     30 |     30 | SALES    | CHICAGO |
|  7896 | BLAKE  | MANAGER  | 7839 | 1990-12-17 | 2850 | NULL |     30 |     30 | SALES    | CHICAGO |
+-------+--------+----------+------+------------+------+------+--------+--------+----------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;笛卡尔例题&lt;/h4&gt;
&lt;p&gt;显示雇员名，雇员工资，所在部门的名字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+
| ename  | sal  | dname    |
+--------+------+----------+
| SMITH  |  800 | RESEARCH |
| ALLEN  | 1600 | SALES    |
| WARD   | 1250 | SALES    |
| JOOES  | 2975 | RESEARCH |
| MARTIN | 1250 | SALES    |
| BLAKE  | 2850 | SALES    |
+--------+------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在选取重复列的时候，需要指定是哪一个表的列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno from emp, dept where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+----------+--------+
| ename  | sal  | dname    | deptno |
+--------+------+----------+--------+
| SMITH  |  800 | RESEARCH |     20 |
| ALLEN  | 1600 | SALES    |     30 |
| WARD   | 1250 | SALES    |     30 |
| JOOES  | 2975 | RESEARCH |     20 |
| MARTIN | 1250 | SALES    |     30 |
| BLAKE  | 2850 | SALES    |     30 |
+--------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示部门编号为20的部门名称，员工名，工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,dname,emp.deptno 
from emp,dept 
where emp.deptno = dept.deptno 
and emp.deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+----------+--------+
| ename | sal  | dname    | deptno |
+-------+------+----------+--------+
| SMITH |  800 | RESEARCH |     20 |
| JOOES | 2975 | RESEARCH |     20 |
+-------+------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示各个员工的姓名，工资，以及工资级别&lt;/p&gt;
&lt;p&gt;我们先选好需要的表格是emp表和salgrade表，我们这一道题的要点在于过滤条件该如何筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     4 |
| SMITH  |  800 |     3 |
| SMITH  |  800 |     2 |
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     4 |
| ALLEN  | 1600 |     3 |
| ALLEN  | 1600 |     2 |
| ALLEN  | 1600 |     1 |
| WARD   | 1250 |     4 |
| WARD   | 1250 |     3 |
| WARD   | 1250 |     2 |
| WARD   | 1250 |     1 |
| JOOES  | 2975 |     4 |
| JOOES  | 2975 |     3 |
| JOOES  | 2975 |     2 |
| JOOES  | 2975 |     1 |
| MARTIN | 1250 |     4 |
| MARTIN | 1250 |     3 |
| MARTIN | 1250 |     2 |
| MARTIN | 1250 |     1 |
| BLAKE  | 2850 |     4 |
| BLAKE  | 2850 |     3 |
| BLAKE  | 2850 |     2 |
| BLAKE  | 2850 |     1 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用between and语句即可完成，判断sal位于最高工资和最低工资之间即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,grade from emp, salgrade 
where sal between losal and hisal;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------+-------+
| ename  | sal  | grade |
+--------+------+-------+
| SMITH  |  800 |     1 |
| ALLEN  | 1600 |     3 |
| WARD   | 1250 |     2 |
| JOOES  | 2975 |     3 |
| MARTIN | 1250 |     2 |
| BLAKE  | 2850 |     3 |
+--------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;自连接&lt;/h4&gt;
&lt;p&gt;是指的是同一张表的连接查询&lt;/p&gt;
&lt;p&gt;显示公司员工和它上级的名字&lt;/p&gt;
&lt;p&gt;这个时候我们就需要使用到表的自连接，将员工和上级放在同一行中筛选完成（还需要有一个别名）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp empee, emp boss;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以将同一张表连接起来，我们再去写过滤条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select empee.ename,boss.ename  
from emp empee, emp boss 
where empee.mgr = boss.empno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+
| ename | ename |
+-------+-------+
| WARD  | BLAKE |
+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;子查询&lt;/h3&gt;
&lt;p&gt;子查询是指嵌入在其他sql语句中的select语句，也成为嵌套查询&lt;/p&gt;
&lt;p&gt;单行子查询：只返回一行数据的子查询语句&lt;/p&gt;
&lt;p&gt;多行子查询：返回多行数据的子查询语句（in）&lt;/p&gt;
&lt;p&gt;单行子查询例题&lt;/p&gt;
&lt;p&gt;如何显示于SMITH同一部门的所有员工&lt;/p&gt;
&lt;p&gt;我们首先需要得到SMITH的部门号，再通过部门号筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno from emp where ename = &apos;SMITH&apos;;//20
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以把第一个查询嵌入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp 
where deptno = (
	select deptno 
    from emp 
    where ename = &apos;SMITH&apos;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可完成&lt;/p&gt;
&lt;p&gt;多行子查询例题&lt;/p&gt;
&lt;p&gt;查询和部门20的工作相同的雇员的名字、岗位、部门号，但是不包含20自己的&lt;/p&gt;
&lt;p&gt;第一步：查询20号部门有哪一些工作岗位（还需要去重）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct job from emp where deptno = 20;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+---------+
| job     |
+---------+
| CLERK   |
| MANAGER |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：运用job的工作字段进行查询筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三步：不包含20号部门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(&apos;CLERK&apos;,&apos;MANAGER&apos;) and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,job,sal,deptno from emp 
where job in(
	select distinct job 
	from emp 
	where deptno = 20) 
and deptno&amp;lt;&amp;gt;20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子查询临时表&lt;/h4&gt;
&lt;p&gt;查询ecshop中各个类别中，价格最高的商品&lt;/p&gt;
&lt;p&gt;先得到各个类别中价格最高的商品&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select cat_id, max(shop_price) from ecsshop
group by cat_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以将这个表格和ecsshop表进行连接，在设置过滤条件即可完成要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ecshop.cat_id, ecshop.goods_name 
from ecshop,(
select cat_id, max(shop_price) as max_price
from ecshop
group by cat_id)temp
where ecshop.cat_id=temp.cat_id 
and ecshop.shop_price=temp.max_price;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;all和any操作符&lt;/h4&gt;
&lt;p&gt;all&lt;/p&gt;
&lt;p&gt;所有的字段都满足&lt;/p&gt;
&lt;p&gt;显示比部门30的所有员工的工资高的员工姓名、工资、部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
all(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以运用max查询最大的薪水，再通过判断条件筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select max(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;any&lt;/p&gt;
&lt;p&gt;有一个字段满足条件即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
any(
    select sal 
    from emp 
    where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename,sal,deptno from emp 
where sal&amp;gt;
(select min(sal) 
 from emp 
 where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多列子查询&lt;/h4&gt;
&lt;p&gt;多列子查询指的是查询返回多个列数据的子查询语句&lt;/p&gt;
&lt;p&gt;例如查询于SMITH部门，岗位完全相同的所有雇员&lt;/p&gt;
&lt;p&gt;第一步：查询SMITH所在的部门以及岗位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno,job from emp where ename=&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+-------+
| deptno | job   |
+--------+-------+
|     20 | CLERK |
+--------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将上述的查询结果当作查询使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where deptno=20 
and job=&apos;CLERK&apos;
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综合嵌套(运用（）来进行相应的字段匹配)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select ename, deptno, job from emp 
where (deptno, job) = (
	select deptno,job from emp 
    where ename=&apos;SMITH&apos;
)
and ename&amp;lt;&amp;gt;&apos;SMITH&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;相关例题&lt;/h4&gt;
&lt;p&gt;例题一：&lt;/p&gt;
&lt;p&gt;查找每个部门工资高于本部门平均工资人的资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的平均工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, avg(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;p&gt;(这里的emp.*代表选出emp表的所有字段)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, avg(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal&amp;gt;temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题二：&lt;/p&gt;
&lt;p&gt;查询每个部门工资最高的人的详细资料&lt;/p&gt;
&lt;p&gt;第一步：查询部门的最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select deptno, max(sal) from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：将查询的结果表和员工表进行拼接，再进行筛选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select emp.* from emp,(
	select deptno, max(sal)as avg_sal
	from emp group by deptno
)temp where emp.deptno=temp.deptno 
and emp.sal=temp.avg_sal;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题三：&lt;/p&gt;
&lt;p&gt;查询每个部门的信息（包括：部门名，编号，地址）和人员数量&lt;/p&gt;
&lt;p&gt;思路：我们的信息来自于dept表，而人员数量需要构建临时表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*),deptno from emp group by deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+
| count(*) | deptno |
+----------+--------+
|        2 |     20 |
|        4 |     30 |
+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和部门信息表格拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.*, countp 
from dept,(
	select deptno,count(*)as countp 
	from emp 
    group by deptno)temp 
where dept.deptno=temp.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+----------+---------+--------+
| deptno | dname    | loc     | countp |
+--------+----------+---------+--------+
|     20 | RESEARCH | DALLAS  |      2 |
|     30 | SALES    | CHICAGO |      4 |
+--------+----------+---------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表复制&lt;/h3&gt;
&lt;h4&gt;自我复制数据&lt;/h4&gt;
&lt;p&gt;有的时候，为了对于某个sql语句进行效率测试，我们需要海量的数据，可以使用此法为表创建海量的数据&lt;/p&gt;
&lt;p&gt;例如创建这一张表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_table(	
	id int,
    `name` varchar(32),
	sal double,
	job varchar(32),
	deptno int
	);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先将emp表中的内容复制到创建的新表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table(id,`name`,sal,job,deptno)
select empno,ename,sal,job,deptno from emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自我复制：每一次都会将表中的内容复制添加到自己的表中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into my_table
select * from my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;去除表中的重复数据&lt;/h4&gt;
&lt;p&gt;可以通过like创建一个新表，格式和旧表一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table table2 like table1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1.创建一张临时表mytemp,该表数据结构和my_table一样&lt;/p&gt;
&lt;p&gt;2.把my_temp的记录通过distinct关键字处理复制&lt;/p&gt;
&lt;p&gt;3.清除掉原先表my_table的记录&lt;/p&gt;
&lt;p&gt;4.将my_temp的记录复制到my_table&lt;/p&gt;
&lt;p&gt;5.drop删除临时表my_temp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table my_temp like my_table;

insert into my_temp
select distinct * from my_table;

delete from my_table;

insert into my_table
select * from my_temp;

drop table my_temp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你直接删除原先的my_table表，再将my_temp表格更改名称为my_table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table my_temp to my_table;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并查询&lt;/h3&gt;
&lt;h4&gt;union&lt;/h4&gt;
&lt;p&gt;在实际使用的时候，有的时候我们需要合并多个select语句查询到的结果，我们会用到union操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select... union select...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如我们查询职业名称为clerk和部门号为20的并集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;union all&lt;/h4&gt;
&lt;p&gt;如果你添加了all，则不会去除重复内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from emp where job=&apos;clerk&apos; 
union all select * from emp where deptno=20;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;外连接&lt;/h3&gt;
&lt;h4&gt;问题引出&lt;/h4&gt;
&lt;p&gt;还记得之前我们的多表查询嘛，我们在合并表的时候会求多表的笛卡尔集&lt;/p&gt;
&lt;p&gt;我们有一个要求如下：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;我们如果用笛卡尔积的话查询结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dname,ename,job 
from emp,dept 
where emp.deptno=dept.deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+--------+----------+
| dname    | ename  | job      |
+----------+--------+----------+
| RESEARCH | SMITH  | CLERK    |
| RESEARCH | JOOES  | MANAGER  |
| SALES    | ALLEN  | SALESMAN |
| SALES    | WARD   | SALESMAN |
| SALES    | MARTIN | SALESMAN |
| SALES    | BLAKE  | MANAGER  |
+----------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是事实上我们的部门中还有其他的部门没有显示出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+----------+
| deptno | dname      | loc      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为员工表的部门号没有10、40无法匹配到部门表，我们要实现显示出那些没有员工的部门，我们需要外连接，我们创建如下的表作演示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE stu (
`id` INT,
`name` VARCHAR ( 32 ));

INSERT INTO stu
VALUES
	( 1, &apos;Jack&apos; ),
	( 2, &apos;Tom&apos; ),
	( 3, &apos;Kity&apos; ),
	( 4, &apos;nono&apos; );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE exam (
`id` INT,
`grade` INT);

INSERT INTO exam
VALUES
	( 1, 56 ),
	( 2, 76 ),
	( 11, 8 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用where条件筛选后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu,exam where stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+----+-------+
| id | name | id | grade |
+----+------+----+-------+
|  1 | Jack |  1 |    56 |
|  2 | Tom  |  2 |    76 |
+----+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见是没有11号id和4号id的行记录的，因为id不是左右两表都有&lt;/p&gt;
&lt;h4&gt;左外连接&lt;/h4&gt;
&lt;p&gt;左侧的表完全显示（如果没有成绩也要显示姓名与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu left join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+------+------+-------+
| id | name | id   | grade |
+----+------+------+-------+
|  1 | Jack |    1 |    56 |
|  2 | Tom  |    2 |    76 |
|  3 | Kity | NULL | NULL  |
|  4 | nono | NULL | NULL  |
+----+------+------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;右外连接&lt;/h4&gt;
&lt;p&gt;又侧的表完全显示（如果没有姓名也要显示成绩与id）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from stu right join exam on stu.id=exam.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+------+----+-------+
| id   | name | id | grade |
+------+------+----+-------+
|    1 | Jack |  1 |    56 |
|    2 | Tom  |  2 |    76 |
| NULL | NULL | 11 |     8 |
+------+------+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;回到我们的例题：列出部门名称和这些部门的员工名称和工作，同时要求显示出那些没有员工的部门名&lt;/p&gt;
&lt;p&gt;左外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from dept left join emp 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;右外连接实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select dept.deptno,dname,ename,job 
from emp right join dept 
on dept.deptno=emp.deptno; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+--------+------------+--------+----------+
| deptno | dname      | ename  | job      |
+--------+------------+--------+----------+
|     10 | ACCOUNTING | NULL   | NULL     |
|     20 | RESEARCH   | JOOES  | MANAGER  |
|     20 | RESEARCH   | SMITH  | CLERK    |
|     30 | SALES      | BLAKE  | MANAGER  |
|     30 | SALES      | MARTIN | SALESMAN |
|     30 | SALES      | WARD   | SALESMAN |
|     30 | SALES      | ALLEN  | SALESMAN |
|     40 | OPERATIONS | NULL   | NULL     |
+--------+------------+--------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;MySQL中的约束&lt;/h2&gt;
&lt;p&gt;何为约束？&lt;/p&gt;
&lt;p&gt;约束是用于确保数据库数据满足特定的商业规则，而再mysql中约束包括not null、unique、primary key、foreign key、check五种&lt;/p&gt;
&lt;h3&gt;primary key&lt;/h3&gt;
&lt;p&gt;primary key：用于唯一的标示表行的数据，当定义主键约束之后，该列不可以重复，以下是一个案例&lt;/p&gt;
&lt;p&gt;创建一个主键为id表，向其中插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test (
	`id` INT PRIMARY KEY,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) 
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values
(1,&apos;jack&apos;,&apos;jack@qq.com&apos;),
(2,&apos;marry&apos;,&apos;marry@gmail.com&apos;),
(3,&apos;lory&apos;,&apos;lory@163.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们现在加一条语句，id为1（之前加过id为1的记录）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into primary_test values(1,&apos;jerry&apos;,&apos;jerry@qq.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 1062 - Duplicate entry &apos;1&apos; for key &apos;primary_test.PRIMARY&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主键的细节&lt;/p&gt;
&lt;p&gt;1.一张表最多只能有一个主键，但可以是复合主键&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test2 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`,`name`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.主键的指定方式有两种，第一种是直接在字段名 类型后加上primary key，第二种是在表的定义最后加上primary key(列名)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE primary_test4 (
	`id` INT ,
	`name` VARCHAR ( 32 ),
	`email` VARCHAR ( 32 ) ,
	 primary key(`id`)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用desc可以查看主键情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(32) | YES  |     | NULL    |       |
| email | varchar(32) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.主键不可以重复且不能为空&lt;/p&gt;
&lt;h3&gt;not null&lt;/h3&gt;
&lt;p&gt;非空约束，当列上定义了not null，那么插入数据的时候必须要提供数据&lt;/p&gt;
&lt;h3&gt;unique&lt;/h3&gt;
&lt;p&gt;唯一约束&lt;/p&gt;
&lt;p&gt;1.当定义了唯一约束的时候，该列的值不可以重复&lt;/p&gt;
&lt;p&gt;2.一张表可以有多个unique字段&lt;/p&gt;
&lt;p&gt;3.当unique没有添加非空约束，则unique字段可以有多个null&lt;/p&gt;
&lt;h3&gt;foreign key&lt;/h3&gt;
&lt;p&gt;外键&lt;/p&gt;
&lt;p&gt;用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须要拥有主键约束或者是unique约束，当定义外键约束后，要求外键列数据必须要在主表的主键列存在或者是null&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;例如我们有一个学生表其中有id和class_id，还有一个班级表，有属性id，如果我们要求，每个学生所在的班级号class_id是存在于班级表的，就可以把class_id做成外键约束（班级表为主表，而学生表为从表）&lt;/p&gt;
&lt;p&gt;当我们插入一个学生它的班级编号不存在于班级表，则插入失败&lt;/p&gt;
&lt;p&gt;当我们学生表有一个学生他的班级编号存在班级表，则删除对应的班级表id会删除失败&lt;/p&gt;
&lt;p&gt;班级表（主表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_class (
	`id` INT primary key,
	`name` VARCHAR ( 32 ),
	`add` VARCHAR ( 32 ) 
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学生表（从表）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE my_stu (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`class_id` int,
	foreign key(class_id) references my_class(id)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外键细节&lt;/p&gt;
&lt;p&gt;1.外键指向的表字段，要求为primary key或者是unique&lt;/p&gt;
&lt;p&gt;2.表的类型是innodb，这样的表才支持外键&lt;/p&gt;
&lt;p&gt;3.外键字段的类型要求和主键字段类型一致&lt;/p&gt;
&lt;p&gt;4.外键字段的值必须要求在主键字段中出现过，或者为null&lt;/p&gt;
&lt;p&gt;5.一旦建立主外键的关系，数据就不可以随意删除了&lt;/p&gt;
&lt;h3&gt;check&lt;/h3&gt;
&lt;p&gt;用于强制行数据必须满足条件，注意在mysql 5.7，这里插入不符合check的数据会成功（只是会提示）8.0是会生效的&lt;/p&gt;
&lt;p&gt;假设sal列上定义了check约束，并要求sql列值在1000-2000之间，性别为两个，那么如果插入的记录如果不满足相关条件就会提示报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test (
	`id` INT primary key,
	`name` VARCHAR (32) NOT NULL,
	`sex` VARCHAR(10) CHECK (`sex` IN(&apos;man&apos;,&apos;woman&apos;)),
	`sal` double CHECK (`sal`&amp;gt;1000 and `sal`&amp;lt;2000)
) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表设计&lt;/h3&gt;
&lt;p&gt;现有一个商店的数据库shop_database，记录客户以及其购物情况，有以下的三个表组成&lt;/p&gt;
&lt;p&gt;goods商品表：&lt;/p&gt;
&lt;p&gt;商品号goods_id  商品名称goods_name  价格price  商品类别category 供货商provider&lt;/p&gt;
&lt;p&gt;customer顾客表：&lt;/p&gt;
&lt;p&gt;客户号customer_id  姓名name  住址address  邮箱email  性别sex  身份证id&lt;/p&gt;
&lt;p&gt;purchase购买表：&lt;/p&gt;
&lt;p&gt;订单号order_id  客户号customer_id  商品号goods_id  购买数量nums&lt;/p&gt;
&lt;p&gt;要求如下：&lt;/p&gt;
&lt;p&gt;1.合理定义主键、外键&lt;/p&gt;
&lt;p&gt;2.客户姓名不可以为空值&lt;/p&gt;
&lt;p&gt;3.电子邮箱不可以为重复&lt;/p&gt;
&lt;p&gt;4.客户的性别约束‘男’|‘女’&lt;/p&gt;
&lt;p&gt;5.价格在1.0——9999.99之间&lt;/p&gt;
&lt;p&gt;goods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table goods(
goods_id int primary key,
goods_name varchar(30) not null default &apos;&apos;,
price decimal(10,2)not null 
    check(price between 1.0 and 9999.99),
category int not null default &apos;&apos;,
provider varchar(30)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;customer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table customer(
customer_id int primary key,
name varchar(30) not null,
address varchar(30),
email varchar(30),
sex varchar(10) check(sex IN(&apos;男&apos;,&apos;女&apos;)),
id decimal(20,0) unique
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;purchase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table purchase(
order_id int primary key,
customer_id int not null,
goods_id int not null,
nums int,
FOREIGN key(customer_id) REFERENCES customer(customer_id),
FOREIGN key(goods_id) REFERENCES goods(goods_id)
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E4%BF%AE%E6%94%B9%E8%A1%A8crud%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description>修改表，CRUD，常用函数</description><pubDate>Fri, 11 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL笔记&lt;/h1&gt;
&lt;h2&gt;修改表&lt;/h2&gt;
&lt;p&gt;我们修改表可以通过图形化界面进行修改，这一般比较方便，但是有一些限制，例如需要批量修改，条件限制的情况，我们也需要学会通过指令来对于表进行操作&lt;/p&gt;
&lt;h3&gt;添加列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name ADD(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name MODIFY(column datatype [DEFAULT expr]
, column datatype [DEFAULT expr]...);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name DROP(column);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重命名表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RENAME TABLE `oldTable` TO `newTable`;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看表结构&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;desc newtable;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(20) | YES  |     | NULL    |       |
| sex        | char(1)     | YES  |     | NULL    |       |
| birthday   | date        | YES  |     | NULL    |       |
| entry_date | datetime    | YES  |     | NULL    |       |
| job        | varchar(20) | YES  |     | NULL    |       |
| Salary     | double      | YES  |     | NULL    |       |
| resume     | text        | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
8 rows in set (0.09 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改表字符集&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.在创建的员工表上增加一个image列，varchar类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ ADD `image` VARCHAR ( 30 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.修改job列，使其长度为60&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ MODIFY `job` VARCHAR ( 60 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.删除sex列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employ DROP `sex`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.将表名更改为employee&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rename table employ to employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.修改表的字符集为utf8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.将列名name修改为user_name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee CHANGE `name` user_name VARCHAR(32); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在修改列属性的时候可以加一些规则，例如不为空，默认为&apos;null&apos;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE employee MODIFY `user_name` VARCHAR(32) NOT NULL DEFAULT &apos;null&apos;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CRUD&lt;/h2&gt;
&lt;p&gt;create read update delete 增删改查&lt;/p&gt;
&lt;p&gt;我们在之前也曾用到过这一些语句，现在我们系统的来进行学习CRUD&lt;/p&gt;
&lt;h3&gt;Insert（增）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name [(column, column, ...)] VALUES (value, value, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;创建一张商品表(id int , goods_name varchar(10), price double)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE goods(
`id` int,
`goods_name` varchar(10),
`price` double);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中添加两条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods VALUES (1, &apos;牙刷&apos;, 10.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO goods (id, goods_name) VALUES (2, &apos;牙膏&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from goods;

+----+------------+-------+
| id | goods_name | price |
+----+------------+-------+
|  1 | 牙刷       |    10 |
|  2 | 牙膏       | NULL  |
+----+------------+-------+
2 rows in set (0.08 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意细节&lt;/h4&gt;
&lt;p&gt;1.插入的数据应该与字段的数据类型相同&lt;/p&gt;
&lt;p&gt;2.数据的长度因该在列的规定范围内&lt;/p&gt;
&lt;p&gt;3.value中列出的数据位置必须于被加入的列的排列位置对应&lt;/p&gt;
&lt;p&gt;4.字符和日期类型数据需要包含在单引号中&lt;/p&gt;
&lt;p&gt;5.列允许插入空值（前期是字段不是NOT NULL）&lt;/p&gt;
&lt;p&gt;6.插入的记录可以有多条，在后续加（），（）即可&lt;/p&gt;
&lt;p&gt;7.如果是表中的所有字段添加数据的时候，可以不写字段名称&lt;/p&gt;
&lt;p&gt;8.默认值的使用，当不给某个字段值的时候，如果有默认值就会添加，否则填入null，如果NOT NULL则报错&lt;/p&gt;
&lt;h3&gt;Update（改）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;UPDATE table_name SET col_name1 = expr1 [col_name2 = expr2] [WHERE where_definition]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个使用案例&lt;/p&gt;
&lt;p&gt;1.将所有的员工薪水修改为5000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 5000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将力宏的薪水修改为3000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = 3000 WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.将lory的薪水上调1000元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.UPDATE语法可以指定用新值更新原有表行中的各列&lt;/p&gt;
&lt;p&gt;2.SET子句指定要修改那些列和赋予的哪些值&lt;/p&gt;
&lt;p&gt;3.WHERE子句指定应该更新哪些行，如果没有，则更新所有的行&lt;/p&gt;
&lt;p&gt;4.如果需要修改多个字段，可以通过set 字段1= value，set 字段2= value...完成，例如如下代码，就顺便进行了id++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE employee SET Salary = Salary + 1000, id = id + 1 WHERE `user_name`=&apos;lory&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Delete（删）&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;案例&lt;/p&gt;
&lt;p&gt;1.删除用户名为力宏的记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee WHERE `user_name`=&apos;力宏&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.删除表中的所有记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.如果不加WHERE子句，就会删除表中所有的记录&lt;/p&gt;
&lt;p&gt;2.DELETE语句不可以删除某一列的值（可以使用update更新字段为null）&lt;/p&gt;
&lt;p&gt;3.使用DELETE语句尽可以删除表的记录，不可以删除表本身，需要使用DROP删除表&lt;/p&gt;
&lt;h3&gt;Select（查）&lt;/h3&gt;
&lt;p&gt;算是数据库的一个重点&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT [DISTINCT] * | [column1, colum2, ...] FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中DISTANCT可选，表示是否去除重复数据&lt;/p&gt;
&lt;p&gt;1.查询所有的员工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询非重复的员工（每个字段都相同）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct * from employee;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----+-----------+------+--------+
| id | user_name | job  | Salary |
+----+-----------+------+--------+
|  1 | 李明      | NULL |   2000 |
|  2 | 王丽      | NULL |   2000 |
|  3 | 丽华      | NULL |  20003 |
|  4 | 李儒      | NULL |   2000 |
|  5 | 小明      | NULL |   2000 |
|  6 | lory      | NULL |  20003 |
+----+-----------+------+--------+
6 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.SELECT语句可以进行一些运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * | (column1 | expression, column2 | expression, ...)FROME table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如在查询科目成绩时可以指定查询的一列为其他的几列相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT (english + math + chinese) as `grades` from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.SELECT可以使用as语句取别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column_name as other_name from table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT `user_name` as `name`, `Salary` as `money` FROM `employee`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------+-------+
| name | money |
+------+-------+
| 李明 |  2000 |
| 李明 |  2000 |
| 王丽 |  2000 |
| 丽华 | 20003 |
| 李儒 |  2000 |
| 小明 |  2000 |
| lory | 20003 |
+------+-------+
7 rows in set (0.07 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.和改删一样，SELECT一样可以运用WHERE过滤&lt;/p&gt;
&lt;p&gt;常见的运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;  &amp;lt;  &amp;lt;=  &amp;gt;=  =  &amp;lt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于 小于 大于等于 小于等于 等于 不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BETWEEN...AND...&lt;/td&gt;
&lt;td&gt;显示在某一区间内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN(set)&lt;/td&gt;
&lt;td&gt;显示在in列表中的值，如in(100，200)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[NOT] LIKE &apos;张pattern&apos;&lt;/td&gt;
&lt;td&gt;模糊查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;判断是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;6.使用order by设置排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT  * | [column1, colum2, ...] FROM table_name 
ORDER BY column1 asc|desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排序的列可以是表中的列名，也可以select语句中指定的列名&lt;/p&gt;
&lt;p&gt;Asc升序 Desc降序&lt;/p&gt;
&lt;p&gt;ORDER BY 子句应该位于SELECT语句的末尾&lt;/p&gt;
&lt;p&gt;7.group by + having&lt;/p&gt;
&lt;p&gt;使用group by子句对列进行分组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用having子句对分组后的结果过滤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, colum2, ... FROM table_name 
group by column1 having ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例&lt;/p&gt;
&lt;p&gt;1.显示每个部门的平均工资和最高工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MAX(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.显示每个部门的每种岗位的平均工资和最低工资&lt;/p&gt;
&lt;p&gt;可以先显示每个部门的平均工资和最低工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno FROM emp GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还需要再添加一个分组的标准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), MIN(sal), deptno, job FROM emp GROUP BY deptno, job;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.显示平均工资低于2000的部门号和他的平均工资&lt;/p&gt;
&lt;p&gt;先显示各个部门的平均工资和部门号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal), deptno FROM emp 
GROUP BY deptno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运用having进行过滤实现平均工资小于2000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(sal) as avg_sal, deptno FROM emp 
GROUP BY deptno
HAVING avg_sal &amp;lt; 2000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是SELECT使用例题：&lt;/p&gt;
&lt;p&gt;1.对数学成绩排序后输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student ORDER BY `math` asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.对总分按照降序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT `name` , (`math`+`english`+`chinese`) as grade FROM student ORDER BY grade desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.对姓李的学生按照成绩排序输出[升序]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `name` LIKE &apos;李%&apos; ORDER BY (`math`+`english`+`chinese`)  asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;1.查询math大于60并且id大于90的学生成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; 60 and id &amp;gt; 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.查询英语成绩大于语文成绩的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `math` &amp;gt; `chinese`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.查询总分大于200分并且数学成绩小于语文成绩的韩姓同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE (`math`+`chinese`+`english`)&amp;gt;200 and `math`&amp;lt;`chinese` and user_name LIKE &apos;韩%&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.查询英语成绩在80-90分的同学(闭区间)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` BETWEEN 80 AND 90;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.查询数学分数为89，90，91的同学&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM student WHERE `english` IN(89,90,91);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;重要的函数&lt;/h2&gt;
&lt;h3&gt;Count&lt;/h3&gt;
&lt;p&gt;统计函数&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT COUNT(*) | COUNT(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count(*)和count(column)区别&lt;/p&gt;
&lt;p&gt;count(*)返回满足条件记录的行数&lt;/p&gt;
&lt;p&gt;count(column)统计满足条件的某列有多少的，但排除对应列为null的情况&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计班级里一共有几个学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        7 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计总分大于300的学生个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select count(*) from student where `grade` &amp;gt; 300;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| count(*) |
+----------+
|        4 |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SUM&lt;/h3&gt;
&lt;p&gt;合计函数&lt;/p&gt;
&lt;p&gt;Sum函数返回满足where条件的行的和---一般使用在数值列&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅对数值起作用&lt;/p&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.统计一个班数学总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.统计一个班语文、英语、数学各科的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math),SUM(english),SUM(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.统计一个班语文、英语、数学各科和的总成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.统计一个班级语文的平均分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUM(chinese)/COUNT(*) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们也可以使用AVG统计函数求平均值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;AVG&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT AVG(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用案例如上，不再过多赘述&lt;/p&gt;
&lt;h3&gt;MAX/MIN&lt;/h3&gt;
&lt;p&gt;数值范围在统计中特别有用&lt;/p&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX/MIN(column) FROM table_name [WHERE where_definition];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用案例&lt;/h4&gt;
&lt;p&gt;1.求班级最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math + english + chinese)，MIN(math + english + chinese) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.求出班级数学最高分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT MAX(math)，MIN(math) FROM student;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符串函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHARSET(str)&lt;/td&gt;
&lt;td&gt;返回字串字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CONCAT(str2 [,...])&lt;/td&gt;
&lt;td&gt;连接字串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INSTR(string, substring)&lt;/td&gt;
&lt;td&gt;返回substring在string中出现的位置，没有则返回0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UCASE(str2)&lt;/td&gt;
&lt;td&gt;转为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LCASE(str2)&lt;/td&gt;
&lt;td&gt;转为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LEFT(str2, length)&lt;/td&gt;
&lt;td&gt;从str2中的左边起取length个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LENGTH(string)&lt;/td&gt;
&lt;td&gt;string长度[按照字节]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPLACE(str, search_str, replace_str)&lt;/td&gt;
&lt;td&gt;在str中用字符串替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STRCMP(str1,str2)&lt;/td&gt;
&lt;td&gt;逐个字符比较两个字符串大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUBSTRING(str, position [length])&lt;/td&gt;
&lt;td&gt;从str的position开始，取length个字符，不写则取完&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LTRIM(str2) RTRIM(str2)&lt;/td&gt;
&lt;td&gt;去除前端空格去除后端空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trim&lt;/td&gt;
&lt;td&gt;去除左右两边空格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;CHARSET(str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CHARSET(name) FROM emp;
//返回字符集（utf8）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CONCAT(str2 [,...])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(name, &apos;job is&apos;, job) as name_job FROM emp;
//字符串拼接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;INSTR(string, substring)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT INSTR(string, &apos;target&apos;) FROM DUAL;--其中DUAL是亚元表
//返回出现位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UCASE(str2) LCASE(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT UCASE(name) FROM emp;//转为大写
SELECT LCASE(name) FROM emp;//转为小写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LEFT(str2, length) RIGHT(str2, length)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LEFT(name, 2) FROM emp;//从左取2个字符
SELECT RIGHT(name, 2) FROM emp;//从右取2个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LENGTH(string)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LENGTH(name) FROM emp;//返回名字长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REPLACE(str, search_str, replace_str)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT REPLACE(name, &apos;a&apos;, &apos;b&apos;) FROM emp;
//将名字中的a替换为b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;STRCMP(str1,str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT STRCMP(str1,str2) FROM DUAL;
//比较字符串大小 小于返回-1 大于返回1 等于返回0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SUBSTRING(str, position [length])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT SUBSTRING(name, 1, 2) FROM emp;
//从第一个位置开始取两个字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LTRIM(str2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT LTRIM(&apos; 名字&apos;) FROM DUAL;//&apos;名字&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;以首字母小写的方式显示所有员工emp表的名字&lt;/p&gt;
&lt;p&gt;取出第一个字符转为小写然后和后面的字符拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CONCAT(LCASE(LEFT(name, 1)),
SUBSTRING(name,2,LENGTH(name))) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数学函数&lt;/h3&gt;
&lt;p&gt;有很多，我挑几个常用的&lt;/p&gt;
&lt;h4&gt;ABS(num)&lt;/h4&gt;
&lt;p&gt;绝对值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT ABS(-1) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;CEILING(number)&lt;/h4&gt;
&lt;p&gt;向上取整，得到比number大的最小整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT CEILING(1.34) FROM DUAL;//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;FLOOR(number)&lt;/h4&gt;
&lt;p&gt;向下取整，得到比number小的最大整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT FLOOR(1.34) FROM DUAL;//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;RAND([seed])&lt;/h4&gt;
&lt;p&gt;随机数范围为[0,1,0]&lt;/p&gt;
&lt;p&gt;不加种子返回的数每次都不同&lt;/p&gt;
&lt;p&gt;种子指定后返回的数不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT RAND(6) FROM DUAL;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;日期相关函数&lt;/h3&gt;
&lt;p&gt;对于日期而言也有非常多的相关函数，有点小多，在这里不过多介绍，即查即用&lt;/p&gt;
&lt;h3&gt;加密函数于系统函数&lt;/h3&gt;
&lt;h4&gt;USER()&lt;/h4&gt;
&lt;p&gt;显示登录到mysql有哪些用户以及登陆的IP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select user() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;DATABASE()&lt;/h4&gt;
&lt;p&gt;查询使用数据库名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select DATABASE() from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+
| DATABASE() |
+------------+
| dbtest     |
+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;MD5(str)&lt;/h4&gt;
&lt;p&gt;为字符串计算出一个MD5 32的字符串，常用为用户密码加密(32位)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select MD5(&apos;密码&apos;) from dual;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+----------------------------------+
| MD5(&apos;密码&apos;)                      |
+----------------------------------+
| a8105204604a0b11e916f3879aae3b0b |
+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;UPDATE user SET `password`=MD5(654321);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;PASSWORD(str)&lt;/h4&gt;
&lt;p&gt;加密函数，是MySQL使用的加密方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from mysql.user
//其中的$A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED就是加密后的密码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流程控制函数&lt;/h3&gt;
&lt;h4&gt;IF(expr1,expr2,expr3)&lt;/h4&gt;
&lt;p&gt;如果表达式1为真，返回expr2，否则返回expr3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IF(TRUE, &apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;IFNULL(expr1,expr2)&lt;/h4&gt;
&lt;p&gt;如果表达式1为NULL，返回expr1，否则返回expr2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT IFNULL(&apos;BEIJING&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//BEIJING
SELECT IFNULL(&apos;NULL&apos;, &apos;SHANGHAI&apos;) FROM DUAL;//SHANGHAI
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;多分支函数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN expr1 THEN expr2 
WHEN expr3 THEN expr4 
ELSE expr5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT CASE 
WHEN FALSE THEN expr2 
WHEN TRUE THEN expr4 
ELSE expr5 END
//返回expr2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;查询emp表，如果comm是null，就显示0.0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IF(comm IS NULL, 0.0, comm) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, IFNULL(comm, 0.0) FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果emp表的job是CLERK则显示职员，如果是MANAGER则显示经理，如果是SALESMAN就显示销售人员，其他正常显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT name, (
SELECT CASE 
WHEN job=&apos;CLERK&apos; THEN &apos;职员&apos; 
WHEN job=&apos;MANAGER&apos; THEN &apos;经理&apos; 
WHEN job=&apos;SALESMAN&apos; THEN &apos;销售人员&apos; 
ELSE job END) AS &apos;job&apos;
FROM emp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是MySQL的基本语句，查询的基础部分，和一些常见的函数，我们明天会进入增强查询（多表查询）&lt;/p&gt;
</content:encoded></item><item><title>MySQL笔记</title><link>https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/mysql%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</guid><description>基本使用，数据类型，备份恢复</description><pubDate>Thu, 10 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;p&gt;​	经过40天的Java学习，我系统性的学习了Java相关知识点，了解了各个知识点背后的源码逻辑，可以用Java语言实现各类算法，以及解决实际问题，独立的设计，编写相关项目。&lt;/p&gt;
&lt;p&gt;​	而从今天开始我将开始数据库的学习，预计5天完成MySQL数据库基本操作的学习，之后运用JDBC完成一个实战项目&lt;/p&gt;
&lt;p&gt;​	我在之前选修数据库课程的时候，只是停留在理论上，对于知识的理解也只是限于应付考试，为了更好的理解数据库以及更好的使用数据库，我决定再次回顾相关知识点，并且整理笔记&lt;/p&gt;
&lt;h2&gt;MySQL的基本使用&lt;/h2&gt;
&lt;p&gt;关于MySQL的安装我就不过多赘述，因为之前也安装过了，详见各大网站上的安装使用教程照着安装即可&lt;/p&gt;
&lt;h3&gt;MySQL启动服务&lt;/h3&gt;
&lt;p&gt;在我这里因为安装的时候设置为开机自动启用，所以不用执行该指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net start mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的如果需要停止服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net stop mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过以下的指令查看数据库服务是否启用（root）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sc query MySQL80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示MySQL80在运行状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SERVICE_NAME: MySQL80
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;MySQL数据库的本地连接&lt;/h3&gt;
&lt;p&gt;-h 表示连接的主机 localhost为本地主机&lt;/p&gt;
&lt;p&gt;-P 代表的是连接端口&lt;/p&gt;
&lt;p&gt;-u 代表的是登录用户名称&lt;/p&gt;
&lt;p&gt;-p654321 （输入登录密码，p后不加空格）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -h localhost -P 3306 -u root -p654321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要对于账户和密码进行修改我们可以在链接到数据库后，使用如下的指令对于账户的密码进行修改（654321）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的新密码&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实我们的登录账户名称和账户密码也会被存放在数据库中，我们上述的指令就是对于存放密码的数据库表进行更改操作&lt;/p&gt;
&lt;h2&gt;数据库的三层结构&lt;/h2&gt;
&lt;p&gt;1.所谓安装Mysql数据库，就是在主机上安装一个数据管理系统（DBMS），这个管理程序可以创建多个数据库&lt;/p&gt;
&lt;p&gt;2.一个数据库中可以创建多个表，用以保存数据&lt;/p&gt;
&lt;p&gt;3.数据库管理系统，数据库，表之间的关系（三层结构）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/109.png&quot; alt=&quot;109&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据库和表本质上是文件，存放在内存中&lt;/p&gt;
&lt;p&gt;表中的一行称之为一条记录，而在Java中一条记录使用一个对象来表示&lt;/p&gt;
&lt;h1&gt;SQL语句分类&lt;/h1&gt;
&lt;p&gt;DDL：数据定义语句（create 表，库.......）&lt;/p&gt;
&lt;p&gt;DML：数据操作语句（增删改查）&lt;/p&gt;
&lt;p&gt;DQL：数据查询语句（select）&lt;/p&gt;
&lt;p&gt;DCL：数据控制语句（管理数据库：如grant revoke）&lt;/p&gt;
&lt;h2&gt;创建数据库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE [IF NOT EXISTS] db_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;1.创建一个名为lory_db01的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database lory_db01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建一个使用utf-8字符集的lory_db02的数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db02 character set utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.创建一个使用utf-8字符集并带校对规则的lory_db03的数据库(区分大小写utf8_bin)默认不区分大小写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database lory_db03 character set utf8 collate utf8_bin;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区分大小与否&lt;/h3&gt;
&lt;p&gt;不区分大小写的情况下使用查询语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from students where name = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| B  | B    |
| d  | b    |
+----+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区分大小写的情况下（利用COLLARTE指定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM students WHERE name COLLATE utf8mb4_bin = &apos;b&apos;;
+----+------+
| id | name |
+----+------+
| d  | b    |
+----+------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查询数据库&lt;/h2&gt;
&lt;h3&gt;显示数据库语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| dbtest             |
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| student            |
| sys                |
| test               |
| world              |
+--------------------+
9 rows in set (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;显示数据库创建语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;show create database db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show create database student;

| Database | Create Database                       
| student  | CREATE DATABASE `student` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=&apos;N&apos; */ |

1 row in set (0.05 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据库删除语句&lt;/h3&gt;
&lt;p&gt;[ ]中内容可选&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop database [IF EXISTS] db_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;备份与恢复&lt;/h2&gt;
&lt;p&gt;备份是实际工作中非常重要的部分，我们无论是要进行数据库转移还是损坏后的恢复，都需要使用到备份和恢复数据库&lt;/p&gt;
&lt;h3&gt;备份数据库相关指令&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;p&gt;mysqldump&lt;/p&gt;
&lt;p&gt;(注意是在dos命令行中执行而不是数据库命令行界面)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p**** -B DB_1 DB_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C:\Windows\System32&amp;gt; mysqldump -u root -p654321 -B dbtest &amp;gt; d:\\test.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后在对应的路径下有一个备份文件，文件中其中存放了一些SQL语句，通过重新执行这些语句我们就可以恢复数据库中的内容（还有一些其他的信息）&lt;/p&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;p&gt;source&lt;/p&gt;
&lt;p&gt;(注意在数据库命令行中执行)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然你也可以将sql备份文件中的SQL语句直接执行&lt;/p&gt;
&lt;h3&gt;备份数据库表&lt;/h3&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;mysqldump -u root -p db_01 table_1 table_2 ... &amp;gt; File.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;恢复&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;source d:/test.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建数据库表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;create table table_name
(
	fieldname1 datatype,
	fieldname2 datatype,
	fieldname3 datatype,
)character set 字符集 collate 校对规则 engine 存储引擎
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;field：指定列名  datatype：指定字段类型  character set：不指定则默认为所在数据库字符集	collate：如不指定默认为所在数据库校对规则 engine（讲解待定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE student1 (
    id INT,
    name VARCHAR(255),
    password VARCHAR(255)
)
CHARACTER SET utf8mb4 
COLLATE utf8mb4_bin 
ENGINE=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;MySQL列类型&lt;/h1&gt;
&lt;h2&gt;类型总览&lt;/h2&gt;
&lt;h3&gt;数值类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BIT(M)&lt;/td&gt;
&lt;td&gt;位类型，M指定位数（1-64）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TINYINY [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占一个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SAMLLINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占两个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUMINT [UNSIGNED]&lt;/td&gt;
&lt;td&gt;占三个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT [UNSIGENED]&lt;/td&gt;
&lt;td&gt;INT类型，占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BIGINT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLOAT [UNSIGHNED]&lt;/td&gt;
&lt;td&gt;浮点型占4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOUBLE [UNSIGHED]&lt;/td&gt;
&lt;td&gt;浮点型占8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DECIMAL(M,D)&lt;/td&gt;
&lt;td&gt;定点数M指定长度，D表示小数点位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文本、二进制类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHAR(size) char(20)&lt;/td&gt;
&lt;td&gt;固定长度字符串，最大255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VARCHAR(size)&lt;/td&gt;
&lt;td&gt;可变长度字符串，0-65535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOB LONGBLOB&lt;/td&gt;
&lt;td&gt;二进制数据 BLOB （2^16）LONGBLOB（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEXT LONGTEXT&lt;/td&gt;
&lt;td&gt;文本Text （2^16）LONGTEXT（2^32）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;时间日日期类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DATE/DATETIME/TimeStamp&lt;/td&gt;
&lt;td&gt;日期类型（YYYY-MM-DD）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TimeStamp表示时间戳，可用于自定记录insert、updata操作的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/110.png&quot; alt=&quot;110&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Mysql常用数据类型&lt;/h2&gt;
&lt;p&gt;其中用的比较多的有以下几个&lt;/p&gt;
&lt;p&gt;int double decimal char varchar text datatime&lt;/p&gt;
&lt;p&gt;在实际使用的时候，在满足要求的情况下尽量用小的数据类型&lt;/p&gt;
&lt;h3&gt;整形&lt;/h3&gt;
&lt;h4&gt;TINYINT&lt;/h4&gt;
&lt;p&gt;以tinyint为例，支持-128~127，或者添加无符号参数支持0-255&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test(id TINYINT);
CREATE TABLE test(id TINYINT unsigned);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BIT&lt;/h4&gt;
&lt;p&gt;1.bit(m) m在1-64&lt;/p&gt;
&lt;p&gt;2.添加数据范围按照给定的位数确定，2的m次方&lt;/p&gt;
&lt;p&gt;3.显示的时候按照bit&lt;/p&gt;
&lt;p&gt;4.查询时任然可以按照数来查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test01(id BIT(8));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入数据以位的形式存储显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test01 VALUES(13);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;00001101
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;浮点型&lt;/h3&gt;
&lt;h4&gt;DECIMAL&lt;/h4&gt;
&lt;p&gt;1.FLOAT/DOUBLE于JAVA一样，单精度浮点数以及双精度&lt;/p&gt;
&lt;p&gt;2.DECIMAL可以支持更加精确的小数位，M为小数位数总数，D是小数点后面的位数&lt;/p&gt;
&lt;p&gt;3.如果D为0，则没有小数点和小数部分，M最大为65，D最大为30，如果D省略，默认为0，若M省略，默认为10&lt;/p&gt;
&lt;p&gt;4.如果希望精度较高推荐使用decimal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DECIMAL[M,D][UNSIGNED]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test02(num1 DECIMAL(30,20), num2 FLOAT);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test02 VALUES(88.1324, 133);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串&lt;/h3&gt;
&lt;h4&gt;CHAR(size)&lt;/h4&gt;
&lt;p&gt;固定长度字符串，最大为255字符&lt;/p&gt;
&lt;h4&gt;VARCHAR(size)&lt;/h4&gt;
&lt;p&gt;可变长度字符串，最大为65532字节（utf-8编码最大21844字符 1-3个字节用于记录大小）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test03(num1 VARCHAR(21844), num2 CHAR(255));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test03 VALUES(&apos;helloworld&apos;, &apos;你好&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;子字符串使用细节&lt;/h4&gt;
&lt;p&gt;1.char(m)和.varchar(m) m表示的是字符数，无论中英文都最多放m个&lt;/p&gt;
&lt;p&gt;2.char(4)是固定长度，即使插入aa，也会占据4个字符的空间，而varchar(4)是变长，会按照实际占用的空间分配，除此之外还需要1-3个字节存放记录内容长度&lt;/p&gt;
&lt;p&gt;3.如何选择：如果数据是定长的，例如手机，邮编等就用char，如果是不确定的就用varchar，例如留言，文章等，而在查询速度的上而言char的速度快于varchar&lt;/p&gt;
&lt;p&gt;4.在存放文本的时候也可以使用Text数据类型（更利于空间使用例如英文占一个字节，而中文占用三个字节），可以将TEXT列视为VAECHAR列，注意TEXT不可以有默认值，大小为0-2的16次，还需要更多的时候可以选择MEDIUMTEXT 或者 LONGTEXT&lt;/p&gt;
&lt;h3&gt;日期类型&lt;/h3&gt;
&lt;h4&gt;基本使用&lt;/h4&gt;
&lt;p&gt;时间戳可以设置为更新时的当前时间，这里没有加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test04 ( birthday DATE, job_time DATETIME, login_time TIMESTAMP );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test04(birthday, job_time) VALUES(&apos;2022-2-22&apos;, &apos;2022-2-22 10:10:10&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+------------+
| birthday   | job_time            | login_time |
+------------+---------------------+------------+
| 2022-02-22 | 2022-02-22 10:10:10 | NULL       |
+------------+---------------------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个自动更新的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE test05 (
  birthday DATE,
  job_time DATETIME,
  login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;+------------+---------------------+---------------------+
| birthday   | job_time            | login_time          |
+------------+---------------------+---------------------+
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:43 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:44 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
| 2022-02-22 | 2022-02-22 10:10:10 | 2025-04-11 15:35:45 |
+------------+---------------------+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建表例题&lt;/h3&gt;
&lt;p&gt;创建一个员工表，选取适当的数据类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;整形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sex&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;birthday&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entry_date&lt;/td&gt;
&lt;td&gt;日期型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;job&lt;/td&gt;
&lt;td&gt;字符型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Salary&lt;/td&gt;
&lt;td&gt;小数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resume&lt;/td&gt;
&lt;td&gt;文本型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;创建表格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `empty`(
	id INT,
	`name` VARCHAR ( 20 ),
	sex CHAR ( 1 ),
	birthday DATE,
	entry_date DATETIME,
	job VARCHAR ( 20 ),
	Salary DOUBLE,
	`resume` TEXT 
);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%8D%E5%B0%84/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%8D%E5%B0%84/</guid><description>反射（重中之重，框架学习的前置）</description><pubDate>Tue, 08 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;反射&lt;/h2&gt;
&lt;p&gt;reflection&lt;/p&gt;
&lt;h3&gt;引出反射&lt;/h3&gt;
&lt;p&gt;我们需要怎样才可以读出配置文件的内容，并调用配置文件的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classPath = com.reflection.Cat
method = hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;目标类文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;


public class Cat {
    public void hi() {
        System.out.println(&quot;hi&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一点很容易，我们通过创建properties在进行加载，就可以很容易的得到配置中的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReflectionQuestion {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;src\\re.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String classPath = properties.getProperty(&quot;classPath&quot;);
        String method = properties.getProperty(&quot;method&quot;);
        System.out.println(classPath + &quot; &quot; + method);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们要怎样取创建配置文件中的对象，和调用对应的方法呢？&lt;/p&gt;
&lt;p&gt;我们暂时还没有在不通过在不修改源码的情况下控制程序的办法，在这里我们就需要使用到反射机制来解决，以下是一个快速入门&lt;/p&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;我们需要以下的几个步骤&lt;/p&gt;
&lt;p&gt;1.加载类，返回Class类型的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//加载类运用一个Class的对象接收类的路径
Class cls = Class.forName(classPath);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.通过类得到你加载的类Cat对象实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过Class对象的实例调用newInstance获取到对应类路径下对象的实例
//（编译类型是一个Object）（运行类型是对应的类型）
Object obj = cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.通过类对象调用getMethod方法得到对应参数名称的方法，存在Method对象中（将方法视为一个对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过cls类调用方法getMethod获取方法
Method method01 = cls.getMethod(method);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.最后通过方法对象调用invoke传入对象,完成调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//最后通过方法对象调用invoke传入对象,完成调用
method01.invoke(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以实现不修改源码的基础上修改程序的内部逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReflectionQuestion {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;src\\re.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String classPath = properties.getProperty(&quot;classPath&quot;);
        String method = properties.getProperty(&quot;method&quot;);

        Class cls = Class.forName(classPath);
        Object targetClass = cls.newInstance();
        Method targetMethod = cls.getMethod(method);
        targetMethod.invoke(targetClass);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class com.reflection.Cat
hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过修改配置文件，创建一个狗类，调用其中的say方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classPath = com.reflection.Dog
method = say
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;狗类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;
public class Dog {
    public void say () {
        System.out.println(&quot;大狗大狗叫叫叫~~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大狗大狗叫叫叫~~
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射机制原理&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1.反射机制允许程序在程序执行期间借助Reflection API获取任何类的内部信息（包括成员变量，构造器，成员方法），并能够操作对象的属性以及方法（反射在设计模式和底层框架都会用的到&lt;/p&gt;
&lt;p&gt;2.加载完类后，堆中产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构。而这个对象就像是一面镜子，透过这个镜子可以看到类的结构（所以称之为反射）&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;反射机制原理图&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/107.png&quot; alt=&quot;107&quot; /&gt;&lt;/p&gt;
&lt;p&gt;反射（Reflection）的核心来源是 Java 的 Class 对象，这个对象是程序在 Class 类阶段（加载阶段） 通过 &lt;code&gt;ClassLoader&lt;/code&gt; 类加载器，加载后创建的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在底层编译时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类加载器（&lt;code&gt;ClassLoader&lt;/code&gt;）会将字节码文件加载到 JVM 中，并转换为 &lt;strong&gt;Class 类对象&lt;/strong&gt;，其中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字段信息（Field[] fields）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造器信息（Constructor[] cons）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法信息（Method[] ms）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这些信息是 Java 反射的基础&lt;/strong&gt;，通过 &lt;code&gt;Class&lt;/code&gt; 对象，Java 代码可以动态地获取类的详细结构，并在运行时操作类的成员（方法、变量等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对用户而言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 允许开发者使用反射机制操作 Class 对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反射的方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;Class&lt;/code&gt; 对象获取类的信息（字段、方法、构造器）。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Field&lt;/code&gt; 访问类的字段。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Method&lt;/code&gt; 调用类的方法。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Constructor&lt;/code&gt; 创建对象实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;反射的优缺点&lt;/h4&gt;
&lt;p&gt;1.优点：可以动态的创建和使用对象（也是框架的底层核心），使用灵活，没有反射机制，框架就会失去底层支持&lt;/p&gt;
&lt;p&gt;2.使用反射基本是解释执行，对执行速度有影响（和传统方式时间差距很大）&lt;/p&gt;
&lt;p&gt;有一个setAccessible方法可以操作访问安全检查的开关以此来提升反射的效率&lt;/p&gt;
&lt;h3&gt;反射相关的类&lt;/h3&gt;
&lt;h4&gt;Class&lt;/h4&gt;
&lt;p&gt;代表一个类，Class对象表示在某个类加载后在堆中的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(classPath);
//创建Class对象
Object obj = cls.newInstance();
//通过Class对象获取对应实例
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.Class也是类，继承于Object类&lt;/p&gt;
&lt;p&gt;2.Class类对象不是new实例化出来的，而是系统创建的&lt;/p&gt;
&lt;p&gt;3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次&lt;/p&gt;
&lt;p&gt;4.每个类的实例都会记得自己是由哪一个Class实例所生成的&lt;/p&gt;
&lt;p&gt;5.通过Class对象可以完整的得到一个类的完整结构（API调用）&lt;/p&gt;
&lt;p&gt;6.Class对象是存放在堆中的&lt;/p&gt;
&lt;p&gt;7.类的字节码二进制数据，是放在方法区的，称之为类的元数据（包括方法代码，变量名，方法名，访问权限等）&lt;/p&gt;
&lt;h4&gt;Method&lt;/h4&gt;
&lt;p&gt;代表类的方法，Method对象表示某个类的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Method method01 = cls.getMethod(method);
//获取方法对象
method01.invoke(obj);
//通过invoke传入类对象实例调用方法
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Field&lt;/h4&gt;
&lt;p&gt;代表类的成员变量，Field对象表示某个类的成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field nameField = cls.getField(&quot;name&quot;);
//获取成员变量对象
System.out.println(nameField.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Constructor&lt;/h4&gt;
&lt;p&gt;代表类的构造方法，Constructor对象表示某个类的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor constructor1 = cls.getConstructor();
//不带参数的构造器
System.out.println(constructor1);

Constructor constructor2 = cls.getConstructor(String.class);
//带参数的构造器需要传入String类的Class对象
System.out.println(constructor2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以调用构造器对象构造类的对象实例&lt;/p&gt;
&lt;h3&gt;Class常用方法(入门)&lt;/h3&gt;
&lt;h4&gt;forName&lt;/h4&gt;
&lt;p&gt;获取类的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Cat&quot;);
System.out.println(cls);//class com.reflection.Cat
System.out.println(cls.getClass());//class java.lang.Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前一个输出是哪一个类的Class对象，后一个输出类对象&lt;/p&gt;
&lt;h4&gt;getPackage&lt;/h4&gt;
&lt;p&gt;获取类的包名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(cls.getPackage());
//package com.reflection
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getName&lt;/h4&gt;
&lt;p&gt;获取类的全路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(cls.getName());
//com.reflection.Cat
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;newInstance&lt;/h4&gt;
&lt;p&gt;通过类实例创建对应类的实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
Cat cat = (Cat)obj;
cat.hi();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getField&lt;/h4&gt;
&lt;p&gt;获取类的属性（无法获取私有属性）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getField(&quot;name&quot;);
System.out.println(field.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取所有属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getFields();
for(Field field : fields) {
    System.out.println(field.get(obj));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;set&lt;/h4&gt;
&lt;p&gt;设置类属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
Field field = cls.getField(&quot;name&quot;);
field.set(obj, &quot;来福&quot;);
System.out.println(field.get(obj));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取Class对象方式&lt;/h3&gt;
&lt;p&gt;在编程的时候一共可以有六种方式可供程序员使用获取Class对象&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;forName&lt;/p&gt;
&lt;p&gt;使用前提：已知一个类的全类名，且类在类的路径下，可以通过Class的静态方法forName获取（可能会抛出ClassNotFound异常）&lt;/p&gt;
&lt;p&gt;应用场景：多用于配置文件，获取类全路径，加载类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Cat&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;加载阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;类.class&lt;/p&gt;
&lt;p&gt;从类加载器中获取&lt;/p&gt;
&lt;p&gt;使用前提：已知具体的类，通过类的class方法获取，该方式是最为可靠的，程序性能最高&lt;/p&gt;
&lt;p&gt;应用场景：多用于参数传递，比如通过反射得到对应构造器对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Cat.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;运行阶段&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对象.getClass&lt;/p&gt;
&lt;p&gt;使用前提：某一个类的实例已经存在，通过该实例的getClass方法获取Class对象&lt;/p&gt;
&lt;p&gt;应用场景：通过创建好的对象获取Class对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cat cat = new Cat();
Class cls = cat.getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;通过类加载器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;调用类加载器的loadClass方法获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassLoader classLoader = cat.getClass().getClassLoader();
Class&amp;lt;?&amp;gt; cls = classLoader.loadClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;基本数据类型类对象&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;数据类型.class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;Integer&amp;gt; cls = int.class;
System.out.println(cls);//int 这里隐含了自动拆装箱
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;strong&gt;包装型类对象&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;调用包装类的静态属性TYPE获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Integer.TYPE;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;类加载&lt;/h2&gt;
&lt;p&gt;反射机制是Java实现动态语言的关键，也就是通过反射实现动态加载&lt;/p&gt;
&lt;h3&gt;动态加载与静态加载&lt;/h3&gt;
&lt;h4&gt;静态加载&lt;/h4&gt;
&lt;p&gt;编译时加载相关的类，如果没有则报错，依赖性较高&lt;/p&gt;
&lt;h4&gt;动态加载&lt;/h4&gt;
&lt;p&gt;运行时加载需要的类，如果没有用到缺失的类，就不会报错，降低了依赖性&lt;/p&gt;
&lt;h4&gt;代码示例&lt;/h4&gt;
&lt;p&gt;以下是一个动态加载的代码示例：&lt;/p&gt;
&lt;p&gt;例如我有一个Cat类，一个House类，但是实际上只有Cat类是在代码中声明，我们利用静态加载一个Cat 和一个House类，代码不通过编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cat cat = new Cat();
House house = new House();//编译报错，没有House类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们可以通过类加载实现动态加载，只有在运行的时候没有获取到对应的类时候才会发出运行时错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        char key = scanner.next().charAt(0);
        switch (key) {
            case 1:
                Class cls = Class.forName(&quot;com.reflection.Cat&quot;);
                Object obj1 = cls.newInstance();
                break;
            case 2:
                Class cls2 = Class.forName(&quot;com.reflection.House&quot;);
                Object obj2 = cls2.newInstance();
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在输入2的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: com.reflection.House
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类加载的流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/108.png&quot; alt=&quot;108&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;加载阶段（由JVM控制）&lt;/h4&gt;
&lt;p&gt;JVM机将字节码从不同的数据源（class文件、jar包，网络）转化为二进制字节流加载到内存中，并且生成代表该类的java.lang.Class对象&lt;/p&gt;
&lt;h4&gt;连接阶段（由JVM控制）&lt;/h4&gt;
&lt;h5&gt;验证&lt;/h5&gt;
&lt;p&gt;确保Class字节流中的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全（这个阶段是可以手动关闭的）&lt;/p&gt;
&lt;p&gt;在编译运行的时候：使用-Xverify:none参数关闭大部分的类验证措施，以缩短虚拟机类加载的时间&lt;/p&gt;
&lt;h5&gt;准备&lt;/h5&gt;
&lt;p&gt;JVM在该阶段对静态变量，分配内存，并默认初始化（0，null，false等），这些变量所使用的内存都在方法区中进行分配&lt;/p&gt;
&lt;p&gt;以一个类来举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A {
	public int n1 = 10;
	//n1是实例属性，不是静态变量，在准备阶段是不会分配内存的
	public static int n2 = 20;
	//n2是静态变量，分配内存，初始化为0，在后续才会进行赋值
	public static final int n3 = 30;
	//n3是一个常量，分配内存，初始直接进行赋值30
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;解析阶段&lt;/h5&gt;
&lt;p&gt;虚拟机将常量池中的符号引用替换为直接引用的过程&lt;/p&gt;
&lt;h4&gt;初始化（由程序员控制）&lt;/h4&gt;
&lt;p&gt;1.到初始化阶段才开始执行类中定义的Java程序代码，此阶段执行的是&amp;lt;clinit&amp;gt;()方法的过程&lt;/p&gt;
&lt;p&gt;2.&amp;lt;clinit&amp;gt;()方法是由编译器按语句在源代码中出现的顺序，以此自动收集类中所有静态变量的复制动作，和静态代码块中的语句，并进行合并&lt;/p&gt;
&lt;p&gt;3.虚拟机会保证一个类的&amp;lt;clinit&amp;gt;()方法在多线程环境中被正确的加锁，同步，如果多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的&amp;lt;clinit&amp;gt;()方法，其他线程都需要阻塞等待&lt;/p&gt;
&lt;p&gt;正是通过3的线程加锁，才保证了某一个类的对象在堆中只存在一个&lt;/p&gt;
&lt;p&gt;在代码编写的时候：有一个setAccessible（爆破）方法可以操作访问安全检查的开关以此来提升反射的效率&lt;/p&gt;
&lt;h2&gt;获取类信息&lt;/h2&gt;
&lt;h3&gt;相关方法&lt;/h3&gt;
&lt;p&gt;现有一个类Person&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Deprecated
public class Person extends AA implements IL{
    public int pub = 0;
    int def = 0;
    private int pri = 0;

    public Person() {}

    public Person(int pub, int def, int pri) {
        this.pub = pub;
        this.def = def;
        this.pri = pri;
    }

    public void say(){}
    void hi(){}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Class类&lt;/h4&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;获取全类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getName());
//com.reflection.Person
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getSimpleName&lt;/h5&gt;
&lt;p&gt;获取简单类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getSimpleName());//Person
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getFields&lt;/h5&gt;
&lt;p&gt;获取所有public修饰的属性，包含本类以及父类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getFields();
for(Field field : fields) {
    System.out.println(field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public int com.reflection.Person.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredFields&lt;/h5&gt;
&lt;p&gt;获取本类中所有属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field[] fields = cls.getDeclaredFields();
for(Field field : fields) {
    System.out.println(field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public int com.reflection.Person.pub
int com.reflection.Person.def
private int com.reflection.Person.pri
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getMethods&lt;/h5&gt;
&lt;p&gt;获取本类中由public修饰的所有方法，包含本类以及父类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    Method[] methods = cls.getMethods();
    for(Method method : methods) {
        System.out.println(method.getName());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;say
wait
wait
wait
equals
toString
hashCode
getClass
notify
notifyAll
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredMethods&lt;/h5&gt;
&lt;p&gt;获取本类中所有方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
Method[] methods = cls.getDeclaredMethods();
for(Method method : methods) {
    System.out.println(method);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;void com.reflection.Person.hi()
public void com.reflection.Person.say()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getConstructors&lt;/h5&gt;
&lt;p&gt;获取public修饰的构造器，包含本类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
Constructor[] connstructors = cls.getConstructors();
for(Constructor connstructor : connstructors) {
    System.out.println(connstructor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public com.reflection.Person()
public com.reflection.Person(int,int,int)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDeclaredConstructors&lt;/h5&gt;
&lt;p&gt;获取本类所有的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public com.reflection.Person()
public com.reflection.Person(int,int,int)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getPackage&lt;/h5&gt;
&lt;p&gt;以Package的形式返回包信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class cls = Class.forName(&quot;com.reflection.Person&quot;);
System.out.println(cls.getPackage());
//package com.reflection
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getSuperclass&lt;/h5&gt;
&lt;p&gt;以Class的形式返回父类的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    System.out.println(cls.getSuperclass());
    //class com.reflection.AA
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getInterfaces&lt;/h5&gt;
&lt;p&gt;以Class的形式返回接口信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class cls = Class.forName(&quot;com.reflection.Person&quot;);
        Class[] interfaces = cls.getInterfaces();
        for(Class anInterface : interfaces)
        System.out.println(anInterface);
        //interface com.reflection.IL
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getAnnotations&lt;/h5&gt;
&lt;p&gt;以Annotation数组的形式返回注解信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    Class cls = Class.forName(&quot;com.reflection.Person&quot;);
    Annotation[] annotations = cls.getAnnotations();
    for(Annotation annotation : annotations)
    System.out.println(annotation);
    //@java.lang.Deprecated()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Filed类&lt;/h4&gt;
&lt;h5&gt;getModifiers&lt;/h5&gt;
&lt;p&gt;以int形式返回修饰符&lt;/p&gt;
&lt;p&gt;默认修饰符0  ，public 1 ， private 2 ， protected 4 ，static 8 ，final 16 public+static 9（1 + 8）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getField(&quot;pub&quot;);
//注意通过getField只能获取public修饰的属性
System.out.println(field.getModifiers());//1 (public)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getType&lt;/h5&gt;
&lt;p&gt;以Class形式返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Field field = cls.getField(&quot;pub&quot;);
System.out.println(field.getType());//int
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;返回属性名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Field field = cls.getField(&quot;pub&quot;);
System.out.println(field.getName());//pub
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Method类&lt;/h4&gt;
&lt;h5&gt;getModifiers&lt;/h5&gt;
&lt;p&gt;以int形式返回修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getModifiers());//1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getReturnType&lt;/h5&gt;
&lt;p&gt;以Class形式返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getReturnType());//void
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getName&lt;/h5&gt;
&lt;p&gt;返回方法名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
System.out.println(method.getName());//say
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getParameterTypes&lt;/h5&gt;
&lt;p&gt;以Class数组返回参数类型数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
Method method = cls.getMethod(&quot;say&quot;);
Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Constructor类&lt;/h4&gt;
&lt;p&gt;和Method类基本一致，没有getReturnType方法（没有返回值）&lt;/p&gt;
&lt;h2&gt;反射爆破&lt;/h2&gt;
&lt;h3&gt;反射爆破创建实例&lt;/h3&gt;
&lt;p&gt;有以下几个构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Person() {}

public Person(int pub) {
    this.pub = pub;
}

public Person(int pub, int def, int pri) {
    this.pub = pub;
    this.def = def;
    this.pri = pri;
}

private Person(int pub, int def) {
    this.pub = pub;
    this.def = def;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大体分为两种方式&lt;/p&gt;
&lt;p&gt;方式一：调用类中pulic修饰的无参构造器&lt;/p&gt;
&lt;p&gt;方式二：调用类中的指定构造器&lt;/p&gt;
&lt;h4&gt;Constructor类相关方法&lt;/h4&gt;
&lt;h5&gt;setAccessible&lt;/h5&gt;
&lt;p&gt;是Java程序设计者留的后门，可以破解私有构造器的限制&lt;/p&gt;
&lt;p&gt;爆破（暴力破解）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;newInstance&lt;/h5&gt;
&lt;p&gt;调用构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Object obj = constructor.newInstance(10);//通过构造器创建对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Class类相关方法&lt;/h4&gt;
&lt;h5&gt;newInstance&lt;/h5&gt;
&lt;p&gt;调用类中的无参构造器，获取对应类的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object obj = cls.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getConstructor&lt;/h5&gt;
&lt;p&gt;根据参数列表，获取对应的构造器对象（获取public构造器对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getConstructor(int.class);//获取到公有的构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;getDecalaredConstructor&lt;/h5&gt;
&lt;p&gt;根据参数列表，获取对应的构造器对象（获取本类所有的构造器对象）&lt;/p&gt;
&lt;p&gt;用普通的方式无法通过private修饰的构造器创建对象实例，但是通过反射可以实现&lt;/p&gt;
&lt;p&gt;但是后续调用私有构造器需要爆破（暴力破解private）（单独使用newInstance会发生运行错误）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class,int.class);//获取到所有的构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;通过爆破使用私有构造器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class,int.class);//获取到所有的构造器
constructor.setAccessible(true);
Object obj = constructor.newInstance(10, 29);//通过构造器创建对象
System.out.println(obj);//pub 10 def 29 pri 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射爆破操作属性&lt;/h3&gt;
&lt;h4&gt;访问属性的相关方法&lt;/h4&gt;
&lt;h5&gt;获取Field对象&lt;/h5&gt;
&lt;p&gt;Field f = class对象.getDeclaredField(属性名称)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field field = cls.getDeclaredField(&quot;pri&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;爆破&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;field.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;访问&lt;/h5&gt;
&lt;p&gt;设置属性值&lt;/p&gt;
&lt;p&gt;f.set(obj, 值)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field.set(obj, 100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取属性值&lt;/p&gt;
&lt;p&gt;f.get(obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field.get(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是静态属性，则set和get中的obj参数可以写为null&lt;/p&gt;
&lt;h4&gt;private修饰的属性值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class, int.class, int.class);
        //获取到所有的构造器

        Object obj = constructor.newInstance(10, 29, 101);//通过构造器创建对象
        Field field = cls.getDeclaredField(&quot;pri&quot;);
        field.setAccessible(true);
        field.set(obj, 100);
        System.out.println(field.get(obj));//100
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反射爆破操作方法&lt;/h3&gt;
&lt;h4&gt;访问方法相关方法&lt;/h4&gt;
&lt;h5&gt;getDeclaredMethod&lt;/h5&gt;
&lt;p&gt;获取类所有的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Method method = cls.getDeclaredMethod(&quot;hi&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;setAccessible&lt;/h5&gt;
&lt;p&gt;设置方法爆破&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;method.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;invoke&lt;/h5&gt;
&lt;p&gt;传入class类对象实例调用方法&lt;/p&gt;
&lt;p&gt;如果是静态方法传入null即可&lt;/p&gt;
&lt;p&gt;invoke方法参数后是一个可变参数，可供传入参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object returnValue = method.invoke(obj);//静态方法hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在反射中如果有返回值统一返回Object类型的值&lt;/p&gt;
&lt;h4&gt;通过反射调用private方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Class01 {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.Person&quot;);
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(int.class, int.class, int.class);//获取到所有的构造器

        Object obj = constructor.newInstance(10, 29, 101);//通过构造器创建对象
        Method method = cls.getDeclaredMethod(&quot;hi&quot;);
        method.setAccessible(true);
        method.invoke(obj);//静态方法hi
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;课后习题&lt;/h1&gt;
&lt;h2&gt;例题一&lt;/h2&gt;
&lt;p&gt;1.定义PrivateTest类，由私有属性name，属性值为hellokitty&lt;/p&gt;
&lt;p&gt;2.提供getName公共方法&lt;/p&gt;
&lt;p&gt;3.创建PrivateTest类，利用Class类得到私有属性name属性，修改name属性值&lt;/p&gt;
&lt;p&gt;4.使用getName方法打印name属性值&lt;/p&gt;
&lt;h3&gt;题解&lt;/h3&gt;
&lt;p&gt;写出PrivateTest类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.reflection;

public class PrivateTest {
    private String name = &quot;hellokitty&quot;;

    public String getName() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主方法调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test01 {
    public static void main(String[] args) throws Exception{
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;com.reflection.PrivateTest&quot;);
        Object obj = cls.newInstance();

        Field name = cls.getDeclaredField(&quot;name&quot;);
        name.setAccessible(true);
        name.set(obj, &quot;New name&quot;);

        Method getName = cls.getMethod(&quot;getName&quot;);
        Object invoke = getName.invoke(obj);
        String target = (String) invoke;

        System.out.println(target);//New name
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题二&lt;/h2&gt;
&lt;p&gt;1.利用Class类的forName方法得到File类的class对象&lt;/p&gt;
&lt;p&gt;2.在控制台打印出File类的所有构造器&lt;/p&gt;
&lt;p&gt;3.通过newInstance的方法创建File对象，并创建 E:\mynew.txt 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileTest{
    public static void main(String[] args) throws Exception{
        Class&amp;lt;?&amp;gt; cls = Class.forName(&quot;java.io.File&quot;);
        Constructor&amp;lt;?&amp;gt;[] constructors = cls.getDeclaredConstructors();
        for(Constructor&amp;lt;?&amp;gt; constructor : constructors) {
            System.out.println(constructor);
        }
        Constructor&amp;lt;?&amp;gt; constructor = cls.getDeclaredConstructor(String.class);
        Object obj = constructor.newInstance(&quot;e:\\JavaFile\\mynew.txt&quot;);
        Method method = cls.getMethod(&quot;createNewFile&quot;);
        method.invoke(obj);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0io%E6%B5%81/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0io%E6%B5%81/</guid><description>IO流</description><pubDate>Sun, 06 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;p&gt;IO流的部分我打算用两天的时间完成学习，再用一天来结束class以及反射的内容，Java的基础知识点就告一段落。&lt;/p&gt;
&lt;h2&gt;文件基础知识&lt;/h2&gt;
&lt;p&gt;文件在程序中是以流的形式来操作的&lt;/p&gt;
&lt;p&gt;Java程序（内存）——输出流——&amp;gt;文件&lt;/p&gt;
&lt;p&gt;文件——输入流——&amp;gt;Java程序（内存）&lt;/p&gt;
&lt;p&gt;流：数据在数据源（文件）和程序（内存）之间经历的路径&lt;/p&gt;
&lt;p&gt;输入流：数据从文件到程序的路径&lt;/p&gt;
&lt;p&gt;输出流：数据从程序到文件的路径&lt;/p&gt;
&lt;h2&gt;常用的文件操作&lt;/h2&gt;
&lt;h3&gt;创建文件&lt;/h3&gt;
&lt;p&gt;创建文件对象相关方法，注意只有调用createNewFile才会创建文件&lt;/p&gt;
&lt;p&gt;方式一：通过路径创建文件对象，并创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
    public void create01() {
        String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
        File file = new File(filePath);
        try {
            file.createNewFile();
            System.out.println(&quot;创建成功&quot;);
        } catch (IOException e) {
            System.out.println(&quot;创建文件失败&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式二：通过父目录文件对象+文件名创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void create02() {
    String filePath = &quot;e:\\JavaFile&quot;;
    File file1 = new File(filePath);
    String fileName = &quot;2.txt&quot;;
    File file2 = new File(file1, fileName);
    try {
        file2.createNewFile();
        System.out.println(&quot;创建成功&quot;);
    } catch (IOException e) {
        System.out.println(&quot;创建文件失败&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式三：通过父目录字符串+文件名创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void create03() {
    String filePath = &quot;e:\\JavaFile&quot;;
    String fileName = &quot;3.txt&quot;;
    File file2 = new File(filePath, fileName);
    try {
        file2.createNewFile();
        System.out.println(&quot;创建成功&quot;);
    } catch (IOException e) {
        System.out.println(&quot;创建文件失败&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件都创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/97.png&quot; alt=&quot;97&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;获取文件名称&lt;/h3&gt;
&lt;p&gt;getName&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getName());//1.txt
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取文件绝对路径&lt;/h3&gt;
&lt;p&gt;getAbsolutePath&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getAbsolutePath());//e:\1.txt
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取父级目录&lt;/h3&gt;
&lt;p&gt;getParent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\1.txt&quot;);
    System.out.println(file.getParent());//e:\
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取文件大小&lt;/h3&gt;
&lt;p&gt;length 字节&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Test
    public void info() {
        File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);//6 
        //文件里是 你好 中文字符在UTF-8占三个字节
        System.out.println(file.length());//6 
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测文件是否存在&lt;/h3&gt;
&lt;p&gt;exists&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.exists());//true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测是不是文件&lt;/h3&gt;
&lt;p&gt;isFile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.isFile());//true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测是不是目录&lt;/h3&gt;
&lt;p&gt;isDirectory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void info() {
    File file = new File(&quot;e:\\JavaFile\\1.txt&quot;);
    System.out.println(file.isFile());//false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建目录&lt;/h3&gt;
&lt;h4&gt;创建一级目录&lt;/h4&gt;
&lt;p&gt;mkdir&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void mkdir() {
    String filePath = &quot;e:\\JavaFile\\New&quot;;
    File file = new File(filePath);
    if (!file.exists()) {
        file.mkdir();
        System.out.println(filePath + &quot; 目录创建&quot;);
    } else {
        System.out.println(&quot;目录已存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;创建多级目录&lt;/h4&gt;
&lt;p&gt;mkdirs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void mkdirs() {
    String filePath = &quot;e:\\JavaFile\\New\\another\\other&quot;;
    File file = new File(filePath);
    if (!file.exists()) {
        file.mkdirs();
        System.out.println(filePath + &quot; 目录创建&quot;);
    } else {
        System.out.println(&quot;目录已存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除空目录或文件&lt;/h3&gt;
&lt;p&gt;delete&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void delete() {
    String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
        System.out.println(filePath + &quot;被删除&quot;);//1.txt被删除
    } else {
        System.out.println(&quot;文件不存在&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java IO流原理&lt;/h2&gt;
&lt;p&gt;1.I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输，如读写文件，网络通讯等&lt;/p&gt;
&lt;p&gt;2.Java程序中，对于数据的输入/输出以 流 ”stream“ 的方式进行。&lt;/p&gt;
&lt;p&gt;3.java.io包下提供了各种“流”类和接口，以获取不同种类的数据，并通过方法输入或者输出数据&lt;/p&gt;
&lt;p&gt;4.输入input：读取外部数据（磁盘，光盘的设备的数据）到程序（内存）中&lt;/p&gt;
&lt;p&gt;5.输出output：将程序（内存）数据输出到磁盘，光盘等存储设备中&lt;/p&gt;
&lt;h3&gt;流的分类&lt;/h3&gt;
&lt;p&gt;按照操作数据单位不同分为：字节流（8bit），字符流（按字符）&lt;/p&gt;
&lt;p&gt;按照数据流向分为：输入，输出流&lt;/p&gt;
&lt;p&gt;按照流的角色不同分为：节点流，处理流，包装流&lt;/p&gt;
&lt;h3&gt;四个抽象基类&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;抽象基类&lt;/th&gt;
&lt;th&gt;字节流&lt;/th&gt;
&lt;th&gt;字符流&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;输入流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;输出流&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1.Java的IO流设计40多个类，实际上非常规则，都是从如上的4个抽象基类派生的&lt;/p&gt;
&lt;p&gt;2.由这四个派生出来的子类名称都是以其父类民作为子类名后缀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/98.png&quot; alt=&quot;98&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/99.png&quot; alt=&quot;99&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出流&lt;/h2&gt;
&lt;h3&gt;FileInputStream&lt;/h3&gt;
&lt;p&gt;文件输入流&lt;/p&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;p&gt;传入文件对象 File&lt;/p&gt;
&lt;p&gt;传入文件描述符&lt;/p&gt;
&lt;p&gt;传入文件路径字符串 String&lt;/p&gt;
&lt;h4&gt;流循环读取单个字节&lt;/h4&gt;
&lt;p&gt;当文件字节读取完毕时返回-1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        int readData = 0;
        InputStream inputstream = null;
        try {
            inputstream = new FileInputStream(filePath);//创建文件对象流

            while ((readData = inputstream.read()) != -1) {
                System.out.print((char)readData);
            }
        } catch (IOException e) {
            System.out.println(&quot;没有找到文件...&quot;);
        } finally {
            try {
                inputstream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用字节流数组读取&lt;/h4&gt;
&lt;p&gt;在read中添加一个byte数组参数，如果读取正常返回一个读取到的字节数&lt;/p&gt;
&lt;p&gt;再通过返回的字节数根据buf字节数组用String构造一个字符串（从0到每次读取到的字节数）输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Stream {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        int readLen = 0;
        byte[] buf = new byte[8];
        InputStream inputstream = null;
        try {
            inputstream = new FileInputStream(filePath);//创建文件对象流
            while ((readLen = (inputstream.read(buf)) )!= -1) {
                System.out.println(new String(buf, 0, readLen));
            }
         //Hello Wo
		//rld!!
        } catch (IOException e) {
            System.out.println(&quot;没有找到文件...&quot;);
        } finally {
            try {
                inputstream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FileOutputStream&lt;/h3&gt;
&lt;p&gt;文件字节输出流&lt;/p&gt;
&lt;h4&gt;写入单个字符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class OUTSTREAM {
    public static void main(String[] args) {
        File file = new File(&quot;e:\\JavaFile\\4.txt&quot;);
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream(file);
            //如果没有文件会创建文件
            fos.write(&apos;A&apos;);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;写入一个字节数组&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class OUTSTREAM {
    public static void main(String[] args) {
        File file = new File(&quot;e:\\JavaFile\\4.txt&quot;);
        FileOutputStream fos = null;
        String target = &quot;Hello World!&quot;;
        byte[] buffer = target.getBytes();
        //通过getBytes得到字节数组
        try {
            fos = new FileOutputStream(file);
            fos.write(buffer, 0, buffer.length);
            //后两个参数可选左闭右包，无则将调用如上形式
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;追加内容&lt;/h4&gt;
&lt;p&gt;以上是将目标文件直接进行内容更新，如果要添加内容则需要在构造器里添加第二个boolean参数（设置为true）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fos = new FileOutputStream(file, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;文件拷贝&lt;/h4&gt;
&lt;p&gt;运用文件输入流和文件输出流来进行文件的拷贝&lt;/p&gt;
&lt;h5&gt;单个字节流&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\3.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int target;
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((target = fis.read()) != -1) {
                fos.write(target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;字节流数组&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\3.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int bufLength = 0;
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((bufLength = fis.read(buffer)) != -1) {
                for (int i = 0; i &amp;lt; bufLength; i++) {
                    fos.write(buffer[i]);
                }
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\1.jpg&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\4.jpg&quot;;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        int bufLength = 0;
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(inputPath);
            fos = new FileOutputStream(outputPath);
            while((bufLength = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bufLength);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                fis.close();
                fos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;字符输入输出流&lt;/h2&gt;
&lt;p&gt;相比于文件字节流而言，当读取到由多个字节组成的字符（例如中文）会将多个字节传为字符读出&lt;/p&gt;
&lt;h3&gt;FileReader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/101.png&quot; alt=&quot;101&quot; /&gt;&lt;/p&gt;
&lt;p&gt;相关方法&lt;/p&gt;
&lt;p&gt;构造方法:传入文件对象或者文件路径字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new FileReader(File\String);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;read:读取单个字符，返回字符如果读取到-1代表到达文件末尾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileReader01 {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\2.txt&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileReader filereader = null;
        int target;
        try {
            filereader = new FileReader(inputPath);
            while((target = filereader.read()) != -1) {
                System.out.print((char)target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filereader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;read（char[]）:读取多个字符到字符数组，返回读到的字符数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileReader01 {
    public static void main(String[] args) {
        String inputPath = &quot;e:\\JavaFile\\2.txt&quot;;
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileReader filereader = null;
        char[] buffer = new char[4];
        int length;
        try {
            filereader = new FileReader(inputPath);
            while((length = filereader.read(buffer)) != -1) {
                String target = new String(buffer, 0, length);
                System.out.print(target);
            }
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filereader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;FileWriter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/100.png&quot; alt=&quot;100&quot; /&gt;&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;write(int):写入单个字符&lt;/p&gt;
&lt;p&gt;write(char[ ]):写入指定数组&lt;/p&gt;
&lt;p&gt;write(char[], off, len):写入数组指定部分&lt;/p&gt;
&lt;p&gt;write(string):写入整个字符串&lt;/p&gt;
&lt;p&gt;write(string, off, len):写入字符串指定部分&lt;/p&gt;
&lt;p&gt;注意：当FileWriter使用后，必须要使用close关闭或者flush刷新后才可以写入完成&lt;/p&gt;
&lt;p&gt;以下是一个代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileWriter01 {
    public static void main(String[] args) {
        String outputPath = &quot;e:\\JavaFile\\New\\1.txt&quot;;
        FileWriter filewriter = null;
        char[] buffer = &quot;风雨之后，遇见彩虹&quot;.toCharArray();
        try {
            filewriter = new FileWriter(outputPath);
            filewriter.write(buffer, 0, buffer.length);
            filewriter.flush();//在完成写之后记得刷入
        } catch (IOException e) {
            System.out.println(&quot;发生异常&quot;);
        } finally {
            try {
                filewriter.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;节点流和处理流&lt;/h2&gt;
&lt;h3&gt;节点流&lt;/h3&gt;
&lt;p&gt;节点流可以从一个特定的数据源读写数据，例如FileReader，FileWriter&lt;/p&gt;
&lt;h3&gt;处理流&lt;/h3&gt;
&lt;p&gt;处理流（包装流）是连接已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader，BufferedWriter，更加灵活&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/102.png&quot; alt=&quot;102&quot; /&gt;&lt;/p&gt;
&lt;p&gt;处理流具体功能&lt;/p&gt;
&lt;p&gt;1.性能的提高：主要以增加缓冲的方式来提高输入输出的效率&lt;/p&gt;
&lt;p&gt;2.操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加的灵活&lt;/p&gt;
&lt;h3&gt;区别与联系&lt;/h3&gt;
&lt;p&gt;1.节点流是底层流/低级流，直接和数据源相接&lt;/p&gt;
&lt;p&gt;2.处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出&lt;/p&gt;
&lt;p&gt;3.处理流对节点流进行了包装，使用了修饰器设计模式，不会直接与数据源相连接&lt;/p&gt;
&lt;h3&gt;修饰器设计模式示例&lt;/h3&gt;
&lt;p&gt;我们来模拟一下处理流封装节点流，有点类似于之前提到的代理模式&lt;/p&gt;
&lt;p&gt;但是还是有些区别：装饰器关注于动态添加功能，代理关注于控制访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        BufferedReader_ bufferedReader = new BufferedReader_(new FileReader_());
        System.out.println(&quot;拓展的Read方法&quot;);
        bufferedReader.readFiles(3);
    }
}

class BufferedReader_ extends Reader_ {
    private Reader_ reader_;

    public BufferedReader_(Reader_ reader_){
        this.reader_ = reader_;
    }

  	//将原本的reader方法封装在修饰器中
    public void readFile() {
        reader_.readFile();
    }  
  
    //在BufferedReader_中可以添加FileReader_的方法（拓展修饰）
    public void readFiles(int num) {
        for (int i = 0; i &amp;lt; num; i++) {
            reader_.readFile();
        }
    }
}

abstract class Reader_ {
    public void readFile(){}
    public void readString(){}
}

class FileReader_ extends Reader_{
    public void readFile() {
        System.out.println(&quot;对文件进行读取...&quot;);
    }
}

class StringReader_ extends Reader_{
    public void readString() {
        System.out.println(&quot;对字符串进行读取...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这样的方式我们可以通过构造的处理流来调用更具有便捷性的方法来操作节点流。&lt;/p&gt;
&lt;h3&gt;字符处理流&lt;/h3&gt;
&lt;h4&gt;BufferedReader&lt;/h4&gt;
&lt;p&gt;在其中有属性Reader，可以封装一个节点流（可以是任意的Reader子类），还有一个char数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedReader extends Reader {

    private Reader in;

    private char cb[];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个代码示例，我们将文件的输入字符流放在了创建的读入字符处理流里，通过这个处理流调用读取下一行方法读取内容，并且输出&lt;/p&gt;
&lt;p&gt;readLine方法，返回字符串类型，如果读完就返回null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedReader01 {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileReader filereader = null;
        BufferedReader bufferedreader = null;

        try {
            filereader = new FileReader(filePath);
            bufferedreader = new BufferedReader(filereader);
            String line;
            while ((line = bufferedreader.readLine()) != null) {
                System.out.println(line);
            }
            System.out.println(line);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferedreader.close();//关闭外层流即可
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;你好！！Hello World!!
我来自于西安
你好
null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在释放资源的时候只需要关闭外层流即可，在调用的时候会将Reader的in释放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void close() throws IOException {
    synchronized (lock) {
        if (in == null)
            return;
        try {
            in.close();
        } finally {
            in = null;
            cb = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;BufferedWriter&lt;/h4&gt;
&lt;p&gt;在其中有属性Writer，可以封装一个节点流（可以是任意的Writer子类），还有一个char数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedWriter extends Writer {

    private Writer out;

    private char cb[];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用处理流写入内容&lt;/p&gt;
&lt;p&gt;可以使用newLine插入换行符（根据操作系统对应的换行符）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BufferedWriter01 {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileWriter filewriter = null;
        BufferedWriter bufferwriter = null;
        try {
            filewriter = new FileWriter(filePath, true);
            //在节点流设置追加模式
            bufferwriter = new BufferedWriter(filewriter);
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.write(&quot;处理流写入&quot;);
            bufferwriter.newLine();//插入一个换行符
            bufferwriter.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferwriter.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;处理流字符文件拷贝案例（不可以拷贝视频，图片，音频）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class BufferedWriter01 {
    public static void main(String[] args) {
        String targetFilePath = &quot;e:\\JavaFile\\target.txt&quot;;
        FileWriter filewriter = null;
        BufferedWriter bufferwriter = null;

        String srcFilePath = &quot;e:\\JavaFile\\src.txt&quot;;
        FileReader filereader = null;
        BufferedReader bufferreader = null;
        try {
            filewriter = new FileWriter(targetFilePath, true);
            bufferwriter = new BufferedWriter(filewriter);
            filereader = new FileReader(srcFilePath);
            bufferreader = new BufferedReader(filereader);
            String line;
            while ((line = bufferreader.readLine()) != null) {
                bufferwriter.write(line);
                bufferwriter.newLine();
            }
            bufferwriter.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bufferwriter.close();
                bufferreader.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字节处理流&lt;/h3&gt;
&lt;h4&gt;BufferedInputStream&lt;/h4&gt;
&lt;h4&gt;BufferedOutputStream&lt;/h4&gt;
&lt;p&gt;通过拷贝案例说明使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

import java.io.*;

public class BufferedWriter01 {
    public static void main(String[] args) {
        String targetFilePath = &quot;e:\\JavaFile\\2.jpg&quot;;
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;

        String srcFilePath = &quot;e:\\JavaFile\\1.jpg&quot;;
        FileInputStream fis = null;
        BufferedInputStream bis = null;
        try {
            fos = new FileOutputStream(targetFilePath);
            fis = new FileInputStream(srcFilePath);
            bos = new BufferedOutputStream(fos);
            bis = new BufferedInputStream(fis);
            byte[] buffer = new byte[1024];
            int length;
            while((length = bis.read(buffer)) != -1) {
                bos.write(buffer, 0 , length);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                bos.close();
                bis.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对象处理流&lt;/h2&gt;
&lt;p&gt;在实际开发中我们可能会需要保存对象，和从文件中恢复对象（要求保存数据类型）这个时候我们就会需要到 对象处理流（专门用于处理对象）&lt;/p&gt;
&lt;h3&gt;序列化和反序列化&lt;/h3&gt;
&lt;p&gt;1.序列化就是在保存数据的时候，保存数据的值和数据类型&lt;/p&gt;
&lt;p&gt;2.反序列化就是在恢复数据时，恢复数据的值和数据类型&lt;/p&gt;
&lt;p&gt;3.需要让某个对象支持序列化机制，我们就必须让其类是可序列化的，类需要实现Serializable接口或者Externalizable接口（推荐使用第一个标记接口，没有方法）（后一个需要实现方法）&lt;/p&gt;
&lt;h3&gt;对象输入输出流&lt;/h3&gt;
&lt;h4&gt;ObjectOutputStream&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实际案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要保存int型的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = 100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存一个Dog类型的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dog dog = new Dog(&quot;来福&quot;, 18);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class ObjectClass {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\data.dat&quot;;
        ObjectOutputStream oos = null;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(filePath);
            oos = new ObjectOutputStream(fos);
            oos.write(100);//保存整形100
            oos.writeObject(new Dog(&quot;来福&quot;, 18));
            //保存狗类示例对象
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                oos.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Dog implements Serializable {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ObjectInputStream&lt;/h4&gt;
&lt;p&gt;接下来我们来从文件中恢复对象（反序列化）&lt;/p&gt;
&lt;p&gt;在回复对象的Java文件下应该也有类的定义，要求类的定义完全相同，因为这里因为在同一个包下，可以不用再打一次（或者建议把Dog单独写成一个共有的类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ObjectClassRead {
    public static void main(String[] args) {
        String filePath = &quot;e:\\JavaFile\\data.dat&quot;;
        ObjectInputStream ois = null;
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(filePath);
            ois = new ObjectInputStream(fis);
            int i = ois.read();
            Object obj = ois.readObject();//运行类型是Dog
            System.out.println(i);
            System.out.println(obj);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                ois.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100
来福 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;对象处理流的细节&lt;/h3&gt;
&lt;p&gt;1.读写顺序要求一致（例如前一道题目先传入int再传入Dog，读的时候先int再Dog）&lt;/p&gt;
&lt;p&gt;2.要求实现序列化或者反序列化对象（实现Serializable接口）&lt;/p&gt;
&lt;p&gt;3.序列化的类中建议添加Serial Version UID 以提高版本的兼容性（修改类的时候会认为是原来的升级版本，而非全新的类）&lt;/p&gt;
&lt;p&gt;4.序列化对象的时候，默认将里面的所有属性都进行序列化，但除了static和transient关键字修饰的成员&lt;/p&gt;
&lt;p&gt;5.序列化对象时，要求对象属性的类型也都实现了序列化接口&lt;/p&gt;
&lt;p&gt;6.序列化具备可继承性，即某类实现了序列化，则它的子类也默认实现了序列化&lt;/p&gt;
&lt;h2&gt;标准输入输出流&lt;/h2&gt;
&lt;h3&gt;System.in 标准输入&lt;/h3&gt;
&lt;p&gt;默认设备为键盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static InputStream in = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在使用Scanner的时候传入的就是我们的标准输入流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Scanner scanner = new Scanner(System.in);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译类型为InputStream，运行时类型为BufferedInputStream&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class InputAndOutput {
    public static void main(String[] args) {
        System.out.println(System.in.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class java.io.BufferedInputStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;System.out 标准输出&lt;/h3&gt;
&lt;p&gt;默认设备为显示器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static PrintStream out = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在用sout打印的时候，用的就是这个输出流到终端&lt;/p&gt;
&lt;p&gt;编译类型和运行时类型为PrintStream&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class InputAndOutput {
    public static void main(String[] args) {
        System.out.println(System.out.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class java.io.PrintStream
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;转换流&lt;/h2&gt;
&lt;h3&gt;问题引出&lt;/h3&gt;
&lt;p&gt;我们在读取文件的时候使用的是UTF-8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
        String s = bufferedReader.readLine();
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在读取非UTF-8的时候，可能就会读出乱码&lt;/p&gt;
&lt;p&gt;这个时候我们就需要运用转换流将字节流指定格式转为字符流即可解决问题&lt;/p&gt;
&lt;h3&gt;InputStreamReader&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/103.png&quot; alt=&quot;103&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Reader的子类，可以将InputStream（字节流）包装成为Reader（字符流）&lt;/p&gt;
&lt;p&gt;其中有一个非常重要的构造方法（InputStream,Charset）后一个参数指定编码格式&lt;/p&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        FileInputStream fis = new FileInputStream(filePath);//获取文件字节流
        InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);//将字节流指定编码转为字符流
        BufferedReader bufferedReader = new BufferedReader(isr);//将字符流放入字符处理流
        String s = bufferedReader.readLine();
        System.out.println(s);
        bufferedReader.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;OutputStreamWriter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/104.png&quot; alt=&quot;104&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Writer的子类，可以将OutputStream（字节流）包装成为Writer（字符流）&lt;/p&gt;
&lt;p&gt;也有一个构造器（OutputStream,Charset）后一个参数指定编码格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class transformation {
    public static void main(String[] args) throws Exception {
        String filePath = &quot;e:\\JavaFile\\2.txt&quot;;
        BufferedWriter bufferwrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath), &quot;UTF-8&quot;));
        bufferwrite.write(&quot;你好！！&quot;);
        bufferwrite.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;打印流&lt;/h2&gt;
&lt;h3&gt;PrintStream&lt;/h3&gt;
&lt;p&gt;打印字节流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/105.png&quot; alt=&quot;105&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) {
        PrintStream out = System.out;
        out.print(&quot;你好&quot;);//运用打印输出流可以输出到显示器
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print调用了write，也可以直接调用write方法进行打印&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void print(String s) {
    if (s == null) {
        s = &quot;null&quot;;
    }
    write(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以调用System.setOut来设置System.out打印输出流的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) throws IOException {
        System.setOut(new PrintStream(&quot;e:\\JavaFile\\1.txt&quot;));
        PrintStream out = System.out;
        out.write(&quot;你好&quot;.getBytes());
        out.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;PrintWriter&lt;/h3&gt;
&lt;p&gt;打印字符流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/106.png&quot; alt=&quot;106&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PrintStream_ {
    public static void main(String[] args) throws IOException {
        PrintWriter printWriter = new PrintWriter(System.out);
        printWriter.print(&quot;hello&quot;);
        printWriter.close();//需要用close关闭后刷入
    }

    @Test
    public void test() throws IOException {
        String filePath = &quot;e:\\JavaFile\\1.txt&quot;;
        PrintWriter printWriter = new PrintWriter(new FileWriter(filePath));
        printWriter.print(&quot;hello&quot;);
        printWriter.close();//需要用close关闭后刷入
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Properties&lt;/h2&gt;
&lt;p&gt;在讲集合的时候曾提到过&lt;/p&gt;
&lt;p&gt;1.专门用于读写配置文件的集合类，格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;键=值
键=值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.注意键值对不需要有空格，值不需要用引号括起来，默认类型是String&lt;/p&gt;
&lt;h3&gt;常见方法&lt;/h3&gt;
&lt;h4&gt;load&lt;/h4&gt;
&lt;p&gt;加载配置文件的键值对到Properties对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
Properties properties = new Properties();
properties.load(new FileReader(filePath));//加载文件到对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;list&lt;/h4&gt;
&lt;p&gt;将数据显示到指定设备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;properties.list(System.out);//将键值对打印在控制台
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;user=root
pwd=12345
ip=127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;getProperty(key)&lt;/h4&gt;
&lt;p&gt;根据键获取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String user = properties.getProperty(&quot;user&quot;);
String pwd = properties.getProperty(&quot;pwd&quot;);
System.out.println(user + &quot; &quot; + pwd);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;setProperty(key)&lt;/h4&gt;
&lt;p&gt;根据键值设置到Properties对象&lt;/p&gt;
&lt;h4&gt;store&lt;/h4&gt;
&lt;p&gt;将Properties的键值对存储到配置文件中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\another.properties&quot;;
        Properties properties = new Properties();
        properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);
        properties.setProperty(&quot;user&quot;, &quot;tom&quot;);
        properties.setProperty(&quot;pwd&quot;, &quot;123456&quot;);
        properties.store(new FileOutputStream(filePath), null);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;有一个配置文件mysql.properties如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip = 127.0.0.1
user = root
pwd = 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;传统方式实现&lt;/h4&gt;
&lt;p&gt;我们需要使用文件IO进行读取ip，user，pwd比较复杂&lt;/p&gt;
&lt;p&gt;通过处理流读取每一行字符串数据，再通过字符串拆分处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), &quot;UTF-8&quot;));
        String line;
        while ((line = br.readLine()) != null) {
            String[] targerArr = line.split(&quot;=&quot;);
            System.out.println(targerArr[0] + &quot; 内容是 &quot; + targerArr[1]);
        }

        br.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Properties类实现&lt;/h4&gt;
&lt;p&gt;我们可以使用Properties类方便实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPIP {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\mysql.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileReader(filePath));//加载配置文件到对象
        properties.list(System.out);//将键值对打印在控制台
        String user = properties.getProperty(&quot;user&quot;);
        String pwd = properties.getProperty(&quot;pwd&quot;);
        System.out.println(user + &quot; &quot; + pwd);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;IO章节作业&lt;/h1&gt;
&lt;h2&gt;例题一：&lt;/h2&gt;
&lt;p&gt;1.判断e盘下是否有文件夹mytemp，没有则创建mytemp&lt;/p&gt;
&lt;p&gt;2.再mytemp目录下创建文件hello.txt&lt;/p&gt;
&lt;p&gt;3.如果hello.txt存在，就提示已存在，不再重复创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HomeWork01 {
    public static void main(String[] args) {
        File directory = new File(&quot;e:\\mytemp&quot;);
        File file = new File(directory, &quot;hello.txt&quot;);

        if (directory.isDirectory()) {
            System.out.println(&quot;已存在该目录&quot;);
        } else {
            if (directory.mkdir()) {
                System.out.println(&quot;创建成功&quot;);
            } else {
                System.out.println(&quot;创建失败&quot;);
            }
        }

        if (file.exists()) {
            System.out.println(&quot;已存在该文件&quot;);
        } else {
            try {
                if (file.createNewFile()) {
                    System.out.println(&quot;创建成功&quot;);
                } else {
                    System.out.println(&quot;创建失败&quot;);
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题二：&lt;/h2&gt;
&lt;p&gt;用BufferedReader读取一个文本文件，为每行加上行号，再将内容输出到屏幕上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework02 {
    public static void main(String[] args) throws IOException {
        String filePath = &quot;e:\\JavaFile\\src.txt&quot;;
        BufferedReader br = new BufferedReader(new FileReader(filePath));
        String line;
        int count = 1;
        while((line = br.readLine()) != null) {
            System.out.print(count++ + &quot; &quot; + line + &quot;\n&quot;);
        }
        br.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 这是一个
2 处理流拷贝的
3 测试案例
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;例题三：&lt;/h2&gt;
&lt;p&gt;1.编写一个dog.properties配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name = tom
age = 5
color = red
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编写Dog（name，age，color）类，创建一个对象，读取dog配置文件中的内容完成初始化，输出&lt;/p&gt;
&lt;p&gt;3.将创建的Dog对象序列化输出到dog.txt文件&lt;/p&gt;
&lt;p&gt;同理我们也可以将文件反序列化，读出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.stander;

import java.io.*;
import java.util.Properties;


public class IPIP {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String filePath = &quot;e:\\JavaFile\\dog.properties&quot;;
        Properties properties = new Properties();
        properties.load(new FileInputStream(filePath));
        String name = properties.getProperty(&quot;name&quot;);
        String age = properties.getProperty(&quot;age&quot;);
        String color = properties.getProperty(&quot;color&quot;);
        Dog dog = new Dog(name, age, color);
        System.out.println(dog);

        String savePath = &quot;e:\\JavaFile\\save.dat&quot;;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(savePath));
        oos.writeObject(dog);

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(savePath));
        Dog another = (Dog) ois.readObject();
        System.out.println(another);
    }
}

class Dog implements Serializable {
    String name;
    String age;
    String color;

    public Dog(String name, String age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return name + &quot; &quot; + age + &quot; &quot; + color;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>多线程基础，较为简陋，后续添加内容</description><pubDate>Fri, 04 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;p&gt;在韩顺平老师的Java课程中会结合一个坦克大战的实战项目，我急功近利，就不写坦克大战的编写了，只学Java中最核心的几个知识点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java绘图坐标体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;p&gt;在Java中坐标原点位于左上角，以像素为单位，x坐标代表距离竖坐标向右x个像素，而y代表位于横坐标的下y个像素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java事件处理机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java事件处理采取的是&quot;委派事件模型&quot;，当事件发生的时候，产生事件的对象，会把此信息传递给事件的监听者进行处理，事件在代码中体现为一个事件对象。&lt;/p&gt;
&lt;p&gt;事件源：是一个产生事件的对象，比如按钮，窗口等&lt;/p&gt;
&lt;p&gt;事件：事件就是承载事件源状态改变时的对象，比如说键盘事件，鼠标事件，窗口事件等等，会生成一个事件对象，保存当前事件的很多信息。&lt;/p&gt;
&lt;h2&gt;多线程基础&lt;/h2&gt;
&lt;p&gt;单线程：同一个时刻只允许执行一个线程&lt;/p&gt;
&lt;p&gt;多线程：同一个时刻可以执行多个线程，例如QQ打开多个聊天窗口&lt;/p&gt;
&lt;p&gt;并发：同一个时刻，多个任务交替执行，给人以同时进行的错觉（单线程多任务）&lt;/p&gt;
&lt;p&gt;并行：同一个时刻，多个任务同时进行（多核CPU可以支持并行）&lt;/p&gt;
&lt;p&gt;可通过Java写一个返回可用CPU数量的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        int cupNums = runtime.availableProcessors();
        System.out.println(cupNums);//16
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程的基本使用&lt;/h2&gt;
&lt;p&gt;在Java中线程有两种使用方式&lt;/p&gt;
&lt;p&gt;继承关系，其中Thread类实现了Runnable接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/94.png&quot; alt=&quot;94&quot; /&gt;&lt;/p&gt;
&lt;p&gt;1.继承Thread类，重写run方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//1.当一个类继承了Thread类，该类就可以被当作线程使用
//2.一般我们会重写run方法，写上自己的业务代码
//3.run Thread 类实现了 Runnable 接口的run方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.实现Runnable接口，重写run方法&lt;/p&gt;
&lt;p&gt;我们先用thread实现run&lt;/p&gt;
&lt;h3&gt;继承Thread&lt;/h3&gt;
&lt;p&gt;以下是一个代码示例，启动一个猫叫的线程，输出5次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Cat cat = new Cat();//对于一个继承了Thread类的类
        cat.start();//我们可以把它当作一个线程来启动
    }
}

class Cat extends Thread {
    private int times = 0;

    @Override
    public void run() {
        while (times &amp;lt; 5) {
            System.out.println(&quot;我是猫猫&quot;);
            times++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;我是猫猫 第0次 线程名 Thread-0
我是猫猫 第1次 线程名 Thread-0
我是猫猫 第2次 线程名 Thread-0
我是猫猫 第3次 线程名 Thread-0
我是猫猫 第4次 线程名 Thread-0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到以上的代码中我们重写了Cat的run方法，但是在cat的实例中我们调用的是start方法，实际运行的也是run方法，这就涉及到了线程启用的机制&lt;/p&gt;
&lt;h3&gt;实现Runnable&lt;/h3&gt;
&lt;p&gt;1.因为Java是单继承的，我们有的时候仅仅依靠继承Thread类，是没有办法将一个子类再去继承Thread来实现多线程&lt;/p&gt;
&lt;p&gt;2.Java的设计者提供了另外的一个方式创建线程，就是通过Runnable接口来创建线程&lt;/p&gt;
&lt;p&gt;Runnable中没有start方法，而且不能够使用run来启动线程（因为直接调用run方法是阻塞的），我们需要创建线程对象将实现了Runnable接口的对象放入，再通过线程的start方法启用线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hi {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Thread thread = new Thread(dog);
        thread.start();
    }
}

class Dog implements Runnable {
    @Override
    public void run () {
        while(true) {
            System.out.println(&quot;大狗大狗叫叫叫~&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的底层使用了一个名为代理模式(静态代理)的设计模式&lt;/p&gt;
&lt;p&gt;模拟实现Runnable接口开发线程的机制（没有实现start0的多线程）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ThreadProxy implements Runnable {
    //Thread将Proxy当作一个线程类
    private Runnable target = null;

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

    public ThreadProxy(Runnable target) {
        this.target = target;
    }

    public void start() {
        start0();
    }

    public void start0(){//真正实现多线程的方法
        run();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们有一个继承了父类的子类，我们就可以把这个子类实现Runnable接口，再去重写一个run方法（而通过动态绑定机制我们就可以调用run方法），将子类传给代理者，通过start方法就会开始启用多线程调用多线程子类的run方法。&lt;/p&gt;
&lt;h3&gt;多个子线程启用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Hi {
    public static void main(String[] args) {
        Dog dog1 = new Dog(&quot;来福&quot;);
        Dog dog2 = new Dog(&quot;旺财&quot;);
        Thread thread1 = new Thread(dog1);
        Thread thread2 = new Thread(dog2);
        thread1.start();
        thread2.start();
    }
}

class Dog implements Runnable {
    private int count = 0;
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        while (count &amp;lt; 10) {
            System.out.println(&quot;大狗 &quot; + name + &quot; 叫叫叫~&quot;);
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
大狗 来福 叫叫叫~
大狗 来福 叫叫叫~
大狗 旺财 叫叫叫~
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中并不是完全交替执行的，其原因和底层CPU调用机制有关&lt;/p&gt;
&lt;p&gt;用jconsole监视线程，发现main线程很快退出，而两个子线程继续执行，并在各个线程结束后消散，最后进程结束&lt;/p&gt;
&lt;p&gt;Thread和Runnable&lt;/p&gt;
&lt;p&gt;1.之间本质上都没有什么区别，都是通过了start0方法去创建一个线程运行，而通过源码上来看发现Thread类本身也实现了Runnable的接口&lt;/p&gt;
&lt;p&gt;2.实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dog dog = new Dog();
Thread thread1 = new Thread(dog);
Thread thread2 = new Thread(dog);
thread1.start();
thread2.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程启用的机制&lt;/h2&gt;
&lt;h3&gt;线程的运行与生命周期&lt;/h3&gt;
&lt;p&gt;在我们运行代码的时候，我们会开启一个进程，在这个进程中我们会开启一个主线程，在主线程又会开启Thread-0子线程，用这种方式启动子线程后，主线程不会阻塞，会继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CupNum {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.start();
        for(int i = 0; i &amp;lt; 3; i++) {
            System.out.println(&quot;主线程 &quot; + i);
            try{
                Thread.sleep(1000);
            } catch (Exception e) {
                System.out.println(&quot;捕获主线程异常&quot;);
            }
        }
    }
}

class Cat extends Thread {
    private int times = 0;

    @Override
    public void run() {
        while (times &amp;lt; 5) {
            System.out.println(&quot;我是猫猫 第&quot; + times + &quot;次 线程名 &quot; + Thread.currentThread().getName());
            times++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获子线程异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直观上来看，子线程，主线程交替执行，直到线程执行完毕&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程 0
我是猫猫 第0次 线程名 Thread-0
主线程 1
我是猫猫 第1次 线程名 Thread-0
主线程 2
我是猫猫 第2次 线程名 Thread-0
我是猫猫 第3次 线程名 Thread-0
我是猫猫 第4次 线程名 Thread-0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了直观的看到线程的创建，我们使用jconsole来监视线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/95.png&quot; alt=&quot;95&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当子线程执行完后Thread就会被挂了，而主线程继续执行，或者如果主线程先挂，子线程也会继续执行，这就意味着主方法执行完毕的时候，可能进程任然在工作。（当所有的线程执行完毕的时候，进程才会被挂）&lt;/p&gt;
&lt;h3&gt;为什么时用start而不是run&lt;/h3&gt;
&lt;p&gt;当直接调用run方法启动代码的时候其实没有启用一个线程，实际上会发生阻塞，并不能实现我们预期中多线程&lt;/p&gt;
&lt;p&gt;1.先调用start方法，其中包含了start0方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在使用start方法的时候会调用start0（JVM）方法，这个方法由底层实现，实现了多线程，使用多线程的方法调用run，而run加载到可运行的线程中，由CPU进行执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private native void start0();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;实际案例（缺省版）&lt;/h2&gt;
&lt;p&gt;在后续同步机制中补完&lt;/p&gt;
&lt;p&gt;我们模拟一个三个窗口售票的情景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class SellTicket {
    public static void main(String[] args) {
        SellTicket01 sell = new SellTicket01();
        Thread t1 = new Thread(sell);
        Thread t2 = new Thread(sell);
        Thread t3 = new Thread(sell);
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellTicket01 implements Runnable {
    private static int ticketNum = 10;

    @Override
    public void run() {
        while(true) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                break;
            }

            try {
                System.out.println(&quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
                Thread.sleep(5000);
            } catch (Exception e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：我们会发现虽然设置了当票数&amp;lt;=0的时候需要break，但是在没有来得及对于票数进行减少的前提下，线程中的判断条件就已经执行（判断还剩余票，可以继续售卖），就会导致了票数超卖的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;售出一张票
售出一张票
剩余8张票
售出一张票
剩余7张票
剩余9张票
售出一张票
剩余6张票
售出一张票
剩余5张票
售出一张票
剩余4张票
售出一张票
剩余3张票
售出一张票
剩余2张票
售出一张票
剩余1张票
售出一张票
剩余0张票
售出一张票
剩余-1张票
售出一张票
剩余-2张票
票售完
票售完
票售完
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要使用线程的同步互斥来解决这个问题&lt;/p&gt;
&lt;h2&gt;线程的退出&lt;/h2&gt;
&lt;p&gt;1.当线程完成任务的时候，线程会自动退出&lt;/p&gt;
&lt;p&gt;2.还可以使用变量来控制run方法的退出的方式停止线程，及通知方式&lt;/p&gt;
&lt;p&gt;以下代码通过修改flag判断条件退出线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class Exit01 {
    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        t.flag = false;//设置为不再运行
    }
}

class T implements Runnable {
    public boolean flag = true;
    @Override
    public void run() {
        while(flag) {
            System.out.println(&quot;持续运行&quot;);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;持续运行
持续运行
持续运行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程常用的方法&lt;/h2&gt;
&lt;h3&gt;setName&lt;/h3&gt;
&lt;p&gt;设置线程名称，使与参数name同名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;getName&lt;/h3&gt;
&lt;p&gt;获取当前线程名称&lt;/p&gt;
&lt;h3&gt;setPriority&lt;/h3&gt;
&lt;p&gt;更改线程优先级&lt;/p&gt;
&lt;p&gt;分为1， 5， 10 从低到高&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);
        t.setPriority(Thread.MIN_PRIORITY);//设置优先级为最低
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;getPriority&lt;/h3&gt;
&lt;p&gt;获取线程优先级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sleep&lt;/h3&gt;
&lt;p&gt;暂停当前线程进入休眠&lt;/p&gt;
&lt;h3&gt;interrupt&lt;/h3&gt;
&lt;p&gt;中断线程，没有结束线程，一般用于中断正在休眠的线程（用于唤醒休眠线程）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread01 {
    public static void main(String[] args) {
        M m = new M();
        Thread t = new Thread(m);
        t.setName(&quot;线程1&quot;);//设置线程名字
        t.setPriority(Thread.MIN_PRIORITY);//设置优先级为最低
        System.out.println(t.getName());//获取线程名字
        t.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        t.interrupt();
    }
}

class M implements Runnable {
    public boolean flag = true;

    @Override
    public void run() {
        System.out.println(&quot;线程运行&quot;);
        try {
            System.out.println(&quot;线程休眠20s&quot;);
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            System.out.println(&quot;休眠被中断&quot;);
        }
        System.out.println(&quot;线程结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;线程1
线程运行
线程休眠20s
休眠被中断
线程结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;线程插队&lt;/h3&gt;
&lt;h3&gt;yield&lt;/h3&gt;
&lt;p&gt;线程礼让，让出CPU，让其他的线程执行，但是礼让的时间不确定，所以也不一定礼让成功&lt;/p&gt;
&lt;h3&gt;join&lt;/h3&gt;
&lt;p&gt;线程的插队，插队的线程一旦插队成功，则肯定先在执行完插入的线程的所有任务&lt;/p&gt;
&lt;h3&gt;使用join&lt;/h3&gt;
&lt;p&gt;代码示例（不加入插队的情况），两个线程交替进行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread02 {
    public static void main(String[] args) {
        System.out.println(&quot;主线程开始运行&quot;);
        N n = new N();
        Thread thread1 = new Thread(n);
        thread1.start();
        for(int i = 0; i &amp;lt; 20; i++) {
            System.out.println(&quot;主线程占用&quot; + i);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class N implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;子线程开始运行&quot;);
        for(int i = 0; i &amp;lt; 20; i++) {
            System.out.println(&quot;子线程占用&quot; + i);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
子线程占用1
主线程占用1
主线程占用2
子线程占用2
主线程占用3
子线程占用3
主线程占用4
子线程占用4
子线程占用5
主线程占用5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主线程加入join，让子线程插队&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i = 0; i &amp;lt; 20; i++) {
    System.out.println(&quot;主线程占用&quot; + i);
    try {
        if(i == 2) {
            thread1.join();//在判断主线程执行3次的时候，让子线程插队
        }
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
主线程占用1
子线程占用1
主线程占用2
子线程占用2
子线程占用3
子线程占用4
子线程占用5
子线程占用6
子线程占用7
子线程占用8
子线程占用9
子线程占用10
......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当子线程结束后，主线程再继续执行&lt;/p&gt;
&lt;h3&gt;使用yield&lt;/h3&gt;
&lt;p&gt;（调用静态方法）&lt;/p&gt;
&lt;p&gt;而使用yield在资源不紧张的情况下可以使得继续同步执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i = 0; i &amp;lt; 20; i++) {
    System.out.println(&quot;主线程占用&quot; + i);
    try {
        if(i == 2) {
            Thread.yield();
        }
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：仍然继续同步执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程开始运行
主线程占用0
子线程开始运行
子线程占用0
主线程占用1
子线程占用1
子线程占用2
主线程占用2
子线程占用3
主线程占用3
子线程占用4
主线程占用4
主线程占用5
子线程占用5
主线程占用6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;线程插队例题&lt;/h3&gt;
&lt;p&gt;1.主线程每间隔1s输出hi，一共10次&lt;/p&gt;
&lt;p&gt;2.当输出5次hi后，启动一个子线程，每隔1s输出hello （要求使用join插队）&lt;/p&gt;
&lt;p&gt;3.在子线程执行完毕后继续输出主线程的hi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
public class Homework {
    public static void main(String[] args) throws InterruptedException {
        AA aa = new AA();
        Thread thread = new Thread(aa);
        for (int i = 1; i &amp;lt; 11; i++) {
            System.out.println(&quot;hi &quot; + i);
            if (i == 5) {
                thread.start();
                thread.join();
            }
            Thread.sleep(1000);
        }
        System.out.println(&quot;主线程结束&quot;);
    }
}

class AA implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i &amp;lt; 11; i++) {
            System.out.println(&quot;hello &quot; + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println(&quot;子线程结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户线程和守护线程&lt;/h2&gt;
&lt;p&gt;1.用户线程：也被称为工作线程，当线程的任务执行完成或通知方式结束&lt;/p&gt;
&lt;p&gt;2.守护线程：一般是为了工作线程服务的，当所有的用户线程结束的时候，守护线程自动结束&lt;/p&gt;
&lt;p&gt;3.常见的守护线程：垃圾回收机制&lt;/p&gt;
&lt;p&gt;我们接下来模拟一个守护线程，这个线程在主线程运行完毕之后退出，只需要将子线程设置为守护线程即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class Thread03 {
    public static void main(String[] args) {
        B b = new B();
        Thread thread = new Thread(b);
        thread.setDaemon(true);
        //设置守护线程 注意先设置再启动
        thread.start();
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.println(&quot;主线程工作中...&quot;);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class B implements Runnable {
    @Override
    public void run() {
        while(true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;守护线程工作中...&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：可见使用setDaemon关键字进行设置守护线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
守护线程工作中...
主线程工作中...
主线程工作中...
守护线程工作中...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程的生命周期&lt;/h2&gt;
&lt;p&gt;在JDK文档中有一个State的枚举类型，用于表示线程的六种状态&lt;/p&gt;
&lt;p&gt;NEW 尚未启动的线程位于此状态&lt;/p&gt;
&lt;p&gt;RUNNABLE 在Java虚拟机中执行的线程位于此状态&lt;/p&gt;
&lt;p&gt;BLOCKED 被阻塞等待监视器锁定的线程位于此状态&lt;/p&gt;
&lt;p&gt;WAITING 正在等待另一个线程执行特定动作的线程位于此状态&lt;/p&gt;
&lt;p&gt;TIMED_WAITING 正在等待另一个线程执行特定动作到指定的等待时间的线程位于此状态&lt;/p&gt;
&lt;p&gt;TERMINATED 已退出的线程位于此状态&lt;/p&gt;
&lt;p&gt;在有一些说法中有七种状态之说：其实是RUNNABLE细化为了READY和RUNNING，取决于是否真正在运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/96.png&quot; alt=&quot;96&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中RUNNABLE会通过三种不同的操作进入WAITING TIMED_WAITING BLOCKED 而在特定的条件下返回RUNNABLE&lt;/p&gt;
&lt;p&gt;在以前提到的wait和join实际上就是将线程的状态切换为WAITING 或者 TIMED_WAITING（取决于加不加参数），而yeild是将RUNING状态尝试着切换到Ready状态，从而让出CPU时间&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Thread03 {
    public static void main(String[] args) {
        B b = new B();
        Thread thread = new Thread(b);
        System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//再启动前输出状态（1）
        thread.start();
        //在状态不为结束的时候重复输出状态
        while(Thread.State.TERMINATED != thread.getState()) {
            System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//在RUNNABLE的状态输出（2）
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println(&quot;thread 的状态为 &quot; + thread.getState());//在线程结束时输出状态（3）
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;thread 的状态为 NEW（1）
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
线程工作中...
线程工作中...
thread 的状态为 TIMED_WAITING//在子线程启用sleep时进入了TIMED_WAITING
线程工作中...
线程工作中...
thread 的状态为 RUNNABLE
thread 的状态为 TERMINATED（3）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;线程同步机制&lt;/h2&gt;
&lt;p&gt;还记得我们之前的售票问题吗？因为没有办法预期什么时候票售完，而导致了过量销售票的问题，现在我们要来解决这个问题&lt;/p&gt;
&lt;h3&gt;同步&lt;/h3&gt;
&lt;p&gt;1.在多线程编程中，一些敏感的数据不允许被多个线程同时访问，此时就要使用同步访问技术，保证数据在任何一个时刻最多只能有一个线程访问它，保证数据的完整性&lt;/p&gt;
&lt;p&gt;2.从内存上而言，线程同步是当有一个线程对特定的内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作&lt;/p&gt;
&lt;h3&gt;Synchronized关键字&lt;/h3&gt;
&lt;p&gt;1.同步代码块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized(对象){	//得到对象的锁之后才可以操作代码
	//需要被同步的代码;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.运用synchronized放在方法声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized void m () {
	//需要被同步的代码;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;互斥锁&lt;/h3&gt;
&lt;p&gt;1.Java中，引入了对象互斥锁的概念，来保证共享数据操作的完整性&lt;/p&gt;
&lt;p&gt;2.每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，只能有一个线程访问该对象&lt;/p&gt;
&lt;p&gt;3.关键字synchronized来与对象的互斥锁联系，当某个对象用synchronized装饰的时候，表明该对象在任一时刻只能由一个线程访问&lt;/p&gt;
&lt;p&gt;4.同步的局限性：导致程序的执行效率降低&lt;/p&gt;
&lt;p&gt;5.同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）&lt;/p&gt;
&lt;p&gt;6.同步方法（静态的）的锁为当前类本身&lt;/p&gt;
&lt;h3&gt;解决方法&lt;/h3&gt;
&lt;h4&gt;解决方法1&lt;/h4&gt;
&lt;p&gt;在方法上直接加锁，加上synchronized关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public synchronized void sell() {
        if(ticketNum &amp;lt;= 0) {
            System.out.println(&quot;票售完&quot;);
            loop = false;
            return;
        }

        try {
            System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
            ticketNum--;
            System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
            Thread.sleep(5000);
        } catch (Exception e) {
            System.out.println(&quot;捕获异常&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0售出一张票
剩余9张票
Thread-1售出一张票
剩余8张票
Thread-2售出一张票
剩余7张票
Thread-2售出一张票
剩余6张票
Thread-1售出一张票
剩余5张票
Thread-1售出一张票
剩余4张票
Thread-1售出一张票
剩余3张票
Thread-1售出一张票
剩余2张票
Thread-1售出一张票
剩余1张票
Thread-0售出一张票
剩余0张票
票售完
票售完
票售完
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;解决方法2&lt;/h4&gt;
&lt;p&gt;在代码块上加锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public void sell() {
        synchronized(this) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                loop = false;
                return;
            }

            try {
                System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
                Thread.sleep(5000);
            } catch (Exception e) {
                System.out.println(&quot;捕获异常&quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;p&gt;其实还可以改进一下，将模拟的sleep放在所代码块的外面，这样可以模拟每一个售票窗口每5s售一张票，而不是没5s只有一个售票口出一张票（其实这里在实际编程中不会加入sleep休眠，只是增强一下对锁的理解，sleep休眠的时间是不受this锁的影响）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SellTicket01 implements Runnable {
    private static int ticketNum = 10;
    private boolean loop = true;
    @Override
    public void run() {
        while(loop) {
            sell();
        }
    }

    public void sell() {
        synchronized(this) {
            if(ticketNum &amp;lt;= 0) {
                System.out.println(&quot;票售完&quot;);
                loop = false;
                return;
            }
                System.out.println(Thread.currentThread().getName() + &quot;售出一张票&quot;);
                ticketNum--;
                System.out.println(&quot;剩余&quot; + ticketNum + &quot;张票&quot;);
        }

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;注意细节&lt;/h3&gt;
&lt;p&gt;1.同步方法如果没有使用static修饰：默认锁对象为this&lt;/p&gt;
&lt;p&gt;2.如果方法使用static修饰，默认锁对象：当前类.class&lt;/p&gt;
&lt;p&gt;3.要求多个线程的锁对象为同一个&lt;/p&gt;
&lt;h3&gt;线程死锁&lt;/h3&gt;
&lt;p&gt;多个线程都占用了对方的锁资源，但是不肯相让，导致了死锁&lt;/p&gt;
&lt;p&gt;例如：A要B的b资源，但是b资源被B占用，而B要等到A的a资源释放后才可以继续运行完毕释放b资源，导致了A也无法获取到b资源，从而释放a。&lt;/p&gt;
&lt;p&gt;以下是一个发生死锁的代码示例，两个Object资源由static修饰，两个新创建的对象共享资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class DeadLock {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadLockDemo(true));
        Thread thread2 = new Thread(new DeadLockDemo(false));
        thread1.start();
        thread2.start();
    }
}

class DeadLockDemo implements Runnable {
    static Object resource1 = new Object();
    static Object resource2 = new Object();

    boolean flag;

    public DeadLockDemo(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag) {
            synchronized (resource1) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;获取资源1,下一步获取资源2&quot;);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource2) {
                    try {
                        System.out.println(Thread.currentThread().getName() + &quot;获取资源2&quot;);
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        } else {
            synchronized (resource2) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;获取资源2,下一步获取资源1&quot;);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource1) {
                    try {
                        System.out.println(Thread.currentThread().getName() + &quot;获取资源1&quot;);
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发生死锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0获取资源1,下一步获取资源2
Thread-1获取资源2,下一步获取资源1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;释放锁&lt;/h3&gt;
&lt;h4&gt;会释放锁的情况&lt;/h4&gt;
&lt;p&gt;1.当前线程的同步方法、同步代码块执行完毕&lt;/p&gt;
&lt;p&gt;2.当前线程在同步方法、同步代码块中遇到了break、return&lt;/p&gt;
&lt;p&gt;3.当前线程在同步方法、同步代码块中遇到了异常&lt;/p&gt;
&lt;p&gt;4.当前线程在同步方法、同步代码块中调用了线程对象的wait方法，使线程暂停&lt;/p&gt;
&lt;h4&gt;不会释放锁的情况&lt;/h4&gt;
&lt;p&gt;1.当前线程在同步方法、同步代码块中使用了Thread.sleep/yield方法&lt;/p&gt;
&lt;p&gt;2.线程执行同步代码块中，其他线程调用了该线程的suspend( )方法，将该线程挂起，该线程不会释放锁。（不推荐使用suspend和resume进行编程）&lt;/p&gt;
&lt;h1&gt;多线程编程作业&lt;/h1&gt;
&lt;h2&gt;例题一&lt;/h2&gt;
&lt;p&gt;1.在main方法中启动两个线程&lt;/p&gt;
&lt;p&gt;2.在第一个线程中随机循环打印100以内的整数&lt;/p&gt;
&lt;p&gt;3.直到第二个线程中从键盘读取了Q命令&lt;/p&gt;
&lt;p&gt;解题思路：&lt;/p&gt;
&lt;p&gt;我将线程2设置为守护线程，当线程1结束时，守护线程2自动结束&lt;/p&gt;
&lt;p&gt;而线程2中可以去设置线程1类的loop从而终止线程1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework01 {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new Task1());
        Thread thread2 = new Thread(new Task2());
        thread2.setDaemon(true);
        thread1.start();
        thread2.start();
    }
}

class Task1 implements Runnable {
    public static boolean loop = true;

    @Override
    public void run() {
        while (loop) {
            System.out.println((int) (Math.random() * 100));
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Task2 implements Runnable {
    @Override
    public void run() {
        while (true) {
            Scanner scanner = new Scanner(System.in);
            char c = scanner.next().charAt(0);
            if (c == &apos;Q&apos; || c == &apos;q&apos;) {
                Task1.loop = false;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你也可以在判断条件下直接break Task2，就不用守护线程了&lt;/p&gt;
&lt;h2&gt;例题二&lt;/h2&gt;
&lt;p&gt;1.有两个用户分别从一个卡上取钱（总额1000元）&lt;/p&gt;
&lt;p&gt;2.每次取1000块，当余额不足时就不能取了&lt;/p&gt;
&lt;p&gt;我对题目稍做了一些更改：每次随机取（0-1000元），使其更符合生活实际&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;

public class HomeWork02 {
    public static void main(String[] args) {
        Bank bank = new Bank();
        Thread thread1 = new Thread(bank);
        Thread thread2 = new Thread(bank);
        thread1.start();
        thread2.start();
    }
}

class Bank implements Runnable {
    public static int money = 10000;
    static final Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                int getMoney = (int) (Math.random() * 1000);
                if (money - getMoney &amp;lt; 0) {
                    System.out.println(&quot;钱不够取 剩余 &quot; + money);
                    break;
                } else {
                    System.out.println(Thread.currentThread().getName() + &quot; 取出 &quot; + getMoney + &quot; 剩余 &quot; + money);
                    money -= getMoney;
                }
            }
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread-0 取出 153 剩余 10000
Thread-1 取出 82 剩余 9847
Thread-0 取出 852 剩余 9765
Thread-1 取出 727 剩余 8913
Thread-1 取出 857 剩余 8186
Thread-0 取出 765 剩余 7329
Thread-1 取出 904 剩余 6564
Thread-0 取出 766 剩余 5660
Thread-1 取出 901 剩余 4894
Thread-0 取出 440 剩余 3993
Thread-1 取出 430 剩余 3553
Thread-0 取出 5 剩余 3123
Thread-1 取出 726 剩余 3118
Thread-0 取出 293 剩余 2392
Thread-0 取出 655 剩余 2099
Thread-1 取出 372 剩余 1444
Thread-0 取出 874 剩余 1072
钱不够取 剩余 198
钱不够取 剩余 198
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%B3%9B%E5%9E%8Bjunit/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%B3%9B%E5%9E%8Bjunit/</guid><description>泛型，JUnit</description><pubDate>Thu, 03 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;泛型&lt;/h2&gt;
&lt;h3&gt;使用案例&lt;/h3&gt;
&lt;p&gt;我们先来看一个例子&lt;/p&gt;
&lt;p&gt;运用集合来存储狗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Dog d = (Dog) iterator.next();
            System.out.println(d);
        }
    }
}

class Dog {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过迭代器遍历所有的狗，但是加入程序员不小心放入了一只猫，程序就会因为类型转化错误而抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.ClassCastException: com.Cat cannot be cast to com.Dog
	at com.Generic_.main(Generic_.java:19)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的情况下我们可以使用instanceof加上类型转换来进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        list.add(new Cat(&quot;小花&quot;, 11));
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            Object animal;
            if(obj instanceof Dog){
                animal = (Dog) obj;
            } else {
                animal = (Cat) obj;
            }
            System.out.println(animal);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果我们后续有不小心放入了一只羊，我们就还要去改进代码逻辑&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们引入了泛型，以约束传入的类型，使得在放入了不同于Dog类型的元素的时候就会发生编译器的编译警告，而不是在运行的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic_ {
    public static void main(String[] args) {
        ArrayList&amp;lt;Dog&amp;gt; list = new ArrayList&amp;lt;Dog&amp;gt;();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 33));
        list.add(new Dog(&quot;小黑&quot;, 12));
        //list.add(new Cat(&quot;黑猫&quot;, 12));编译出错
        for(Dog d : list) {
            System.out.println(d);
        }
    }
}

class Dog {
    String name;
    int age;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且可以通过增强的for循环来直接取出Dog对象，使得遍历更加的方便&lt;/p&gt;
&lt;p&gt;&lt;em&gt;泛型的好处&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1.在编译的时候会检查元素的类型，提升了安全性&lt;/p&gt;
&lt;p&gt;2.减少了类型的转换次数，提升了效率&lt;/p&gt;
&lt;p&gt;详细说明：在不使用泛型的时候，放入的时候需要转为Object放入，而取出时通过Object取出引用，需要进行类型的转换。在使用泛型的时候，放入和取出的时候，不需要类型转化&lt;/p&gt;
&lt;p&gt;3.不再提示编译警告（无需加入SuppressWarnings的注解）&lt;/p&gt;
&lt;h3&gt;泛型的定义&lt;/h3&gt;
&lt;p&gt;泛型是一种可以表示数据类型的数据类型，由程序员来指定&lt;/p&gt;
&lt;p&gt;1.泛型又称为参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全问题&lt;/p&gt;
&lt;p&gt;2.在类声明或者实例化时只需要指定好需要的具体类型即可&lt;/p&gt;
&lt;p&gt;3.Java泛型可以保证如果程序在编译时发出警告，而不是运行时出现异常，同时代码更加的简介健壮&lt;/p&gt;
&lt;p&gt;4.泛型的作用是，可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值类型，或者是参数类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        Person&amp;lt;String&amp;gt; person = new Person&amp;lt;String&amp;gt;(&quot;礼物&quot;);
        Person&amp;lt;Integer&amp;gt; person1 = new Person&amp;lt;Integer&amp;gt;(1);
    }
}

class Person&amp;lt;E&amp;gt; {
    E s;
    //E表示的是 s的数据类型，该数据类型在定义Person对象时指定
    //即在编译期间就确定E的类型

    public Person(E s) {
        this.s = s;
    }

    public E f() {
        return s;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E表示的是 s的数据类型，该数据类型在定义Person对象时指定，即在编译期间就确定E的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        Person&amp;lt;String&amp;gt; person = new Person&amp;lt;String&amp;gt;(&quot;礼物&quot;);
        person.classReturn();//class java.lang.String
        Person&amp;lt;Integer&amp;gt; person1 = new Person&amp;lt;Integer&amp;gt;(1);
        person1.classReturn();//class java.lang.Integer
    }
}

class Person&amp;lt;E&amp;gt; {
    E s;

    public Person(E s) {
        this.s = s;
    }

    public void classReturn() {
        System.out.println(s.getClass());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;泛型的语法&lt;/h3&gt;
&lt;h4&gt;声明&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;interface 接口&amp;lt;E&amp;gt; {}
class 类&amp;lt;E,F&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;实例化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;String&amp;gt;();
Iterator&amp;lt;Customer&amp;gt; iterator = customers.iterator();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;例题&lt;/h4&gt;
&lt;p&gt;总而言之在创建泛型集合的时候，传入的泛型类型就会在源码中赋给所有的泛型变量，在实际使用的时候运用var补全即可方便的获取迭代器、EntrySet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        HashSet&amp;lt;Student&amp;gt; set= new HashSet&amp;lt;Student&amp;gt;();
        Student person1 = new Student(&quot;李明&quot;, 19);
        Student person2 = new Student(&quot;王名&quot;, 29);
        Student person3 = new Student(&quot;王王&quot;, 9);
        set.add(person1);
        set.add(person2);
        set.add(person3);
        Iterator&amp;lt;Student&amp;gt; it = set.iterator();
        while(it.hasNext()) {
            Student student = it.next();
            System.out.println(student);
        }

        for(Student student : set){
            System.out.println(student);
        }
    }
}

class Student {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;学生 &quot; + name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap来使用泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic03 {
    public static void main(String[] args) {
        HashMap&amp;lt;String, Student&amp;gt; map= new HashMap&amp;lt;String, Student&amp;gt;();
        Student person1 = new Student(&quot;李明&quot;, 19);
        Student person2 = new Student(&quot;王名&quot;, 29);
        Student person3 = new Student(&quot;王王&quot;, 9);
        map.put(&quot;学生1&quot;, person1);
        map.put(&quot;学生2&quot;, person2);
        map.put(&quot;学生3&quot;, person3);
        Set&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; entrySet = map.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, Student&amp;gt;&amp;gt; iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Map.Entry&amp;lt;String, Student&amp;gt; entry = iterator.next();
            String lable = entry.getKey();
            Student student = entry.getValue();
            System.out.println(lable + student);
        }
    }
}

class Student {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot; &quot; + name + &quot; &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;泛型的使用细节&lt;/h3&gt;
&lt;p&gt;1.泛型里面的类型只能够是引用数据类型，不可以传入基本数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        //List&amp;lt;int&amp;gt; listInt = new ArrayList&amp;lt;int&amp;gt;();编译错误
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在指定泛型具体类型后，可以传入该类型或者该类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        List&amp;lt;A&amp;gt; list = new ArrayList&amp;lt;A&amp;gt;();
        list.add(new A());
        list.add(new AA());
    }
}

class A {}
class AA extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者自定义一个类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        A a = new A();
        AA aa = new AA();
        Test&amp;lt;A&amp;gt; test1 = new Test&amp;lt;A&amp;gt;(a);
        Test&amp;lt;A&amp;gt; test2 = new Test&amp;lt;A&amp;gt;(aa);//传入泛型A的子类型实例引用aa
    }
}

class Test&amp;lt;E&amp;gt; {
    E e;

    public Test(E e) {
        this.e = e;
    }
}

class A {}
class AA extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.泛型的使用形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list1 = new ArrayList&amp;lt;Integer&amp;gt;();
List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();//编译器会自动推断泛型类型

List list3 = new ArrayList();//等价于如下形式
List&amp;lt;Object&amp;gt; list4 = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以去证明一下，其中e可已接收任何类型的实例，判断出e被指定为一个Object类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Generic04 {
    public static void main(String[] args) {
        Test test = new Test();
        test.e = 100;
        System.out.println(test.e.getClass());
        test.e = &quot;Hello&quot;;
        System.out.println(test.e.getClass());
    }
}

class Test&amp;lt;E&amp;gt; {
    public E e;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class java.lang.Integer
class java.lang.String
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;练习题&lt;/h3&gt;
&lt;p&gt;一个练习题，实现员工的排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Generic04 {
    public static void main(String[] args) {
        Employee person1 = new Employee(&quot;丽华&quot;, 19100.0, new MyDate(2004, 5, 2));
        Employee person2 = new Employee(&quot;李丽&quot;, 13900.0, new MyDate(1964, 1, 12));
        Employee person3 = new Employee(&quot;王芳&quot;, 3900.0, new MyDate(1994, 3, 23));
        Employee person4 = new Employee(&quot;王芳&quot;, 300.0, new MyDate(1993, 11, 23));
        Employee person5 = new Employee(&quot;王芳&quot;, 900.0, new MyDate(1994, 3, 23));
        List&amp;lt;Employee&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(person1);
        list.add(person2);
        list.add(person3);
        list.add(person4);
        list.add(person5);

        list.sort(new Comparator&amp;lt;Employee&amp;gt;() {
            @Override
            public int compare(Employee o1, Employee o2) {
                int i = o1.getName().compareTo(o2.getName());
                if (i != 0) {
                    return i;
                }
                return o1.getBirthday().compareTo(o2.getBirthday());
            }
        });

        for (Employee e : list) {
            System.out.println(e);
        }
    }
}

class Employee {
    private String name;
    private double sal;
    private MyDate birthday;


    public Employee(String name, double sal, MyDate birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return name + &quot; 薪水是 &quot; + sal + &quot; 生日是 &quot; + birthday.toString();
    }

    public double getSal() {
        return sal;
    }

    public void setSal(double sal) {
        this.sal = sal;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public MyDate getBirthday() {
        return birthday;
    }

    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }
}

class MyDate implements Comparable&amp;lt;MyDate&amp;gt;{
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public int compareTo(MyDate o2) {
        int year = getYear() - o2.getYear();
        if (year != 0) {
            return year;
        }
        int  month= getMonth() - o2.getMonth();
        if (month != 0) {
            return month;
        }
        int day = getDay() - o2.getDay();
            return day;
    }

    @Override
    public String toString() {
        return &quot;&quot; + year + &quot;-&quot; + month + &quot;-&quot; + day;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;自定义泛型&lt;/h2&gt;
&lt;h3&gt;自定义泛型类&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class 类名&amp;lt;T,E ...&amp;gt; {
	成员
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.普通成员可以使用泛型（属性，方法）&lt;/p&gt;
&lt;p&gt;2.使用泛型的数组，不可以初始化（因为不知道空间大小）&lt;/p&gt;
&lt;p&gt;3.静态方法中不可以使用类的泛型&lt;/p&gt;
&lt;p&gt;4.泛型类的类型，是在创建对象时确定的（因为创建对象时，需要确定类型）&lt;/p&gt;
&lt;p&gt;5.如果在创建对象时没有指定类型，默认为Object&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Tiger&amp;lt;T, R, M&amp;gt; {
    String name;
    T t;
    R r;
    M m;

    public Tiger (String name, T t, R r, M m) {
        this.name = name;
        this.t = t;
        this.r = r;
        this.m = m;
    }

    public T gerT() {
        return this.t;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class generic {
    public static void main(String[] args) {
        Tiger&amp;lt;String, Integer, Double&amp;gt; tiger = new Tiger&amp;lt;&amp;gt;(&quot;Tiger&quot;, &quot;Tiger&quot;, 1, 1.1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用泛型实现复数相加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Complex&amp;lt;T extends Number&amp;gt; {
    private final T real;  // 实部
    private final T imaginary;  // 虚部

    public Complex(T real, T imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    // 复数相加（返回新的 Complex&amp;lt;T&amp;gt;）
    public Complex&amp;lt;T&amp;gt; add(Complex&amp;lt;T&amp;gt; other, BinaryOperator&amp;lt;T&amp;gt; adder) {
        T newReal = adder.apply(this.real, other.real);
        T newImaginary = adder.apply(this.imaginary, other.imaginary);
        return new Complex&amp;lt;&amp;gt;(newReal, newImaginary);
    }

    @Override
    public String toString() {
        return real + &quot; + &quot; + imaginary + &quot;i&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义泛型接口&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;interface 接口名&amp;lt;T, R...&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.接口中，静态成员也不可以使用泛型&lt;/p&gt;
&lt;p&gt;2.泛型的接口类型，在继承接口，或者实现接口时确定&lt;/p&gt;
&lt;p&gt;3.没有指定类型，泛型默认为Object&lt;/p&gt;
&lt;p&gt;使用样例，这里没什么实际运用价值，只是作为展示如何使用（在源码中有很多这种泛型接口），这里是直接指定接口的泛型，事实上，你也可以去添加类的泛型和接口一样，从而保留泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Interface_ {
    public static void main(String[] args) {
        SomeNumber num = new SomeNumber(&quot;数学&quot;, 10);
        System.out.println(num.start(&quot; 难&quot;));
        System.out.println(num.end(10));

    }
}

interface Number&amp;lt;K, V&amp;gt; {
    K start(K k);
    V end(V v);
}

//实现接口的时候，直接指定
class SomeNumber implements Number&amp;lt;String, Integer&amp;gt;{
    String name;
    Integer i;

    public SomeNumber(String name, Integer i) {
        this.name = name;
        this.i = i;
    }

    @Override
    public String start(String s) {
        return name + s;
    }

    @Override
    public Integer end(Integer integer) {
        return i + integer;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义泛型方法&lt;/h3&gt;
&lt;h4&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;修饰符 &amp;lt;T, R ...&amp;gt;返回类型 方法名 (参数列表) {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用细节&lt;/h4&gt;
&lt;p&gt;1.泛型方法，可以定义在普通类中，也可以定义在泛型类中&lt;/p&gt;
&lt;p&gt;2.当泛型方法被调用的时候，类型会确定&lt;/p&gt;
&lt;p&gt;3.public void eat(E e) {}，修饰符后没有&amp;lt;T, R&amp;gt; eat不是泛型方法，只是使用了泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Function {
    public static void main(String[] args) {
        MyTool.printT(&quot;你好&quot;);
        MyTool.printT(23);
    }
}

class MyTool {
    public static&amp;lt;T&amp;gt; void printT(T t) {
        System.out.println(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;泛型的继承&lt;/h2&gt;
&lt;p&gt;1.泛型不具备继承性，不可以把创建的以子类泛型赋值给父类泛型修饰的类型&lt;/p&gt;
&lt;p&gt;2.&amp;lt;?&amp;gt;支持任意泛型类型&lt;/p&gt;
&lt;p&gt;3.&amp;lt;? extands A&amp;gt;支持A类以及A类的子类，规定了泛型的上限&lt;/p&gt;
&lt;p&gt;4.&amp;lt;? super A&amp;gt;支持A类以及A类的父类，不限于直接父类，规定了泛型的下限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Function {
    public static void main(String[] args) {
        List&amp;lt;Object&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;AA&amp;gt; list3 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;BB&amp;gt; list4 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;CC&amp;gt; list5 = new ArrayList&amp;lt;&amp;gt;();
        printCollection1(list1);
        printCollection1(list2);
        printCollection1(list3);
        printCollection1(list4);
        printCollection1(list5);

        printCollection2(list1);//错误，上限是AA，Object是AA的父类
        printCollection2(list2);//错误，String和AA不存在继承关系
        printCollection2(list3);
        printCollection2(list4);
        printCollection2(list5);

        printCollection3(list1);
        printCollection3(list2);//错误，String和AA不存在继承关系
        printCollection3(list3);
        printCollection3(list4);
        printCollection3(list5);

    }

    public static void printCollection1(List&amp;lt;?&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }

    public static void printCollection2(List&amp;lt;? extends AA&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }

    public static void printCollection3(List&amp;lt;? super CC&amp;gt; c) {
        for (Object obj : c) {
            System.out.println(obj);
        }
    }
}

class AA {

}

class BB extends AA {

}

class CC extends BB {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;泛型例题&lt;/h2&gt;
&lt;p&gt;创建一个泛型类，放入map&amp;lt;String, T&amp;gt;，实现相关方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
import org.junit.jupiter.api.Test;
import java.util.*;

public class Homework {
    public static void main(String[] args) {

    }

    @Test
    public void test1 () {
        User usr1 = new User(1, 18, &quot;lory&quot;);
        User usr2 = new User(2, 38, &quot;marry&quot;);
        User usr3 = new User(3, 28, &quot;jack&quot;);

        Dao&amp;lt;User&amp;gt; map = new Dao&amp;lt;&amp;gt;();
        map.save(&quot;100&quot;, usr1);
        map.save(&quot;200&quot;, usr3);
        map.save(&quot;300&quot;, usr2);
        System.out.println(map.get(&quot;200&quot;));
        List&amp;lt;User&amp;gt; list = map.list();
        for(User usr : list) {
            System.out.println(usr);
        }
    }
}

class Dao&amp;lt;T&amp;gt; {
    private Map&amp;lt;String, T&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    public void save(String id, T entity) {
        map.put(id, entity);
    }

    public T get(String id) {
        return map.get(id);
    }

    public List&amp;lt;T&amp;gt; list() {
        Set&amp;lt;Map.Entry&amp;lt;String, T&amp;gt;&amp;gt; entrySet = map.entrySet();
        Iterator&amp;lt;Map.Entry&amp;lt;String, T&amp;gt;&amp;gt; iterator = entrySet.iterator();
        ArrayList&amp;lt;T&amp;gt; target = new ArrayList&amp;lt;&amp;gt;();
        while (iterator.hasNext()) {
            Map.Entry&amp;lt;String, T&amp;gt; entry = iterator.next();
            target.add(entry.getValue());
        }
        return target;
    }

    public void delete(String id) {
        map.remove(id);
    }
}

class User {
    private int id;
    private int age;
    private String name;

    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return id + &quot; &quot; + age + &quot; &quot; + name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JUnit单元测试框架&lt;/h2&gt;
&lt;p&gt;在以往的测试中，我们需要手动的将编写的方法类实例化，在主方法中进行调用，这样做似乎有些复杂了，我们可以通过在需要测试的方法上添加@Test注解，并引入相关的包就可以单独运行方法，甚至支持Debug&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/93.png&quot; alt=&quot;93&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com;
import org.junit.jupiter.api.Test;

public class Junit {
    public static void main(String[] args) {

    }

    @Test
    public void m1() {
        System.out.println(&quot;m1&quot;);//m1
    }

    @Test
    public void m2() {
        System.out.println(&quot;m2&quot;);//m2
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8802/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8802/</guid><description>集合第二部分</description><pubDate>Wed, 02 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;Map接口&lt;/h2&gt;
&lt;h3&gt;定义及性质&lt;/h3&gt;
&lt;p&gt;双列集合&lt;/p&gt;
&lt;p&gt;存放的是K-V&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/91.png&quot; alt=&quot;91&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Map接口下有三个重要的类Hashtable ，HashMap ， TreeMap，其中HashMap时使用频率最高的&lt;/p&gt;
&lt;p&gt;1.Map与Collection并列存在，保存具有映射关系的数据，Key-Value&lt;/p&gt;
&lt;p&gt;2.Map中的key和value可以是任何引用类型的数据，会封装在HashMap$Node对象中&lt;/p&gt;
&lt;p&gt;3.Map中的key不允许重复，原因和HashSet一样&lt;/p&gt;
&lt;p&gt;4.Map中的key可以重复&lt;/p&gt;
&lt;p&gt;5.Map中的key和value可以为null，但是key中的null只能有一个，而value不做限制&lt;/p&gt;
&lt;p&gt;6.常用类String类可以作为Map的key&lt;/p&gt;
&lt;p&gt;7.key和value之间存在单向的一对一关系，即通过指定的key总可以找到对应的value&lt;/p&gt;
&lt;p&gt;8.map存放数据k-v，一对key-value是存放在HashMapNode中的&lt;/p&gt;
&lt;p&gt;为了程序员遍历方便，还会创建EntrySet集合，该集合放入的是Entry（事实上是将EntrySet中的table 存储的Entry节点指向Map的Node）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Map常用方法&lt;/h3&gt;
&lt;h4&gt;put&lt;/h4&gt;
&lt;p&gt;放入Map集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;jack&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map);
        //{16=marry, 10=hello, 12=lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见put当key重复的时候其实起的是替换的作用&lt;/p&gt;
&lt;p&gt;而value是可以重复的，只要key不一样即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.put(13, &quot;hello&quot;);
        System.out.println(map.size());//4
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;get&lt;/h4&gt;
&lt;p&gt;通过key返回value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.put(13, &quot;hello&quot;);
        System.out.println(map.get(12));//lory
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;remove&lt;/h4&gt;
&lt;p&gt;根据key删除映射关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.remove(16);
        System.out.println(map);
        //{10=hello, 12=lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;size&lt;/h4&gt;
&lt;p&gt;获取元素个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;isEmpty&lt;/h4&gt;
&lt;p&gt;判断元素个数是否为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.isEmpty());//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;clear&lt;/h4&gt;
&lt;p&gt;清除所有元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        map.clear();
        System.out.println(map.isEmpty());//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;containsKey&lt;/h4&gt;
&lt;p&gt;查找键是否存在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        System.out.println(map.containsKey(10));//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Map接口的遍历方式&lt;/h3&gt;
&lt;p&gt;总共有六种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set&amp;lt;K&amp;gt; keySet();
Collection&amp;lt;V&amp;gt; values();
Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;keySet&lt;/h4&gt;
&lt;p&gt;1、2、通过取出Key的Set集合，遍历Set集合中的Key，还可以通过Key取出Map中的Value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Set keySet = map.keySet();
        for (Object key : keySet) {
            System.out.println(key + &quot;: &quot; + map.get(key));
        }
        Iterator iterator = keySet.iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + &quot;: &quot; + map.get(key));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;values&lt;/h4&gt;
&lt;p&gt;3、4、取出Values，进行遍历（用接口Collection接收）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Collection values = map.values();
        for(Object obj : values) {
            System.out.print(obj + &quot; &quot;);
        }

        Iterator iterator = values.iterator();
        while(iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.print(obj + &quot; &quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;entrySet&lt;/h4&gt;
&lt;p&gt;5、6、通过取出Entry的Set集合，将entry（Object）转为Map.Entry，再通过Map.Entry实现的getKey和getValue方法取出Map中的KV&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, &quot;lory&quot;);
        map.put(16, &quot;marry&quot;);
        map.put(10, &quot;hello&quot;);
        Set entrySet = map.entrySet();
        for(Object o : entrySet) {
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }

        Iterator iterator = entrySet.iterator();
        while(iterator.hasNext()) {
            Object o = iterator.next();
            Map.Entry entry = (Map.Entry) o;
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;综合案例&lt;/h4&gt;
&lt;p&gt;输出集合中工资大于18000的键值以及对应老师toString方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Map_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put(12, new Teacher(&quot;lory&quot;, 22, 12000 ));
        map.put(16, new Teacher(&quot;marry&quot;, 44, 13000));
        map.put(13, new Teacher(&quot;jack&quot;, 55, 19000));
        Set entrySet = map.entrySet();
        for (Object obj : entrySet) {
            Map.Entry entry = (Map.Entry) obj;
            Teacher teacher = (Teacher) entry.getValue();
            if(teacher.salary &amp;gt; 18000) {
                System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
            }
        }
    }
}

class Teacher {
    String name;
    int age;
    double salary;

    public Teacher(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return &quot;教师 &quot; + name + &quot; &quot; +
                &quot;今年 &quot; + age + &quot; 岁&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Map的实现子类&lt;/h2&gt;
&lt;h3&gt;HashMap&lt;/h3&gt;
&lt;p&gt;1.Map接口的常用实现类是HashMap，Hashtable，Properties&lt;/p&gt;
&lt;p&gt;2.其中HashMap是Map接口中使用频率最高的实现类&lt;/p&gt;
&lt;p&gt;3.通过key-value的方式存储数据&lt;/p&gt;
&lt;p&gt;4.和HashSet一样，不保证映射的顺序，因为底层是由hash表的方式来存储的&lt;/p&gt;
&lt;p&gt;5.HashMap没有实现线程同步，因此线程不安全&lt;/p&gt;
&lt;p&gt;HashMap扩容上而言和HashSet一模一样，扩容因子是0.75扩容为原来的两倍，默认初始化为16&lt;/p&gt;
&lt;h3&gt;Hashtable&lt;/h3&gt;
&lt;p&gt;1.放入的元素为键值对Key-Value&lt;/p&gt;
&lt;p&gt;2.Hashtable的键和值都不能为null（否则会派出NullPointException）&lt;/p&gt;
&lt;p&gt;3.Hashtable的使用和HashMap基本相同&lt;/p&gt;
&lt;p&gt;4.Hashtable是线程安全的，而HashMap不是线程安全的&lt;/p&gt;
&lt;h3&gt;HashMap与Hashtable对比&lt;/h3&gt;
&lt;p&gt;HashMap线程不安全而Hashtable安全&lt;/p&gt;
&lt;p&gt;HashMap效率优于Hashtable&lt;/p&gt;
&lt;p&gt;Hashtable不允许null键值和null数据&lt;/p&gt;
&lt;h3&gt;Properties&lt;/h3&gt;
&lt;p&gt;1.Properties类继承于Hashtable并且实现了Map接口，是一种键值对的形式保存数据&lt;/p&gt;
&lt;p&gt;2.使用方式和Hashtable类似&lt;/p&gt;
&lt;p&gt;3.Properties还可以用于从xxx.properites文件中，加载数据带Properties类对象，并进行读取和修改（广泛用于从配置文件中读取账号和密码，避免硬编码）&lt;/p&gt;
&lt;p&gt;4.xxx.properites文件通常作为配置文件，在后续的IO流会介绍&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Properties_ {
    public static void main(String[] args) {
        Properties properties = new Properties();
        properties.put(18, &quot;lory&quot;);
        properties.put(19, &quot;marry&quot;);
        properties.put(20, &quot;jack&quot;);
        System.out.println(properties.get(18));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;LinkedHashMap&lt;/h3&gt;
&lt;p&gt;和LinkedHashSet与HashSet的关系类似&lt;/p&gt;
&lt;p&gt;是HashMap的有序排列（通过双向链表维护）&lt;/p&gt;
&lt;h3&gt;TreeMap&lt;/h3&gt;
&lt;p&gt;直接实现Map接口&lt;/p&gt;
&lt;p&gt;保证插入时的键有序（通过传入一个Comparator接口比较器）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TreeMap01 {
    public static void main(String[] args) {
        TreeMap treeMap = new TreeMap(new Comparator() {
            public int compare(Object o1, Object o2) {
                int i1 = (Integer)o1;
                int i2 = (Integer)o2;
                return i1 - i2;
            }
        });
        treeMap.put(1, &quot;Tom&quot;);
        treeMap.put(3, &quot;Marry&quot;);
        treeMap.put(4, &quot;Lory&quot;);
        treeMap.put(2, &quot;Thrinisty&quot;);
        System.out.println(treeMap);
        //{1=Tom, 2=Thrinisty, 3=Marry, 4=Lory}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Collections工具类&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;1.Collections是一个操作Set，List，Map集合的工具类&lt;/p&gt;
&lt;p&gt;2.提供了一系列的静态方法对集合元素进行排序，查询，修改等操作&lt;/p&gt;
&lt;h3&gt;常用的工具类&lt;/h3&gt;
&lt;h4&gt;reverse（List）&lt;/h4&gt;
&lt;p&gt;将List中的元素顺序反转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.reverse(list);
        System.out.println(list);
        //[C, B, true, 10, A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;shuffle（List）&lt;/h4&gt;
&lt;p&gt;将List中的元素随机排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.shuffle(list);
        System.out.println(list);
        //[B, true, C, 10, A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sort（List，Comparator）&lt;/h4&gt;
&lt;p&gt;将List中的元素按照指定功能排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.sort(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String)o1;
                String s2 = (String)o2;
                return s1.compareTo(s2);
            }
        });
        System.out.println(list);
        //[A, B, BFXC, C, DVB]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;swap（List，int， int）&lt;/h4&gt;
&lt;p&gt;交换List中的两个对应下标中的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        Collections.swap(list, 3, 2);
        System.out.println(list);
        //[A, BFXC, B, DVB, C]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;max（Collection，Comparator）&lt;/h4&gt;
&lt;p&gt;按照指定顺序返回最大元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;B&quot;);
        list.add(&quot;C&quot;);
        System.out.println(Collections.max(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String) o1;
                String s2 = (String) o2;
                return s1.length() - s2.length();
            }
        }));
        //BFXC
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;frequency（Collection， Object）&lt;/h4&gt;
&lt;p&gt;返回指定集合中指定元素出现的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        list.add(&quot;A&quot;);
        list.add(&quot;A&quot;);
        System.out.println(Collections.frequency(list, &quot;A&quot;));
        //3
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;copy（List dest，List src）&lt;/h4&gt;
&lt;p&gt;将src的内容复制到dest中&lt;/p&gt;
&lt;p&gt;要求新的集合大小大于旧的，否则或抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        List list1 = new ArrayList();
        list1.add(&quot; &quot;);
        list1.add(&quot; &quot;);
        list1.add(&quot; &quot;);
        Collections.copy(list1, list);
        System.out.println(list1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下这种方式也不行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;DVB&quot;);
        List list1 = new ArrayList(4);
        list1.add(&quot; &quot;);
        Collections.copy(list1, list);
        System.out.println(list1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new ArrayList(4)&lt;/code&gt; 只是设置初始容量（&lt;code&gt;capacity&lt;/code&gt;），但 &lt;code&gt;size()&lt;/code&gt; 仍然是 0。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;list1.add(&quot; &quot;)&lt;/code&gt; 后，&lt;code&gt;list1.size()&lt;/code&gt; 变为 1，但 &lt;code&gt;list.size()&lt;/code&gt; 是 3。&lt;/p&gt;
&lt;p&gt;目标列表 &lt;code&gt;list1&lt;/code&gt; 的长度（1） &amp;lt; 源列表 &lt;code&gt;list&lt;/code&gt; 的长度（3），不满足 &lt;code&gt;copy()&lt;/code&gt; 的条件。&lt;/p&gt;
&lt;h4&gt;replaceAll（List list， Object oldVal， Object newVal）&lt;/h4&gt;
&lt;p&gt;使用新值替换所有旧值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(&quot;BFXC&quot;);
        list.add(&quot;A&quot;);
        list.add(&quot;A&quot;);
        Collections.replaceAll(list, &quot;A&quot;, &quot;B&quot;);
        System.out.println(list);//[B, BFXC, B, B]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;简答题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/92.png&quot; alt=&quot;92&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>自学第一月份总结</title><link>https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E8%87%AA%E5%AD%A6%E7%AC%AC%E4%B8%80%E6%9C%88%E4%BB%BD%E6%80%BB%E7%BB%93/</guid><description>收获多多</description><pubDate>Tue, 01 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;自学第一月份总结&lt;/h1&gt;
&lt;p&gt;​	还是过的挺快的，从三月初决定不再考研开始，我投入了大量的时间去巩固Java的基础，也刷了很少的一部分面试算法题目，回顾了一些来自于之前课堂上的知识，例如操作系统，计算机网络等。&lt;/p&gt;
&lt;p&gt;​	也是在这一个月中很幸运的收到了来自第一份正式的面试邀约，无论结果如何，都对我是一次很好的锻炼机会吧。我也明白，虽然自身能力目前还达不到找到工作的水准，但是我知道自己也是在不断地向前走的，回过来看一看我自己，相比刚来到大学的时候的青涩，不敢勇于表达而言，我在面试中可以较为完整的表达出来自自己的一些观点，有着自己的一些思考，算是不错的进步了。&lt;/p&gt;
&lt;p&gt;​	从计划而言，原先的Java30天速成的计划可能得向后延期了，因为我发现，除了我原先想的知识以外，还有很多实用的Java外知识等着我去学习，如MySQL数据库，SQL注入，JDBC，正规式等要学完这一些，得再加上15天的时间，哎，总之继续努力吧。&lt;/p&gt;
&lt;p&gt;​	在课余上，买了把吉他，天天都会把自己折磨的有点手疼，进步也是蛮快的，15天左右了，练了些基础上的内容，拿着变调夹也可以弹一些简单的安河桥之类的，晴天前奏（学会扫弦还不大可能）&lt;/p&gt;
&lt;p&gt;​	感觉还是非常充实的一个月，收获很大，也有按时吃早餐，但是早睡是不可能的，最起码得留点时间给辛苦一天自己玩。&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8801/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%8801/</guid><description>集合第一部分</description><pubDate>Tue, 01 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;集合&lt;/h2&gt;
&lt;h3&gt;集合框架体系&lt;/h3&gt;
&lt;p&gt;（要求记忆）&lt;/p&gt;
&lt;p&gt;单列集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/90.png&quot; alt=&quot;90&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Collection下有两大重要的接口一个List另一个为Set&lt;/p&gt;
&lt;p&gt;双列集合&lt;/p&gt;
&lt;p&gt;存放的是K-V&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/91.png&quot; alt=&quot;91&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Map接口下有三个重要的类Hashtable ，HashMap ， TreeMap&lt;/p&gt;
&lt;p&gt;两个集合不同区别，存放数据的个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        //单列集合
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;A&quot;);
        arrayList.add(&quot;B&quot;);
        arrayList.add(&quot;C&quot;);
	    //双列集合
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;1&quot;, &quot;北京&quot;);
        hashMap.put(&quot;2&quot;, &quot;北京&quot;);
        hashMap.put(&quot;3&quot;, &quot;北京&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;产生原因&lt;/h3&gt;
&lt;p&gt;为什么要学习集合，是因为数组的灵活性不够&lt;/p&gt;
&lt;p&gt;数组的不足：&lt;/p&gt;
&lt;p&gt;1.数组长度没有办法扩容&lt;/p&gt;
&lt;p&gt;2.保存的数据使用一类型（虽然可以使用多态）&lt;/p&gt;
&lt;p&gt;3.使用数组进行增加和删除的时候比较麻烦（要创建新的数组依次拷贝）&lt;/p&gt;
&lt;p&gt;而集合上而言&lt;/p&gt;
&lt;p&gt;1.它可以动态保存任意多个对象，使用方便&lt;/p&gt;
&lt;p&gt;2.提供了一系列方便的操作对象的方法实现增删改查&lt;/p&gt;
&lt;p&gt;3.使用了集合添加元素简单明了&lt;/p&gt;
&lt;h2&gt;Collection接口&lt;/h2&gt;
&lt;p&gt;单列集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/90.png&quot; alt=&quot;90&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Collection下有两大重要的接口一个List另一个为Set&lt;/p&gt;
&lt;h3&gt;接口特点&lt;/h3&gt;
&lt;p&gt;1.Collection实现子类可以存放多个元素，每个元素可以是Object（多态）&lt;/p&gt;
&lt;p&gt;2.有的Collection接口的实现类可以放重复元素（List，Queue），而有的不可以放重复元素（Set）&lt;/p&gt;
&lt;p&gt;3.Collection的实现类中，有的保持插入顺序（List），有的不保证顺序（如 HashSet），还有的会自动排序（如 TreeSet PriorityQueue）&lt;/p&gt;
&lt;p&gt;4.Collection接口没有直接实现的子类，而是通过子接口Set和List来实现&lt;/p&gt;
&lt;h3&gt;Collection中常用的方法&lt;/h3&gt;
&lt;p&gt;以ArrayList演示&lt;/p&gt;
&lt;h4&gt;add添加元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list);//[A, 10, true]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;remove删除元素&lt;/h4&gt;
&lt;p&gt;传入元素&lt;/p&gt;
&lt;p&gt;List中删除数字类型的元素得创建包装类去删除，否则会删除对应下标的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        list.remove(2);//删除true通过下标删除
        list.remove(new Integer(10));
        System.out.println(list);//[A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;contains存在性&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        System.out.println(list.contains(15));//false
        //System.out.println(list);//[A]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;size获取元素个数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list.size());//3
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;isEmpty判断是否为空&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        System.out.println(list.isEmpty());//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;clear清空集合&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类
        list.clear();
        list.add(&quot;B&quot;);
        System.out.println(list);//[B]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;addAll添加多个元素&lt;/h4&gt;
&lt;p&gt;可以传入集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        List list2 = new ArrayList();
        list2.add(&quot;B&quot;);
        list2.add(&quot;C&quot;);

        list.addAll(list2);
        System.out.println(list);//[A, 10, true, B, C]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;removeAll删除多个元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);//在放整数的过程中会装入包装类
        list.add(true);//在放boolean的过程中会装入包装类

        List list2 = new ArrayList();
        list2.add(&quot;A&quot;);
        list2.add(10);

        list.removeAll(list2);
        System.out.println(list);//[true]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Collection遍历方式&lt;/h2&gt;
&lt;h3&gt;迭代器&lt;/h3&gt;
&lt;p&gt;Iterator对象，可以用它进行元素遍历，而Collection接口实现了Iterator，所以只要是实现了Collection接口的子类都可以获取一个迭代器Iterator() 遍历元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {
    boolean hasNext();
    E next();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;next用于返回元素然后下移，而hasNext方法要求实现有下一个元素返回true，在子类的实现中应该在next前加上hasNext的判断条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);

        Iterator it = list.iterator();//获取迭代器
        while (it.hasNext()) {
            Object next = it.next();
            System.out.print(next + &quot; &quot;);//A 10 true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在IDEA中可以使用 itit 模板补全迭代器while循环&lt;/p&gt;
&lt;p&gt;当我们需要再次遍历的时候我们需要重置迭代器(将指针指向开头)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Iterator it = list.iterator();//获取迭代器
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增强for循环&lt;/h3&gt;
&lt;p&gt;底层是迭代器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;A&quot;);
        list.add(10);
        list.add(true);
        for (Object o : list) {
            System.out.print(o + &quot; &quot;);//A 10 true 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试步骤&lt;/p&gt;
&lt;p&gt;用IDEA就可以使用快捷补全 大写的 I&lt;/p&gt;
&lt;p&gt;1.先获取迭代器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
    return new Itr();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断有下一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean hasNext() {
    return cursor != size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.获取并指向下一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public E next() {
    checkForComodification();
    int i = cursor;
    if (i &amp;gt;= size)
        throw new NoSuchElementException();
    Object[] elementData = ArrayList.this.elementData;
    if (i &amp;gt;= elementData.length)
        throw new ConcurrentModificationException();
    cursor = i + 1;
    return (E) elementData[lastRet = i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在数组上使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        for(int o : array) {
            System.out.print(o + &quot; &quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;List接口&lt;/h2&gt;
&lt;h3&gt;List接口特点&lt;/h3&gt;
&lt;p&gt;Set接口的子类（HashSet，TreeSet）无法使用这些方法&lt;/p&gt;
&lt;p&gt;而List接口子类Vector， ArrayList ， LinkedList可以使用List接口方法&lt;/p&gt;
&lt;p&gt;List集合中的元素有序（添加和取出顺序一致），元素可以重复，支持索引获取&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;get获取元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.add(&quot;jack&quot;);
        System.out.println(list);
        //[jack, tom, marry, lory, jack]
        System.out.println(list.get(3));//lory
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;add插入元素&lt;/h4&gt;
&lt;p&gt;默认插入到元素末尾，可以添加索引指定插入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.add(&quot;jack&quot;);
        System.out.println(list);
        //[jack, tom, marry, lory, jack]
        list.add(2, &quot;funny&quot;);
        System.out.println(list);
        //[jack, tom, funny, marry, lory, jack]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;addAll插入集合&lt;/h4&gt;
&lt;p&gt;默认插入集合尾部&lt;/p&gt;
&lt;p&gt;传入索引 加 集合，可以在指定位置插入多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);

        List list1 = new ArrayList();
        list1.add(&quot;杰克&quot;);
        list1.add(&quot;杰瑞&quot;);

        list.addAll(1, list1);
        System.out.println(list);
        [jack, 杰克, 杰瑞, tom, marry, lory]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index Of与 lastIndexOf 和数组类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);

        System.out.println(list.indexOf(&quot;jack&quot;));//0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;set 替换元素&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        System.out.println(list);
        //[tom, tom, marry, lory]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;subList 返回子集合&lt;/h4&gt;
&lt;p&gt;左闭右包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        System.out.println(list.subList(1, 3));
        //[tom, marry]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了迭代器遍历，增强for循环，ArrayList由于底层是数组实现，我们还可以通过普通的for循环遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class List01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;jack&quot;);
        list.add(&quot;tom&quot;);
        list.add(&quot;marry&quot;);
        list.add(&quot;lory&quot;);
        list.set(0, &quot;tom&quot;);
        for(int i = 0; i &amp;lt; list.size(); i++) {
            Object o = list.get(i);
            System.out.println(o);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题（按年龄集合排序）&lt;/p&gt;
&lt;p&gt;我自己做的时候是将集合转为数组，用数组自定义排序，再放回集合，但是有些复杂了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Collection_ {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(new Dog(&quot;旺财&quot;, 19));
        list.add(new Dog(&quot;来福&quot;, 12));
        list.add(new Dog(&quot;小黑&quot;, 13));
        list = sortList(list);
        System.out.println(list);
    }

    public static List sortList(List list) {
        Dog[] array = new Dog[list.size()];
        for (int i = 0; i &amp;lt; list.size(); i++) {
            Dog d = (Dog)list.get(i);
            array[i] = d;
        }

        Arrays.sort(array, new Comparator() {
            public int compare(Object o1, Object o2) {
                Dog d1 = (Dog)o1;
                Dog d2 = (Dog)o2;
                return d1.age - d2.age;
            }
        });

        list.clear();
        for (int i = 0; i &amp;lt; array.length; i++) {
            list.add(array[i]);
        }
        return list;
    }
}

class Dog {
    String name;
    int age;

    Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot; Dog &quot; + name + &quot; are &quot; + age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用标准的冒泡排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void sortList(List list) {
    int size = list.size();
    for (int i = 0; i &amp;lt; size - 1; i++) {
        for (int j = 0; j &amp;lt; size - i - 1; j++) {
            Dog dog1 = (Dog) list.get(j);
            Dog dog2 = (Dog) list.get(j + 1);
            if(dog1.age &amp;gt; dog2.age) {
                list.set(j, dog2);
                list.set(j + 1, dog1);                }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为都是List的子类，所以方法可以传入Vector ArrayList LinkedList&lt;/p&gt;
&lt;h2&gt;List子类&lt;/h2&gt;
&lt;h3&gt;ArrayList使用注意事项&lt;/h3&gt;
&lt;p&gt;1.ArrayList中可以放入null，而且是多个&lt;/p&gt;
&lt;p&gt;2.ArrayList是由数组来实现数据存储的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Object[] elementData;
private int size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.ArrayList基本上等同于Vector，除了ArrayList是线程不安全的（但是执行效率高）&lt;/p&gt;
&lt;p&gt;它的方法没有synchronized关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而Vector是有的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ArrayList的底层机制&lt;/h3&gt;
&lt;h4&gt;扩容流程&lt;/h4&gt;
&lt;p&gt;1.ArrayList中维护了一个Object类型的数组elementData&lt;/p&gt;
&lt;p&gt;其中transient（短暂的），表示该属性不会被序列化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transient Object[] elementData;
private int size
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当创建ArrayList对象的时候，如果使用的是无参构造器，则出事的elementData容量为0，当第一次添加的时候，扩容10，再次扩容扩容原来的1.5倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    //这是个空数组
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.如果是使用指定大小的构造器，则初始elementData容量为指定大小，扩容扩容原来的1.5倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList(int initialCapacity) {
    if (initialCapacity &amp;gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;底层扩容机制&lt;/h4&gt;
&lt;p&gt;建议自己去Debug追一下&lt;/p&gt;
&lt;p&gt;当添加的时候会调用ensureCapacityInternal&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 当容量不够的时候才调用grow
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;底层判断容量不够时扩容的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    //这里就是1.5被扩容
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    //如果是为0，就会赋初值10
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
    //将调用Arrays进行赋值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Vector使用注意事项&lt;/h3&gt;
&lt;p&gt;1.定义继承于AbstractList抽象类，实现了 List&amp;lt;E&amp;gt;, RandomAccess, Cloneable接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Vector&amp;lt;E&amp;gt;
    extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.底层也是维护了一个对象数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Object[] elementData;
protected int elementCount;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.Vector是线程同步的，操作的方法带有synchronized，所以在多线程并发的时候需要使用Vector而不是ArrayList，除非只有一个线程来操作该数据，可以使用ArrayList提高效率（不需要进行线程安全的检查）&lt;/p&gt;
&lt;h3&gt;Vector的扩容机制&lt;/h3&gt;
&lt;p&gt;这里不再过多的重复，大体跟ArrayList类似，只是后续扩容更改为两倍扩容&lt;/p&gt;
&lt;h3&gt;LinkedList使用注意事项&lt;/h3&gt;
&lt;p&gt;1.LinkedList底层实现了双向链表和双端队列特点&lt;/p&gt;
&lt;p&gt;2.可以添加任意元素（元素可以重复）包括null&lt;/p&gt;
&lt;p&gt;3.线程不安全，没有实现同步&lt;/p&gt;
&lt;h3&gt;双端队列补充知识&lt;/h3&gt;
&lt;p&gt;双端队列(Deque, Double Ended Queue)允许在队列的两端进行插入和删除操作，这为&lt;code&gt;LinkedList&lt;/code&gt;带来了以下优势&lt;/p&gt;
&lt;h3&gt;两端操作能力&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;头部操作&lt;/strong&gt;：可以在列表开头高效地添加/删除元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.addFirst(e);  // 或 offerFirst(e)
list.removeFirst(); // 或 pollFirst()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;尾部操作&lt;/strong&gt;：可以在列表末尾高效地添加/删除元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.addLast(e);  // 或 offerLast(e)
list.removeLast(); // 或 pollLast()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实现多种数据结构&lt;/h3&gt;
&lt;p&gt;利用双端队列特性，&lt;code&gt;LinkedList&lt;/code&gt;可以轻松模拟：&lt;/p&gt;
&lt;p&gt;栈(Stack)：后进先出(LIFO)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Deque&amp;lt;String&amp;gt; stack = new LinkedList&amp;lt;&amp;gt;();
stack.push(&quot;A&quot;); // 压栈
stack.pop();     // 弹栈
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;队列(Queue)：先进先出(FIFO)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
queue.offer(&quot;A&quot;); // 入队
queue.poll();     // 出队
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;学过数据结构的可以直接跳过这一个部分&lt;/p&gt;
&lt;p&gt;可以直接去构造这么一个链表节点，实现一些方法去输出链表，添加节点，删除节点等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Node {
    public Node next;
    public Node prev;
    public Object item;

    public Node(Object item) {
        this.item = item;
    }

    public void addNode(Node newNode) {
        this.next = newNode;
        newNode.prev = this;
    }

    public void printNode() {
        Node Point = this;
        while(Point != null) {
            System.out.println(Point.item);
            Point = Point.next;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;底层源码中我们在添加的时候会创建新的链表结点，然后运用前后引用连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    linkLast(e);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;void linkLast(E e) {
    final Node&amp;lt;E&amp;gt; l = last;
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;LinkedList和ArrayList的比较&lt;/h3&gt;
&lt;p&gt;1.在维护的数据结构上而言，前者是双向链表，而后者是数组&lt;/p&gt;
&lt;p&gt;2.在增删的效率上而言LinkedList高于ArrayList&lt;/p&gt;
&lt;p&gt;3.在改查的效率上而言LinkedList低于于ArrayList&lt;/p&gt;
&lt;p&gt;结论：在一般的情况下程序中80%-90%的操作都是查询，大多数选的是ArrayList，也可以根据需要使用LinkedList&lt;/p&gt;
&lt;h2&gt;Set接口&lt;/h2&gt;
&lt;h3&gt;set接口特点&lt;/h3&gt;
&lt;p&gt;1.无序（添加和取出的顺序不一致），没有索引，无法通过索引来操作&lt;/p&gt;
&lt;p&gt;2.不允许重复元素，最多包含有一个null&lt;/p&gt;
&lt;p&gt;3.Set接口类常用的有两个TreeSet，HashSet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(null);
        System.out.println(set);//[null, world, hello]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里看到虽然加入了两个hello world，但是只存放了一个，而且输出的顺序和放入的不一致（但是输出的顺序是同一个不会因为再次输出而改变）&lt;/p&gt;
&lt;p&gt;可以通过两种方式遍历（迭代器和增强for循环）&lt;/p&gt;
&lt;p&gt;但是不可以使用for循环，因为没有办法使用get用索引找到对应元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        set.add(null);
        Iterator iterator = set.iterator();
        while(iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println(obj);
        }

        for(Object obj : set) {
            System.out.println(obj);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Set子类&lt;/h2&gt;
&lt;h3&gt;HashSet说明&lt;/h3&gt;
&lt;p&gt;1.HashSet实现了Set接口&lt;/p&gt;
&lt;p&gt;2.HashSet实际上是HashMap&lt;/p&gt;
&lt;p&gt;3.可以存放null，但只能有一个null&lt;/p&gt;
&lt;p&gt;4.HashSet不保证元素有序，取决于hash后确定的索引结果&lt;/p&gt;
&lt;p&gt;5.不能有重复的对象&lt;/p&gt;
&lt;p&gt;在add添加元素的时候会返回一个boolean值，当添加成功的时候会返回一个true&lt;/p&gt;
&lt;p&gt;，当添加失败的时候返回一个false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SetMethod {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(&quot;hello&quot;);
        set.add(&quot;world&quot;);
        System.out.println(set.add(&quot;hello&quot;));
        //添加失败，添加的是同一个字符串常量
        
        set.add(new Student());
        System.out.println(set.add(new Student()));
        //在这里添加的是不同的对象，所以可以添加成功
        set.add(null);
        System.out.println(set);
    }
}

class Student {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;false
true
[null, world, com.Student@74a14482, com.Student@4554617c, hello]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HashSet的底层机制&lt;/h3&gt;
&lt;p&gt;HashSet的底层是HashMap而，HashMap的底层是（数组+链表+红黑树）&lt;/p&gt;
&lt;h4&gt;模拟简单的HashSet&lt;/h4&gt;
&lt;p&gt;在讲解底层机制之前我们先去模拟一下简单的数组+链表结构（忽略到达一定程度分为红黑树）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HashSetStructure {
    public static void main(String[] args) {
        //模拟一个HashSet的底层（HashMap）
        Node[] table = new Node[16];

        Node john = new Node(&quot;John&quot;, null);
        table[2] = john;//将John添加到table数组中
        Node jane = new Node(&quot;Jane&quot;, null);
        john.next = jane;//将jane添加到john后
        Node rose = new Node(&quot;Rose&quot;, null);
        jane.next = rose;//将rose添加到jane后

        Node Lucy = new Node(&quot;Lucy&quot;, null);
        table[5] = Lucy;//将Lucy添加到table数组中
    }
}

class Node { //节点，存储数据，可以指向下一个节点，形成链表
    Object item;
    Node next;

    public Node(Object item, Node next) {
        this.item = item;
        this.next = next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HashSet底层添加元素&lt;/h4&gt;
&lt;p&gt;1.当添加一个元素的时候会先得到hash值，而又会将hash值转为索引值&lt;/p&gt;
&lt;p&gt;2.找到存储的table表，通过这个索引位置看是否有元素以及被放入&lt;/p&gt;
&lt;p&gt;3.如果没有就将该元素放入table表中&lt;/p&gt;
&lt;p&gt;4.有的话先调用equals进行比较，如果相同就放弃添加，并返回false，不相同就将该元素放入链表最后&lt;/p&gt;
&lt;p&gt;5.在Java8中，一条链表中的元素个数大于等于上限（8），并且table的大小大于等于阈值（64）就会将链表树化（红黑树）&lt;/p&gt;
&lt;p&gt;HashSet创建添加元素（Debug调试）&lt;/p&gt;
&lt;p&gt;首先先创建一个HashMap结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public HashSet() {
    map = new HashMap&amp;lt;&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在添加元素的时候调用add添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入的是key值以及value，而hash方法会根据key调用HashCode创建一个值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    //不完全是哈希值，而是一个算法（h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16）
    //尽量哈希值不会碰撞
    //h ^ (h &amp;gt;&amp;gt;&amp;gt; 16) 的目的是让哈希值的高位信息影响低位，减少哈希冲突。

//这样即使 HashMap 的数组长度 n 较小，也能让 key 分布更均匀，提高查询效率。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回HashCode的一个编码后，会进入正真扩容存放节点的方法，我用AI添加了一些注释用于辅助理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    // 定义局部变量
    Node&amp;lt;K,V&amp;gt;[] tab;  // 哈希表数组
    Node&amp;lt;K,V&amp;gt; p;      // 当前节点
    int n, i;         // n: 数组长度，i: 计算出的索引位置
    
    // 步骤1：初始化哈希表（如果是第一次添加元素）
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;  // 调用resize()初始化表，默认大小16
    
    // 步骤2：计算索引位置并处理空桶情况
    // (n-1) &amp;amp; hash 相当于 hash % n，但效率更高
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);  // 空桶直接创建新节点
    else {
        // 步骤3：处理哈希冲突情况
        Node&amp;lt;K,V&amp;gt; e;  // 用于临时存储已存在的节点
        K k;          // 临时存储键
        
        // 情况3.1：检查第一个节点是否就是要找的键
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;  // 找到相同key的节点
            
        // 情况3.2：如果是树节点，调用树的插入方法
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            
        // 情况3.3：链表遍历查找
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 到达链表末尾，添加新节点
                    p.next = newNode(hash, key, value, null);
                    
                    // 检查是否需要树化（链表长度&amp;gt;=8）
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // TREEIFY_THRESHOLD=8
                        treeifyBin(tab, hash);  // 转换为红黑树
                    break;
                }
                
                // 检查当前节点是否是要找的键
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                    
                p = e;  // 移动到下一个节点
            }
        }
        
        // 步骤4：处理键已存在的情况
        if (e != null) { // 已存在相同key的映射
            V oldValue = e.value;
            // onlyIfAbsent为false或原值为null时才更新
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);  // 用于LinkedHashMap的回调
            return oldValue;     // 返回旧值
        }
    }
    
    // 步骤5：更新修改计数和检查扩容
    ++modCount;  // 并发修改检查计数器
    
    // 检查是否超过阈值需要扩容
    if (++size &amp;gt; threshold)  // threshold=容量*负载因子(默认0.75)
        resize();
        
    afterNodeInsertion(evict);  // 用于LinkedHashMap的回调
    
    return null;  // 新增节点返回null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中判断是否扩容的条件是用resize方法实现的，其中涉及到了一个扩容因子为0.75，当达到这个容量的时候就会去进行一个容的扩（*2）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else {       
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HashSet实践&lt;/h3&gt;
&lt;p&gt;放入自定义类，并判断当属性和Set中的某一个元素相同的时候，添加失败，返回false&lt;/p&gt;
&lt;p&gt;以下是我第一次碰见这道题目的解决方式（有些复杂）&lt;/p&gt;
&lt;p&gt;由于这里不同创建的对象有着相同的属性，而set.add中所判断的是HashCode从而判断这是两个不同的元素，我们需要重新创建添加方法&lt;/p&gt;
&lt;p&gt;我在这里建立了三个方法，其中的类方法是重写了equals方法使其判断两个员工类的属性是一致的，而在两个静态方法中，addSet调用了contains方法去判断在set中是否有和待添加的元素属性相同的元素，有则不添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HomeWork {
    public static void main(String[] args) {
        Set set = new HashSet();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        addSet(person1, set);
        addSet(person2, set);
        addSet(person3, set);
        System.out.println(set.size());
    }

    public static boolean addSet(Object o, Set set) {
        if (contains(o, set)) {
            return false;
        }
        set.add(o);
        return true;
    }

    public static boolean contains(Object o, Set set) {
        Employee person = (Employee) o;
        Iterator it = set.iterator();
        while (it.hasNext()) {
            Employee temp = (Employee) it.next();
            if(person.equals(temp)) {
                return true;
            }
        }
        return false;
    }
}


class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Employee) {
            Employee temp = (Employee) o;
            if(temp.name == this.name &amp;amp;&amp;amp; temp.age == this.age) {
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而标准的方式则是去重写hashCode的一个方法，在hashCode中去调用一个Objects的方法hash(name, age)，传入name和age，当数据相等的时候，返回的哈希值就是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

public class HomeWork {
    public static void main(String[] args) {
        Set set = new HashSet();
        Employee person1 = new Employee(&quot;黎明&quot;, 18);
        Employee person2 = new Employee(&quot;丽丽&quot;, 11);
        Employee person3 = new Employee(&quot;黎明&quot;, 18);
        set.add(person1);
        set.add(person2);
        set.add(person3);
        System.out.println(set.size());
    }

}

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Employee) {
            Employee temp = (Employee) o;
            if(temp.name == this.name &amp;amp;&amp;amp; temp.age == this.age) {
                return true;
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于 &lt;code&gt;Arrays.hashCode(Object[])&lt;/code&gt;，遍历字段并合并哈希，必须保证 &lt;code&gt;equals()&lt;/code&gt; 相同的对象，&lt;code&gt;Objects.hash()&lt;/code&gt; 结果相同&lt;/p&gt;
&lt;h3&gt;LinkedHashSet&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class LinkedHashSet&amp;lt;E&amp;gt;
    extends HashSet&amp;lt;E&amp;gt;
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.是HashSet的子类，同时也实现了Set接口&lt;/p&gt;
&lt;p&gt;2.LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表&lt;/p&gt;
&lt;p&gt;3.LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时用链表维护元素的次序，使得元素在看起来是以插入顺序保存的&lt;/p&gt;
&lt;p&gt;4.LinkedHashSet不允许添加重复元素&lt;/p&gt;
&lt;p&gt;其中存储的节点继承于HashMapNode，名为Entry是一个内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
    Entry&amp;lt;K,V&amp;gt; before, after;
    Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
        super(hash, key, value, next);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中维护了先后引用用于，达到顺序输出的效果&lt;/p&gt;
&lt;h3&gt;TreeSet&lt;/h3&gt;
&lt;p&gt;通过传入一个Comparator接口可以实现有序的排序（可自定义）&lt;/p&gt;
&lt;p&gt;注意这里如果不传入Comparator就会将添加入的对象转为Comparable类型，如果这个类型没有实现Comparable接口的话就会发生异常，抛出错误ClassCastExceprion&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TreeSet01 {
    @SuppressWarnings({&quot;all&quot;})
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            public int compare(Object o1, Object o2) {
                String s1 = (String)o1;
                String s2 = (String)o2;
                return s1.compareTo(s2);
            }
        });
        treeSet.add(&quot;jack&quot;);
        treeSet.add(&quot;ae&quot;);
        treeSet.add(&quot;jille&quot;);
        treeSet.add(&quot;band&quot;);
        System.out.println(treeSet);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0matharrayssystem%E5%A4%A7%E6%95%B0%E5%A4%84%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0matharrayssystem%E5%A4%A7%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>Math，Arrays，System，大数处理</description><pubDate>Mon, 31 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;Math&lt;/h2&gt;
&lt;p&gt;Math类包含了执行基本数学运算的方法，如初等函数，对数，平方根，三角函数&lt;/p&gt;
&lt;h3&gt;常用的方法&lt;/h3&gt;
&lt;h4&gt;abs求绝对值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.abs(-123));//123
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;pow求幂&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.pow(2, 4));//16.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;ceil向上取整&lt;/h4&gt;
&lt;p&gt;返回大于等于这个数的最小整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.ceil(20.2));//21.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;floor向上取整&lt;/h4&gt;
&lt;p&gt;返回小于等于这个数的最大整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.floor(20.2));//20.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;round四舍五入&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.round(20.35));//20.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sqrt开方&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.sqrt(9));//3.0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;random随机数&lt;/h4&gt;
&lt;p&gt;返回一个[0,1)之间的随机小数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.random());//0.8490844298476015
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2-7之间的随机整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        //Math.random() * x 返回了一个数[0, x)
        //Math.random() * 5 返回了[0, 5),
        System.out.println(Math.random() * 5 + 2);//[2,7)
        System.out.println((int)(Math.random() * 6 + 2));//2-7的整数
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;max和min&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Math01 {
    public static void main(String[] args) {
        System.out.println(Math.max(1, 2));//2
        System.out.println(Math.min(1, 2));//1
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Arrays&lt;/h2&gt;
&lt;p&gt;包含了一系列的静态方法，用于管理和操作数组（例如排序和搜索）&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;h4&gt;toString方法&lt;/h4&gt;
&lt;p&gt;返回一个字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(Arrays.toString(arr));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;sort排序&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;binarySearch二分查找&lt;/h4&gt;
&lt;p&gt;要求排序，找不到返回-(low + 1)，表示如果存在应该在的地方&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(Arrays.binarySearch(arr, 5));//4
        System.out.println(Arrays.binarySearch(arr, 15));//-10
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;copyOf拷贝数组&lt;/h4&gt;
&lt;p&gt;拷贝arr的3个数，如果长度大于arr的length，多的int用0填充，Integer用null填充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int[] arrNew = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(arrNew));//[1, 2, 3]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        Integer[] arrNew = Arrays.copyOf(arr, 11);
        System.out.println(Arrays.toString(arrNew));
        //[1, 2, 3, 4, 5, 6, 7, 8, 9, null, null]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;fill数组填充&lt;/h4&gt;
&lt;p&gt;用后面的数填充整个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        Arrays.fill(arr, 4);
        System.out.println(Arrays.toString(arr));//[4, 4, 4]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;equals比较数组元素&lt;/h4&gt;
&lt;p&gt;注意与直接使用arr.equals(arr2)区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        Integer[] arr2 = {1, 2, 3};
        System.out.println(Arrays.equals(arr, arr2));//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;asList将一组值转为list&lt;/p&gt;
&lt;p&gt;将数组转为一个asList集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3};
        List asList = Arrays.asList(arr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;定制排序及其底层实现&lt;/h3&gt;
&lt;p&gt;额外的，我们可以传入一个匿名内部类，定制排序&lt;/p&gt;
&lt;p&gt;匿名内部类，动态绑定，接口编程的组合可以在编程的时候变得非常灵活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Integer[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        Arrays.sort(arr, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                Integer i1 = (Integer) o1;
                Integer i2 = (Integer) o2;
                return i2 - i1;
            }
        });
        System.out.println(Arrays.toString(arr));
        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在底层的代码中会执行我们实现的匿名内部类，从而影响内部逻辑，改变排序顺序（有兴趣的可以通过断点调试去试一试）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(T[] a, Comparator&amp;lt;? super T&amp;gt; c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...... 这里省略了一些调用过程，下面是类c的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (left &amp;lt; right) {
    int mid = (left + right) &amp;gt;&amp;gt;&amp;gt; 1;
    if (c.compare(pivot, a[mid]) &amp;lt; 0)//这里的c就是我们实现接口的类
        right = mid;
    else
        left = mid + 1;
}
assert left == right;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;模拟底层排序&lt;/h3&gt;
&lt;p&gt;我们也可以自己来模拟以下底层的排序，以下是以往的自定义方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] a) {
        for(int i = 0; i &amp;lt; a.length - 1; i++) {
            for(int j = 0; j &amp;lt; a.length - i - 1; j++) {
                if(a[j] &amp;gt; a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现定制排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        int[] arr = {2, 1, 3, 8, 5, 6, 7, 4, 10, 9};
        bubbleSort(arr, new Comparator() {
            public int compare(Object o1, Object o2) {
                int i1 = (Integer)o1;
                int i2 = (Integer)o2;
                return i2 - i1;
            }
        });
        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] a, Comparator c) {
        for (int i = 0; i &amp;lt; a.length - 1; i++) {
            for (int j = 0; j &amp;lt; a.length - i - 1; j++) {
                if (c.compare(a[j], a[j + 1]) &amp;gt; 0) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实一般限定的也比较死，都是i2 - i1是从大到小，反之亦然&lt;/p&gt;
&lt;p&gt;一个书本排序的案例（按照价格从大到小）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Arrays01 {
    public static void main(String[] args) {
        Book[] books = new Book[4];
        books[0] = new Book(&quot;爱丽丝&quot;, 1);
        books[1] = new Book(&quot;齐欢乐&quot;, 12);
        books[2] = new Book(&quot;英雄联盟&quot;, 123);
        books[3] = new Book(&quot;王者荣耀&quot;, 14);
        System.out.println(&quot;排序前&quot;);
        printBooks(books);
        Arrays.sort(books, new Comparator() {
            public int compare(Object o1, Object o2) {
                Book b1 = (Book) o1;
                Book b2 = (Book) o2;
                return b2.price - b1.price;
            }
        });
        System.out.println(&quot;排序后&quot;);
        printBooks(books);
    }

    public static void printBooks(Book[] books) {
        for (Book book : books) {
            System.out.println(book.price + &quot; &quot; + book.name);
        }
    }
}
class Book {
    String name;
    int price;

    public Book(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照名字长度从大到小，自定义排序用匿名类重写compare即可&lt;/p&gt;
&lt;p&gt;因为sort传入的是泛型，我们只需要重写接口的compare方法改为我们需要使用到的排序属性做一个相减比较即可实现类数组的排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Arrays.sort(books, new Comparator() {
    public int compare(Object o1, Object o2) {
        Book b1 = (Book) o1;
        Book b2 = (Book) o2;
        return b2.name.length() - b1.name.length();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;System&lt;/h2&gt;
&lt;h3&gt;System常见的方法&lt;/h3&gt;
&lt;h4&gt;exit&lt;/h4&gt;
&lt;p&gt;退出当前程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        System.exit(0);//程序退出，0代表正常退出
        System.out.println(&quot;continue...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;arraycopy&lt;/h4&gt;
&lt;p&gt;复制数组元素copyOf调用的底层就是这个方法&lt;/p&gt;
&lt;p&gt;Arrays中的&lt;/p&gt;
&lt;p&gt;第一个参数表示拷贝源，第二个为源开始拷贝的下表
第三个参数表示拷贝目标，第四个为源开始复制的下表
第五个表示拷贝的长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        int[] src = {1, 3, 4};
        int[] newSrc = new int[src.length];
        System.arraycopy(src, 0, newSrc, 1, 2);
        System.out.println(Arrays.toString(newSrc));
        //[0, 1, 3]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;currentTimeMillens&lt;/h4&gt;
&lt;p&gt;返回当前时间距离1970-1-1的毫秒数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class System01 {
    public static void main(String[] args) {
        System.out.println(System.currentTimeMillis());
        //1743413461175
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;gc&lt;/h4&gt;
&lt;p&gt;运行垃圾回收机制（非阻塞）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.gc();//主动调用回收器
        System.out.println(&quot;代码结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;大数处理&lt;/h2&gt;
&lt;h3&gt;BigInteger&lt;/h3&gt;
&lt;p&gt;比较适合保存较大的整形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在进行BigInteger的加减乘除的时候需要使用对应方法(加减乘除)&lt;/p&gt;
&lt;p&gt;add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.add(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subtract&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.subtract(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;divide&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.divide(biginteger);
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;multiply&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigInteger biginteger = new BigInteger(&quot;1234567893242342235233253532532&quot;);
        biginteger = biginteger.multiply(BigInteger.valueOf(2));
        System.out.println(biginteger);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BigDecimal&lt;/h3&gt;
&lt;p&gt;适合保存精度更高的浮点型（小数）&lt;/p&gt;
&lt;p&gt;方法同理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigDecimal big = new BigDecimal(&quot;1.0000003982039023029309239203992032093&quot;);
        BigDecimal big2 = new BigDecimal(&quot;121.333&quot;);
        big = big.add(big2);
        System.out.println(big);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在作除法的时候可能会抛出除不尽的异常&lt;/p&gt;
&lt;p&gt;可以通过以下调用divide方法时指定精度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BigInteger_ {
    public static void main(String[] args) {
        BigDecimal big = new BigDecimal(&quot;1.0000003982039023029309239203992032093&quot;);
        BigDecimal big2 = new BigDecimal(&quot;121.333&quot;);
        big = big.divide(big2, BigDecimal.ROUND_CEILING);
        //保留分子精度
        System.out.println(big);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;日期类&lt;/h2&gt;
&lt;h3&gt;Date&lt;/h3&gt;
&lt;p&gt;第一代日期类：精确到毫秒，代表特定时间，实现了比较接口，克隆接口，可序列化接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date
    implements java.io.Serializable, Cloneable, Comparable&amp;lt;Date&amp;gt;
{ ......
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;p&gt;Date无参构造器，获取当前系统时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();//获取当前系统时间
        System.out.println(d1);//默认为外国时间格式，需要转换
        //Mon Mar 31 19:56:05 CST 2025
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Date构造器传入一个long型的数（毫秒数），转为Date型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date(1341324134);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //1970年01月16日 || 08:35:24
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;SimpleDateFormat&lt;/h4&gt;
&lt;p&gt;格式和解析日期的类&lt;/p&gt;
&lt;p&gt;先定义一个日期的格式，创建sdf对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照对应格式输出时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //2025年03月31日 || 07:58:20
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将Date格式化日期转为Date&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) throws ParseException {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        Date d1 = sdf.parse(&quot;1970年01月16日 || 08:35:24&quot;);
        //需要日期格式对应，否则抛出异常
        System.out.println(d1);
        //Fri Jan 16 08:35:24 CST 1970
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Calendar&lt;/h3&gt;
&lt;p&gt;日历：第二代日期类，是一个抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Calendar implements Serializable, Cloneable, Comparable&amp;lt;Calendar&amp;gt; {...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该类的构造器添加了private无法手动创建实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/89.png&quot; alt=&quot;89&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过getInstance获取实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Calendar01 {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        System.out.println(cal.get(Calendar.YEAR));
        //2025
        System.out.println(cal.get(Calendar.MONTH) + 1);
        //3 月份需要+1，因为是由0开始编码
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有格式化输出方法，可以由自己自由定义，以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Calendar01 {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        System.out.println(formatPrint(cal));
        //2025-2-31 20:21:58
    }

    public static String formatPrint(Calendar cal) {
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH);
        int day = cal.get(Calendar.DAY_OF_MONTH);
        int hour = cal.get(Calendar.HOUR_OF_DAY);//24进制
        //12进制位HOUR
        int minute = cal.get(Calendar.MINUTE);
        int second = cal.get(Calendar.SECOND);
        return year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;第三代日期类&lt;/h3&gt;
&lt;h4&gt;引入原因&lt;/h4&gt;
&lt;p&gt;是由于前两代的不足引入的&lt;/p&gt;
&lt;p&gt;Date大多数方法在JDK1.1之后就被弃用了&lt;/p&gt;
&lt;p&gt;而Calendar类也存在一下问题&lt;/p&gt;
&lt;p&gt;可变性：日期和时间的类应该是不可变的&lt;/p&gt;
&lt;p&gt;偏移性：Date中的年份是从1900开始的，而月份是从0开始的&lt;/p&gt;
&lt;p&gt;格式化：格式化只对Date有用，Calendar不行&lt;/p&gt;
&lt;p&gt;线程安全：两者都不是线程安全的；同时不能处理闰秒（每隔2天，多1s）&lt;/p&gt;
&lt;h4&gt;第三代日期的常见的使用&lt;/h4&gt;
&lt;h5&gt;LocalDate&lt;/h5&gt;
&lt;p&gt;只包含日期，可以获取日期字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDate ldt = LocalDate.now();
        System.out.println(ldt);//2025-03-31
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;LocalTime&lt;/h5&gt;
&lt;p&gt;只包含时间，可以获取时间字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalTime ldt = LocalTime.now();
        System.out.println(ldt);//20:34:32.321
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;LocalDateTime&lt;/h5&gt;
&lt;p&gt;包含日期、时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);//2025-03-31T20:33:20.585
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;常见的方法&lt;/h4&gt;
&lt;p&gt;即查即用即可，以下是一个自定义格式代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(formatPrint(ldt));//2025-3-31
    }

    public static String formatPrint(LocalDateTime ldt) {
        int year = ldt.getYear();
        int month = ldt.getMonthValue();
        int day = ldt.getDayOfMonth();
        return year + &quot;-&quot; + month + &quot;-&quot; + day ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们可以使用DateTimeFormatter来定义&lt;/p&gt;
&lt;p&gt;类似于Date中的SimpleDateFormat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime d1 = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MM-dd-yyyy&quot;);
        System.out.println(d1.format(formatter));
        //03-31-2025
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较，前一个传入的参数是格式器，后一个传入的是日期类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Date01 {
    public static void main(String[] args) {
        Date d1 = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 || hh:mm:ss&quot;);
        System.out.println(sdf.format(d1));
        //2025年03月31日 || 07:58:20
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;时间戳与Date的转换&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        Instant instant = Instant.now();//通过now获取时间戳
        System.out.println(instant);//2025-03-31T12:47:34.897Z
        Date date = Date.from(instant);//将时间戳转为Date
        instant = date.toInstant();//将Date转为时间戳
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;时间计算&lt;/h4&gt;
&lt;p&gt;在做订单的时候比较常用&lt;/p&gt;
&lt;p&gt;可以使用plus和minus方法可以对当前时间进行加或者减&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Local01 {
    public static void main(String[] args) {
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime.minusMonths(1));
        //2025-03-30T20:53:15.177
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8C%85%E8%A3%85%E7%B1%BBstringstringbufferstringbuilder/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8C%85%E8%A3%85%E7%B1%BBstringstringbufferstringbuilder/</guid><description>包装类，String，StringBuffer，StringBuilder</description><pubDate>Fri, 28 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;包装类&lt;/h2&gt;
&lt;p&gt;Wrapper（包装器）&lt;/p&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;针对八种基本的数据类型类型响应的引用类型&lt;/p&gt;
&lt;p&gt;有类的特点，可以调用类的方法&lt;/p&gt;
&lt;p&gt;除了 int -&amp;gt; Integer char- &amp;gt; Character 其余的六个都是将首字母大写就是对应的包装类&lt;/p&gt;
&lt;p&gt;Boolean  Byte Short Long Float Double&lt;/p&gt;
&lt;p&gt;Boolean 与 Character 二者是实现了比较和可序列化的接口的Object子类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Boolean implements java.io.Serializable,
                                      Comparable&amp;lt;Boolean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class Character implements java.io.Serializable, Comparable&amp;lt;Character&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这些数字的类型一般都是继承了Number类，而Number类是实现了可序列化的接口的Object子类，数字类型直接实现比较接口&lt;/p&gt;
&lt;p&gt;图标如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/83.png&quot; alt=&quot;83&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;装箱与拆箱&lt;/h3&gt;
&lt;p&gt;自动拆装箱，本质上和手动没有区别，由编译器自动调用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        //jdk5以前是用手动装箱,拆箱
        int i = 10;
        Integer pack = new Integer(i);
        Integer pack2 = Integer.valueOf(i);

        int j = pack.intValue();//手动拆箱

        //jdk5以后支持自动拆装箱
        int k = 200;
        Integer pack3 = k;//自动装箱
        int k1 = pack3;//自动拆箱
        //本质上和手动没有区别，由编译器自动调用方法
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一道比较经典的面试题目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/84.png&quot; alt=&quot;84&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;包装类型和String转换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i = 127;
        String s1 = i + &quot;&quot;;//包装类转字符串
        String s2 = i.toString();
        /* 包装类的toString方法
        public String toString() {
                return toString(value);
            }
         */
        System.out.println(s1);

        Integer i1 = Integer.parseInt(s1);//字符串转包装类
        Integer i2 = Integer.valueOf(s1);//会调用parseInt

        System.out.println(i2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一些常用的方法&lt;/h3&gt;
&lt;p&gt;即查即用，不用特殊记忆&lt;/p&gt;
&lt;p&gt;返回最小值 最大值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i = 127;
        System.out.println(i.MIN_VALUE);
        System.out.println(Integer.MIN_VALUE);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断是不是数字，是不是字母，是不是大写，是不是小写，是不是空格，转成大写，转成小写（查询使用即可，或者可以自己实现）&lt;/p&gt;
&lt;h3&gt;Integer的面试题&lt;/h3&gt;
&lt;p&gt;之前也涉及到过，在前面的数据类型中我曾写过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrapperType {
    public static void main(String[] args) {
        Integer i1 = new Integer(12);
        Integer i2 = new Integer(12);
        System.out.println(i1 == i2);//false
	//创建新的对象，指向的地址肯定不同
        Integer i3 = 12;//Integer.valueOf(12);
        Integer i4 = 12;//Integer.valueOf(12);
        System.out.println(i3 == i4);//true
	//Integer自动包装调用valueOf()，其中涉及到常量池的概念
        Integer i5 = 128;
        Integer i6 = 128;
        System.out.println(i5 == i6);//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在一个cache，-128—127，在范围外才会创建对象&lt;/p&gt;
&lt;p&gt;已经静态的创建好了一个Integer包装数组，将-128—127，在范围内直接用引用指向即可&lt;/p&gt;
&lt;p&gt;还有一个，这里涉及到的是基本数据类型，比较的是值是否相等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/85.png&quot; alt=&quot;85&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;支持可序列化接口，比较接口，可读的字符序列接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.String 对象是用来保存字符串的，是一组字符序列&lt;/p&gt;
&lt;p&gt;2.字符串常量对象使用双引号括起的字符序列&lt;/p&gt;
&lt;p&gt;3.字符串的字符使用的是Unicode字符编码，一个字符占用两个字节&lt;/p&gt;
&lt;p&gt;4.String类较为常用的构造方法有以下:多种构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;()

(String original)

(char[] a)

(char[] a, int startIndex, int count)

(byte[] b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String 有属性private final char value[ ] :用于存储字符串内容，final代表value指向的地址不可以被修改（而地址存储的单个字符内容可以变化），以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        final char[] target = {&apos;1&apos;,&apos;2&apos;,&apos;5&apos;};
        target[0] = &apos;4&apos;;
        char[] target1 = {&apos;1&apos;,&apos;2&apos;,&apos;3&apos;};
        //target = target1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;创建String对象方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        String str1 = &quot;abc&quot;;//方式一
        String str2 = new String(&quot;abc&quot;);//方式二
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式一：查看常量池中是否有&quot;abc&quot;的数据空间，如果有直接指向，如果没有则在常量池中创建，最后指向的是常量池中的空间地址&lt;/p&gt;
&lt;p&gt;方式二：在堆中创建空间，如果里面维护了value属性，指向常量池中的&quot;abc&quot;空间，如果常量池中没有&quot;abc&quot;重新创建，如果有直接通过value指向，最终指向的是堆中的空间地址，堆中的引用指向常量池中的地址&lt;/p&gt;
&lt;p&gt;以下是示例图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/86.png&quot; alt=&quot;86&quot; /&gt;&lt;/p&gt;
&lt;p&gt;虽然指向的最终都是到常量池中的字符，但是二者指向的第一个地址不一样（一个在堆中，另一个在常量池中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class String1 {
    public static void main(String[] args) {
        String str1 = &quot;abc&quot;
        String str2 = new String(&quot;abc&quot;);
        System.out.println(str1 == str2);//false
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用intern方法时，如果常量池中已经包含了对应的字符串，就返回池中的字符串地址，否则先添加String对象添加到池中，并返回池中的地址&lt;/p&gt;
&lt;p&gt;一个测试题目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/87.png&quot; alt=&quot;87&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后一个e指向常量池，true，优化为e = &quot;helloabc&quot;;&lt;/p&gt;
&lt;h3&gt;String的常用方法&lt;/h3&gt;
&lt;h4&gt;equals&lt;/h4&gt;
&lt;p&gt;//判断是否相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;abccdff&quot;);
System.out.println(str1.equals(str2));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;equalsIgnoreCase&lt;/h4&gt;
&lt;p&gt;//忽略大小写判断是否相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
System.out.println(str1.equalsIgnoreCase(str2));//true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;length&lt;/h4&gt;
&lt;p&gt;//字符个数，字符串长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.length());//3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;indexOf&lt;/h4&gt;
&lt;p&gt;//获取第一个对应对应字符的索引，无则返回-1&lt;/p&gt;
&lt;p&gt;注意可以传入字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.indexOf(&quot;bc&quot;));//2
System.out.println(str2.lastIndexOf(&apos;B&apos;));//2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;lastIndexOf&lt;/h4&gt;
&lt;p&gt;//获取最后一个对应字符的索引，无则返回-1&lt;/p&gt;
&lt;p&gt;同上类似&lt;/p&gt;
&lt;h4&gt;substring&lt;/h4&gt;
&lt;p&gt;//截取指定范围的字串&lt;/p&gt;
&lt;p&gt;一个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String substring(int beginIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex;
    if (subLen &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String substring(int beginIndex, int endIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex &amp;gt; value.length) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;concat&lt;/h4&gt;
&lt;p&gt;//拼接字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.concat(str2));//abcABC
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;replace&lt;/h4&gt;
&lt;p&gt;//替换字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.replace(&quot;a&quot;, &quot;b&quot;));//bbc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toUpperCase&lt;/h4&gt;
&lt;p&gt;//向上取大写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str1.toUpperCase());//ABC
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toLowerCase&lt;/h4&gt;
&lt;p&gt;//取向下小写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(str2.toLowerCase());//abc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;split&lt;/h4&gt;
&lt;p&gt;//以（）为标准分割字符串内容&lt;/p&gt;
&lt;p&gt;转移字符需要在前加 \&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str3 = new String(&quot;abc,ABe,CDE&quot;);
String[] stringArr = str3.split(&quot;,&quot;);
String str4 = stringArr[0];
System.out.println(str4);//abc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;toCharArray&lt;/h4&gt;
&lt;p&gt;//转换为字符数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char[] a = str1.toCharArray();
System.out.println(a[1]);//b
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;compareTo&lt;/h4&gt;
&lt;p&gt;//比较大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
System.out.println(str1.compareTo(str2));//32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当区分不出大小且，长度不一样时有不同返回值，详见源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int compareTo(String anotherString) {
    int len1 = value.length;
    int len2 = anotherString.value.length;
    int lim = Math.min(len1, len2);
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    while (k &amp;lt; lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) {
            return c1 - c2;
        }
        k++;
    }
    return len1 - len2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;trim&lt;/h4&gt;
&lt;p&gt;//去前后空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;  ab c  &quot;);
System.out.println(str1.trim());//ab c
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;format&lt;/h4&gt;
&lt;p&gt;//字符串格式化拼接&lt;/p&gt;
&lt;p&gt;类似于C语言中printf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;ABC&quot;);
String str3 = String.format(&quot;你好 %s 和 %s&quot;, str1, str2);
System.out.println(str3);//你好 abc 和 ABC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有点太多了，没必要全记，记不得在查，早晚会熟练使用的&lt;/p&gt;
&lt;h2&gt;StringBuffer&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;是一种增强的String支持增删改，直接父类是AbstractStringBuilder，实现了可序列化的接口，是一个final类型，不可被继承&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/88.png&quot; alt=&quot;88&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中有value char数组，存放在堆中&lt;/p&gt;
&lt;p&gt;StringBuffer相较于String保存的字符串常量（值无法修改），StringBuffer不用在修改内容的时候更改地址（除非内存不足时重新扩容复制），所以效率上高于String&lt;/p&gt;
&lt;h3&gt;常用的构造器&lt;/h3&gt;
&lt;p&gt;默认的无参构造器（创建一个16字符的空间）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入int参数构造器，其中容量为32个字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(32);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传入String常量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;StringBuffer01&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jdk源码，其中先new一个同样大小的数组，再通过append拼接+16的容量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public StringBuffer(String str) {
    super(str.length() + 16);
    append(str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;与String的转化&lt;/h3&gt;
&lt;p&gt;转为String&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        String str = &quot;hello&quot;;
        StringBuffer sb1 = new StringBuffer(str);//对原先的str没有影响
        StringBuffer sb2 = new StringBuffer();
        sb2.append(str);//通过添加完成
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转为StringBuffer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        String str1 = sb.toString();
        String str2 = new String(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;StringBuffer常用方法&lt;/h3&gt;
&lt;h4&gt;append&lt;/h4&gt;
&lt;p&gt;在末尾添加字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.append(&quot; World!!&quot;);
        System.out.println(sb);//Hello World!
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;delete&lt;/h4&gt;
&lt;p&gt;删除 [1，3）的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.delete(1, 3);
        System.out.println(sb.toString());//Hlo
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;replace&lt;/h4&gt;
&lt;p&gt;替换，有三个参数，从 [1，3）的内容用参数 3 替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.replace(1, 3, &quot;世界&quot;);
        System.out.println(sb.toString());//H世界lo
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;indexOf&lt;/h4&gt;
&lt;p&gt;返回查找内容的索引（第一个）传入字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        System.out.println(sb.indexOf(&quot;l&quot;));//2
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;insert&lt;/h4&gt;
&lt;p&gt;在（第一个参数的位置）插入内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        sb.insert(1, &quot;插入&quot;);
        System.out.println(sb);//H插入ello
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;length&lt;/h4&gt;
&lt;p&gt;返回长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
        System.out.println(sb.length());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常见的例题&lt;/h3&gt;
&lt;p&gt;使用append传入null字符串&lt;/p&gt;
&lt;p&gt;当为null的时候返回appendNull，而返回的值是一个null字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        String str = null;
        sb.append(str);
        System.out.println(sb.length());//4
        System.out.println(sb.toString());//null
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = &apos;n&apos;;
    value[c++] = &apos;u&apos;;
    value[c++] = &apos;l&apos;;
    value[c++] = &apos;l&apos;;
    count = c;
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种情况：使用构造器传入null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        String str = null;
        StringBuffer sb = new StringBuffer(str);//抛出异常
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public StringBuffer(String str) {
    super(str.length() + 16);//在源码这里因为null抛出异常
    append(str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个在价格中增添，的代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StringBuffer01 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String price = sc.nextLine();//输入一个价格，在小数点前每隔3位用,隔离开
        StringBuffer sb = new StringBuffer(price);//123456.78
        int index = sb.indexOf(&quot;.&quot;);
        for(int i = index - 3; i &amp;gt; 0; i -= 3) {
            sb.insert(i, &quot;,&quot;);
        }
        System.out.println(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;StringBuilder&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public final class StringBuilder
    extends AbstractStringBuilder
    implements Serializable, CharSequence
{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是一个可变的字符序列，提供与StringBuffer兼容的API，但是不保证线程安全，被设计为StringBuffer的简易替换，用在字符串缓冲区被单个线程使用的时候&lt;/p&gt;
&lt;p&gt;如果可能优先使用StringBuilder，因为它的效率大多都要比StringBuffer快&lt;/p&gt;
&lt;p&gt;在StringBuilder上的主要操作时append和insert方法，可以重载这些方法用以接收任意类型的数据&lt;/p&gt;
&lt;p&gt;StringBuffer继承了AbstractStringBuilder类，可串行化，可以保存在文件，是一个final类型，不可被继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class AbstractStringBuilder implements Appendable, CharSequence {

    char[] value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符存放在堆中&lt;/p&gt;
&lt;p&gt;StringBuilder的方法没有作互斥的处理，没有synchronization关键字，只能在单线程中使用&lt;/p&gt;
&lt;h2&gt;String三者比较&lt;/h2&gt;
&lt;p&gt;1.StringBuilder和StringBuffer类似，均代表可变字符序列，方法一致&lt;/p&gt;
&lt;p&gt;2.String是不可变字符序列，效率低，但是复用率高&lt;/p&gt;
&lt;p&gt;3.StringBuffer是可变字符序列，效率较高（增删），线程安全&lt;/p&gt;
&lt;p&gt;4.StringBuilder是可变字符序列，效率最高，线程不安全&lt;/p&gt;
&lt;h1&gt;课后练习&lt;/h1&gt;
&lt;p&gt;String str = new String(&quot;hello&quot;) + new String(&quot;word&quot;)过程中产生了几个对象&lt;/p&gt;
&lt;p&gt;在Java中，当你使用&lt;code&gt;+&lt;/code&gt;运算符进行字符串拼接时，编译器会自动进行优化，底层实际上是使用&lt;code&gt;StringBuilder&lt;/code&gt;来实现的。这是出于性能和内存效率的考虑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str = new String(&quot;hello&quot;) + new String(&quot;word&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器会将其转换为类似以下的字节码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringBuilder sb = new StringBuilder();
sb.append(new String(&quot;hello&quot;));
sb.append(new String(&quot;word&quot;));
String str = sb.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.反转字符串（将指定的部分反转）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        String str = new String(&quot;HelloWorld&quot;);
        str = reverse(str, 0, str.length() - 1);
        System.out.println(str.toString());
    }

    public static String reverse(String str, int start, int end) {
        char[] arr = str.toCharArray();
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        return new String(arr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断账号密码是否正确&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        String input = new Scanner(System.in).nextLine();
        String[] strArray = input.split(&quot;,&quot;);
        if(strArray[0].length() == 2 || strArray[0]
                .length() == 3 || strArray[0].length() == 4) {
            System.out.println(&quot;用户名正确&quot;);
        }
        if(strArray[1].length() == 6 &amp;amp;&amp;amp; isDigital(strArray[1])) {
            System.out.println(&quot;密码正确&quot;);
        }
    }
    public static boolean isDigital(String str) {
        char[] chars = str.toCharArray();
        for (int i = 0; i &amp;lt; chars.length; i++) {
            if (!Character.isDigit(chars[i])) {
                return false;
            }
        }
        return true;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100,123456
用户名正确
密码正确
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>面试小结</title><link>https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93/</guid><description>字节跳动面试总结</description><pubDate>Thu, 27 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;面试小结&lt;/h1&gt;
&lt;p&gt;这一次面试没有想象中的那么压力山大，面试官也没有去死咬着某个知识点去提问，而是通过投递的简历来提问，其中计算机操作系统相关的题目较多，而我有对计算机系统方面的线程进程问题又比较了解，在这个部分表现得还算过得去，但是在于存储的方面我确实没有一个很好的实践积累，回答的大多都是在理论上的知识点，还有设备IO方面，我知道的也不是很多，面试官看我不是很清楚也就没有深挖。计算机网络相关的基础没有问到，不知道是不是看我的简历上有一两个网络编程的经验就跳过了。&lt;/p&gt;
&lt;p&gt;缺少知识点：多线程相关的细节，Mysql，Redis，哈希表，红黑树&lt;/p&gt;
&lt;p&gt;面试除了基础知识的提问，还考察了在设计项目上的思路，例如操作系统上如何去降低一个响应的时间：我除了进程之外也懂得不多，我就回答的是可以优化进程调度的一个策略，例如调整时间片大小，在线程之下创建亚线程。内存我直接不管了，另外加多CPU支持并行，多的我面试的时候也没有想到。&lt;/p&gt;
&lt;p&gt;以下是AI生成的其他回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; I/O优化
异步I/O：用非阻塞I/O（如epoll、io_uring）替代同步阻塞调用。

缓冲和批处理：合并小I/O请求为大操作（如磁盘写合并）。

SSD/高速存储：替换机械硬盘，降低I/O延迟。

内核参数调优
调整调度器：如Linux的CFS（完全公平调度器）参数或改用实时调度策略（SCHED_FIFO）。

中断优化：启用中断负载均衡（irqbalance），或绑定中断到特定CPU。

亚线程/协程：将任务拆分为更轻量级的单元（如协程、用户态线程），减少阻塞。

CPU绑定（Affinity）：将关键进程绑定到特定CPU核心，避免缓存失效和迁移开销。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络相关场景题&lt;/h3&gt;
&lt;p&gt;还有在网络繁忙的时候该如何解决大量访问的问题，这里我回答的是一个限流，以下是常见的限流算法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;令牌桶（Token Bucket）：

固定速率生成令牌，请求需消耗令牌（突发流量允许一定峰值）。

实现工具：Nginx limit_req、Redis + Lua脚本。

漏桶（Leaky Bucket）：

请求以恒定速率处理（平滑流量，严格限制突发）。

固定窗口/滑动窗口计数：

统计单位时间内的请求数（如每分钟100次），滑动窗口更精确但开销略高。

自适应限流：

根据系统负载动态调整阈值（如CPU、队列长度），如Netflix的Hystrix。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是AI回答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;流量整形与负载均衡
队列缓冲：用消息队列（Kafka、RabbitMQ）异步处理请求，削峰填谷。

负载均衡：

横向扩展：增加服务实例，通过LB（如Nginx、HAProxy）分发流量。

智能路由：根据服务器负载动态分配请求（如Least Connections算法）。

服务降级与熔断
降级：关闭非核心功能（如推荐服务），返回缓存或默认值。

熔断：当错误率超过阈值时，短暂拒绝请求（如Hystrix、Resilience4j）。

服务隔离：将关键服务与非关键服务分离（如线程池隔离）。

缓存优化
多级缓存：

客户端缓存 → CDN → 服务端缓存（Redis）→ 数据库缓存。

热点数据预加载：提前缓存高频访问数据（如秒杀商品库存）。

弹性伸缩与云原生方案
自动扩缩容：Kubernetes HPA、AWS Auto Scaling。

Serverless：突发流量由无服务函数（如AWS Lambda）处理。

协议与连接优化
长连接复用：减少TCP握手开销（如HTTP/2、gRPC）。

压缩数据：减小传输体积（如Gzip、Protobuf）。

快速失败：设置超时时间（如TCP SYN队列调优）。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;哈希表和红黑树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;em&gt;“哈希表和红黑树有什么区别？如何选择？”&lt;/em&gt;
&lt;strong&gt;回答模板&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;先对比核心特性&lt;/strong&gt;：
“哈希表基于哈希函数，理想情况下查询是&lt;code&gt;O(1)&lt;/code&gt;，但可能因冲突退化；红黑树是自平衡二叉搜索树，稳定在&lt;code&gt;O(log n)&lt;/code&gt;，且支持有序遍历。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提优缺点&lt;/strong&gt;：
“哈希表内存占用大但查询快，适合字典类场景；红黑树更省内存且有序，适合范围查询。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例应用&lt;/strong&gt;：
“比如Java的&lt;code&gt;HashMap&lt;/code&gt;用哈希表实现快速查找，而&lt;code&gt;TreeMap&lt;/code&gt;用红黑树保证键的有序性。”&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希表如何解决冲突？&lt;/strong&gt;
→ 拉链法（链表+红黑树，如Java 8的&lt;code&gt;HashMap&lt;/code&gt;）、开放寻址法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树 vs AVL树？&lt;/strong&gt;
→ 红黑树牺牲严格平衡性换取更少的旋转操作，适合频繁插入删除的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;算法题目&lt;/h3&gt;
&lt;p&gt;有思路的，可惜没有写出来，以下是题目样例，具体的输入我想不起来了&lt;/p&gt;
&lt;p&gt;我理解的这是一种压缩的方式：&lt;/p&gt;
&lt;p&gt;例如字符串 ab[avv]{2}dd 代表的是 abavvavvdd，要求写一个算法输入字符串，输出对应的字符串，这一道题我的理解是将 [ 放入栈结构里面，记录右侧下表，遇到]时候弹栈，读取后面的循环次数（限制为2-9，不然更麻烦了），循环输出，但是这里有个重点是这样一个[ ] 是要求可以嵌套使用的，最后写出来的只能处理不嵌套的一种样式，以下是 AI生成的算法，学学看吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.algorithm;
import java.util.Stack;

public class Interview {
    public static void main(String[] args) {
        String s1 = &quot;ab[avv]{2}dd&quot;;
        System.out.println(decodeString(s1));  // 输出: abavvavvdd

        String s2 = &quot;a[b[c]{2}]{3}d&quot;;
        System.out.println(decodeString(s2));  // 输出: abccbccbccd
    }

    // 手动实现的字符串重复方法（兼容 Java 8）
    public static String repeat(String str, int times) {
        if (times &amp;lt;= 0) {
            return &quot;&quot;;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; times; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    public static String decodeString(String s) {
        Stack&amp;lt;StringBuilder&amp;gt; strStack = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; numStack = new Stack&amp;lt;&amp;gt;();
        StringBuilder currentStr = new StringBuilder();
        int i = 0;
        int n = s.length();

        while (i &amp;lt; n) {
            char c = s.charAt(i);
            if (c == &apos;[&apos;) {
                // 遇到 &apos;[&apos;, 压栈当前状态
                strStack.push(currentStr);
                currentStr = new StringBuilder();
                i++;
            } else if (c == &apos;]&apos;) {
                // 遇到 &apos;]&apos;, 准备读取 &apos;{n}&apos;
                i++;  // 跳过 &apos;]&apos;
                if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;{&apos;) {
                    i++;  // 跳过 &apos;{&apos;
                    if (i &amp;lt; n &amp;amp;&amp;amp; Character.isDigit(s.charAt(i))) {
                        int repeatTimes = s.charAt(i) - &apos;0&apos;;
                        i++;  // 跳过数字
                        if (i &amp;lt; n &amp;amp;&amp;amp; s.charAt(i) == &apos;}&apos;) {
                            i++;  // 跳过 &apos;}&apos;
                        }
                        // 弹出栈顶状态并使用自定义的repeat方法
                        StringBuilder prevStr = strStack.pop();
                        String repeatedStr = repeat(currentStr.toString(), repeatTimes);  // 使用自定义repeat
                        prevStr.append(repeatedStr);
                        currentStr = prevStr;
                    }
                }
            } else {
                // 普通字符，直接追加
                currentStr.append(c);
                i++;
            }
        }

        return currentStr.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实看起来还是有点困难的，主要还是我Java还没有学习到字符串相关的常用类String那里，哎，慢慢学吧&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>枚举类，注解，异常处理</description><pubDate>Mon, 24 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;枚举类&lt;/h2&gt;
&lt;p&gt;在设计一个季节对象的时候，我们可以用传统的方式实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = new Season(&quot;春天&quot;, &quot;温暖&quot;);
}

class Season {
    private String season;
    private String description;
    Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是众所周知，季节只有四季，不能体现只有四个这个特征，为了解决这个问题，我们可以使用枚举类来定义季节，设计几个有限的值&lt;/p&gt;
&lt;h3&gt;枚举定义&lt;/h3&gt;
&lt;p&gt;是一组常量的集合：枚举是一种特殊的类，里面只包含一组有限的特定对象&lt;/p&gt;
&lt;p&gt;自定义枚举&lt;/p&gt;
&lt;p&gt;1.不需要提供set方法，因为枚举对象通常是只读的&lt;/p&gt;
&lt;p&gt;2.写枚举对象/属性的使用一般用final + static 修饰&lt;/p&gt;
&lt;p&gt;3.枚举对象名通常用大写来命名，常量的命名规范&lt;/p&gt;
&lt;p&gt;4.枚举对象根据需要也可以拥有多个属性&lt;/p&gt;
&lt;h3&gt;使用方式1&lt;/h3&gt;
&lt;p&gt;1.私有化构造器，防止直接new&lt;/p&gt;
&lt;p&gt;2.删去set方法，防止属性修改&lt;/p&gt;
&lt;p&gt;3.在Season内部直接创建固定对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = Season.SPRING;
}

class Season {
    private String season;
    private String description;

    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
    
    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用方式2&lt;/h3&gt;
&lt;p&gt;使用关键字enum&lt;/p&gt;
&lt;p&gt;使用细节&lt;/p&gt;
&lt;p&gt;1.要将枚举对象放在枚举类的行首&lt;/p&gt;
&lt;p&gt;2.常量之间用“，”间隔&lt;/p&gt;
&lt;p&gt;3.常量通过构造器构造，必须知道用哪一个构造器&lt;/p&gt;
&lt;p&gt;4.使用无参构造器的时候可以省略形参列表和小括号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    Season season = Season.SPRING;
}

enum Season {
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;),
    AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;),
    WINTER(&quot;冬天&quot;, &quot;寒冷&quot;);

    private String season;
    private String description;

    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.当使用enum关键字开发一个枚举类的时候，默认继承了Enum类&lt;/p&gt;
&lt;p&gt;这里可以运用反编译来进行证明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop\Java\IDEA\chapter11\out\production\chapter11\com\enum_&amp;gt; javap Season.class
Compiled from &quot;Enumeration.java&quot;
final class com.enum_.Season extends java.lang.Enum&amp;lt;com.enum_.Season&amp;gt; {
  public static final com.enum_.Season SPRING;
  public static final com.enum_.Season SUMMER;
  public static final com.enum_.Season AUTUMN;
  public static final com.enum_.Season WINTER;
  public static com.enum_.Season[] values();
  public static com.enum_.Season valueOf(java.lang.String);
  static {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Enum类&lt;/h3&gt;
&lt;p&gt;关键enum字修饰的类隐式的继承了Enum类，这个类中有一些常用的方法&lt;/p&gt;
&lt;p&gt;挨个解释有点麻烦，这里直接上代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Enumeration {
    public static void main(String[] args) {
        Season season = Season.WINTER;
        System.out.println(season.toString());// WINTER 输出枚举的名字
        System.out.println(season.name());// WINTER 输出枚举的名字
        System.out.println(season.ordinal());// 3 输出枚举对象的次序，从0开始编号
        for (Season s : Season.values()) {
            System.out.println(s.toString()); // 输出一个枚举常量的数组
        }
        Season season2 = Season.valueOf(&quot;SPRING&quot;);// 用valueOf可以将字符串转为枚举常量
        System.out.println(season2.compareTo(season));
        //-3 比较两个枚举类型，return self.ordinal - other.ordinal;
    }

}

enum Season {
    SPRING(&quot;春天&quot;, &quot;温暖&quot;),
    SUMMER(&quot;夏天&quot;, &quot;炎热&quot;),
    AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;),
    WINTER(&quot;冬天&quot;, &quot;寒冷&quot;);

    private String season;
    private String description;

    private Season(String season, String description) {
        this.season = season;
        this.description = description;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enum使用细节&lt;/p&gt;
&lt;p&gt;1.enum不可以继承其他类，因为已经继承了Enum父类&lt;/p&gt;
&lt;p&gt;2.枚举类和普通类一样可以实现接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Homework {
    public static void main(String[] args) {
        Week week = Week.TUESDAY;
        week.doSomething();
    }
}

interface Doing {
    void doSomething();
}

enum Week implements Doing {
    MONDAY(&quot;星期一&quot;),
    TUESDAY(&quot;星期二&quot;),
    WEDNESDAY(&quot;星期三&quot;);

    private String name;
    private Week(String name) {
        this.name = name;
    }

    @Override
    public void doSomething() {
        System.out.println(name);
    }

    @Override
    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;注解&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;注解（Annotation）也被称为元数据（Metadata）&lt;/p&gt;
&lt;p&gt;1.用于修饰包，类，方法，属性，构造器，局部变量的数据信息&lt;/p&gt;
&lt;p&gt;2.和注释一样，注解不影响程序逻辑，但是注解可以被编译运行，相当于嵌入在代码中的补充信息&lt;/p&gt;
&lt;p&gt;3.在JavaSE中，注解使用的目的比较简单，例如标记过过时的功能，忽略警告等&lt;/p&gt;
&lt;p&gt;4.在JavaEE中注解占据了更加重要的角色，例如配置应用程序的任何切面，代替JavaEE旧版中所遗留的，繁冗代码和XML配置等&lt;/p&gt;
&lt;h3&gt;三个基本的Annotation&lt;/h3&gt;
&lt;h4&gt;@Override&lt;/h4&gt;
&lt;p&gt;限定某个方法，是重写父类方法，该注解只可以用于方法&lt;/p&gt;
&lt;p&gt;源码中的override注解说明，其中@target是注解注解的注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上了这个注解，编译器会检查子类是否重写父类方法，如果没有重写会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father {
    public Father() {}
    public void Print() {
        System.out.println(&quot;Father&quot;);
    }
}

class Child extends Father {
    public Child() {}
    @Override//加上了override注解
    public void Print() {
        System.out.println(&quot;Child&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;@Deprecated&lt;/h4&gt;
&lt;p&gt;可以做版本过渡使用（保证了兼容性）&lt;/p&gt;
&lt;p&gt;用于表示某个程序元素（类，方法等）已过时，可以修饰方法，字段，包，参数，类，局部变量，类型等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以下代码中表示Child类以及过时，但是还是可以使用，只是不建议使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/77.png&quot; alt=&quot;77&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Deprecated
class Child extends Father {
    public Child() {}
    @Override
    public void Print() {
        System.out.println(&quot;Child&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;@SuppressWarnings&lt;/h4&gt;
&lt;p&gt;抑制编译器警告&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编写代码的时候，往往会出现一些黄色的线条勾选部分代码，如果在合理的范围中你不想见到这一些警告，你可以使用@SuppressWarnings不显示一些警告信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;her&quot;);
        list.add(&quot;he&quot;);
        list.add(&quot;it&quot;);
        System.out.println(list.get(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是使用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    @SuppressWarnings({&quot;all&quot;})//忽略编译警告
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;her&quot;);
        list.add(&quot;he&quot;);
        list.add(&quot;it&quot;);
        System.out.println(list.get(0));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在{ }中填入对应需要忽略的警告信息，有点类似字符串数组的静态创建（其实本质就是一个字符串数组，可以查看jdk源码验证）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; String[] value();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外该注解的作用范围和注解的位置有关，像如上代码中抑制的范围是main方法中，或者更大的范围可以放在类上&lt;/p&gt;
&lt;h3&gt;JDK中的元注解&lt;/h3&gt;
&lt;p&gt;修饰注解的注解，再查看注解源码的时候可以用元注解了解注解相应作用即可&lt;/p&gt;
&lt;p&gt;@Retention注解的作用范围&lt;/p&gt;
&lt;p&gt;@Target使用位置&lt;/p&gt;
&lt;p&gt;@Documented 是否在javadoc中体现&lt;/p&gt;
&lt;p&gt;@inherited 子类会继承父类注解（使用较少）&lt;/p&gt;
&lt;p&gt;以下是一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Documented//会显示在javadoc文档
@Retention(RetentionPolicy.RUNTIME)//注解的注解范围（源码，类，运行时）
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})//注解的使用场景
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;异常&lt;/h2&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;h4&gt;异常的概念&lt;/h4&gt;
&lt;p&gt;在Java中，将程序执行过程中发生的不正常情况称为异常&lt;/p&gt;
&lt;p&gt;分为两大类：Error错误以及Exception&lt;/p&gt;
&lt;p&gt;Error： Java 虚拟机无法解决的严重问题例如JVM系统内部错误，资源溢出&lt;/p&gt;
&lt;p&gt;Exception：由于编程错误或者偶然的外在因素导致的一般性问题，可以使用针对性地代码进行处理，异常又分为两大类，一种是编译时异常，另一种是运行时异常。&lt;/p&gt;
&lt;h4&gt;异常体系图&lt;/h4&gt;
&lt;p&gt;异常中又分为编译时异常（javac），运行时异常（java）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/78.png&quot; alt=&quot;78&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;异常处理概念&lt;/h4&gt;
&lt;p&gt;如果程序员认为代码会出现异常，可以使用try-catch异常处理机制来解决&lt;/p&gt;
&lt;p&gt;在程序运行的过程中有可能会发送各种异常，而发生程序异常的时候，程序往往发成崩溃&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        System.out.println(num1 / num2);
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一段代码不会输出最后运行完毕的提示消息，在写程序的时候不应该因为一个微小地异常而导致整个程序崩溃，我们可以通过运用异常处理机制来解决这个问题&lt;/p&gt;
&lt;p&gt;用ctrl alt + t -&amp;gt; 选中try-catch，如果异常处理，即使出现异常程序也可以正常执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        try {
            System.out.println(num1 / num2);
        } catch (Exception e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;异常被捕获
程序运行完毕
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常见的异常&lt;/h3&gt;
&lt;h4&gt;运行时异常&lt;/h4&gt;
&lt;p&gt;空指针异常 NullPointerExceprion&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        String name = null;
        try {
            name.toString();
        } catch (NullPointerException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算数异常 ArithmeticException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 0;
        try {
            System.out.println(num1 / num2);
        } catch (ArithmeticException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组越界访问异常 ArrayIndexOutOfBoundsException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 6, 7};
        try {
            System.out.println(arr[5]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(&quot;异常被捕获&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型转换异常 ClassCastException&lt;/p&gt;
&lt;p&gt;解释说明：当将对象试图转换为不是实例的子类的时候会发生该异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        A a = new B();
        B b = (B) a;
        try {
            C c = (C) a;
        } catch (ClassCastException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}

class A {
}

class B extends A {
}

class C {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这里没有捕获到异常，程序崩溃（暂时未知原因，丢给AI解释说是和开发环境以及缓存有关，后续会查证）&lt;/p&gt;
&lt;p&gt;数字格式不正确 NumberFormatException&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
        } catch (NumberFormatException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;编译时异常&lt;/h4&gt;
&lt;p&gt;在编译期间就必须要处理的异常，否则代码不通过编译&lt;/p&gt;
&lt;p&gt;例如无对应文件异常，数据库异常等，在后续学习文件IO时候会进行补充&lt;/p&gt;
&lt;h3&gt;处理异常的方式&lt;/h3&gt;
&lt;p&gt;二选一即可&lt;/p&gt;
&lt;h4&gt;try-catch-finally&lt;/h4&gt;
&lt;p&gt;程序员在代码中捕获发送的异常，自行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
   	//代码可能会出现异常，将异常封装为Exception对象e，传递catch
} catch (Exception e) {
   	//异常传递给catch
   	//用e来进行自定义处理
} finally {
    //（可以不写finally）
   	//不管try代码块是否有异常，始终要执行finally
    //一般是用来在这里进行资源关闭
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用细节：&lt;/p&gt;
&lt;p&gt;1.如果异常发生，则catch中异常后的代码不再执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
            System.out.println(&quot;try 异常之后的代码&quot;);//不执行
        } catch (NumberFormatException e) {
            System.out.println(&quot;异常被捕获&quot; + e.getMessage());
        } finally {

        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.如果没有发生异常，catch代码块不会被执行&lt;/p&gt;
&lt;p&gt;3.finally中的内容无论异常是否被接收都会被执行，一般用于释放资源&lt;/p&gt;
&lt;p&gt;4.可以有多个catch语句，捕获不同的异常，要求父异常写在后，子异常在前例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        String name = &quot;thrinisty&quot;;
        try {
            int num = Integer.parseInt(name);
            System.out.println(&quot;try 异常之后的代码&quot;);
        } catch (NumberFormatException e) {
            System.out.println(&quot;转换异常被捕获&quot; + e.getMessage());
        } catch (Exception e) {
            System.out.println(&quot;异常发生&quot;);
        } finally {
            System.out.println(&quot;finally&quot;);
        }
        System.out.println(&quot;程序运行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.try-finally配合使用：用于执行一段代码，之后无论异常是否发生，都会执行finally代码块&lt;/p&gt;
&lt;p&gt;一个容易出错的题目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/80.png&quot; alt=&quot;80&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;throws&lt;/h4&gt;
&lt;p&gt;将发生的异常抛出，交给调用者（方法）来进行处理，最顶端的处理者是JVM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/79.png&quot; alt=&quot;79&quot; /&gt;&lt;/p&gt;
&lt;p&gt;假如在代码中没有进行throw显示的处理，而发生了异常，就会默认的抛出异常依次传递直到JVM处理异常，退出程序&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * @author 李昊轩
 * @version 1.0
 */
public class Exception01 {
    public static void main(String[] args) {
        try {
            m1();
        } catch (FileNotFoundException e) {
            System.out.println(&quot;File not found&quot;);
        }
    }

    public static void m1() throws FileNotFoundException {
        FileInputStream fis = new FileInputStream(&quot;cd&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异常交予main函数进行处理，抛出的异常可以是一个列表，对应的异常，异常的父异常&lt;/p&gt;
&lt;h4&gt;异常使用细节&lt;/h4&gt;
&lt;p&gt;1.编译异常必须处理&lt;/p&gt;
&lt;p&gt;2.对于运行时异常，程序中没有进行处理默认为throws方式处理&lt;/p&gt;
&lt;p&gt;3.子类重写父类方法的时候，要么抛出异常的规定，子类重写方法，所抛出的异常类型要和父类抛出的异常一致，要么为父类抛出异常类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father {
    public void sayHello() throws Exception {}
}

class Son extends Father {
    public void sayHello() throws IOException {}
}//子类不可以扩大异常范围
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.运行异常可以默认处理，但是编译异常必须显示的处理&lt;/p&gt;
&lt;h3&gt;课堂练习&lt;/h3&gt;
&lt;p&gt;输入整数，不是整数就继续输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = 0;
        System.out.print(&quot;输入一个整数 &quot;);
        while (true) {
            try {
                num = Integer.parseInt(sc.nextLine());
                break;
            } catch (Exception e) {
                System.out.println(&quot;请重新输入...&quot;);
            }
        }
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义异常&lt;/h3&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.定义类：自定义异常类名，继承Exception或者RuntimeException&lt;/p&gt;
&lt;p&gt;2.继承Exception属于编译异常&lt;/p&gt;
&lt;p&gt;3.继承RuntimeException是运行异常&lt;/p&gt;
&lt;p&gt;通过throw关键字抛出对应的自定义异常，并运用构造器传入异常信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Exception01 {
    public static void main(String[] args) {
        int age = 15;
        try {
            test(age);
        } catch (TypeException e){
            System.out.println(e.getMessage());
        }
    }

    public static void test(int age) {
        if(age &amp;lt; 18) {
            throw new TypeException(&quot;年龄要在18岁以上&quot;);
        }
    }
}

class TypeException extends RuntimeException {
    public TypeException(String message) {
        super(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;throw与throws&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/81.png&quot; alt=&quot;81&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到此枚举类，注解，异常处理的部分结束&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>抽象类，接口，内部类</description><pubDate>Sun, 23 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;当父类方法不确定的时候，需要声明但是不知道该如何实现的时候，可以将其声明为抽象方法，这个类就是抽象类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void eat() {
        System.out.println(&quot;吃一个...&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候可以将该方法设计为抽象方法，所谓抽象方法就是没有实现的方法（没有方法体）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void eat();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当将一个类中的方法设置为抽象方法的时候，要将类也声明为抽象类&lt;/p&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 abstract 返回类型 方法名（）;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再用子类继承实现这些抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    public void eat() {
        System.out.println(&quot;Dog eat&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;抽象类的价值更多的是在于设计，在设计者设计好后，让子类继承并实现&lt;/p&gt;
&lt;h3&gt;抽象类细节&lt;/h3&gt;
&lt;p&gt;1.抽象类不能够被实例化&lt;/p&gt;
&lt;p&gt;2.抽象类不一定要包含抽象方法&lt;/p&gt;
&lt;p&gt;3.抽象方法所在的类必须用abstract修饰&lt;/p&gt;
&lt;p&gt;4.abstract只能修饰类和方法&lt;/p&gt;
&lt;p&gt;5.抽象类可以有任意成员，非抽象方法，构造器，静态属性&lt;/p&gt;
&lt;p&gt;6.抽象方法不能有主体&lt;/p&gt;
&lt;p&gt;7.如果一个类继承了抽象类，则这个类必须要实现所有的抽象方法，除非他自己也声明为abstract类&lt;/p&gt;
&lt;p&gt;8.抽象方法不能够用private final static修饰，因为和重写实现型成悖论&lt;/p&gt;
&lt;h3&gt;模板设计模式&lt;/h3&gt;
&lt;p&gt;抽象类的实践&lt;/p&gt;
&lt;p&gt;需求&lt;/p&gt;
&lt;p&gt;1.有多个类，完成不同的任务&lt;/p&gt;
&lt;p&gt;2.要求能够统计得到各自完成的时间&lt;/p&gt;
&lt;p&gt;3.编程实现&lt;/p&gt;
&lt;p&gt;先使用不同的类实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().job();
        new BB().job();
    }
}

class AA {
    public void job() {
        long start = System.currentTimeMillis();
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
        System.out.println(end - start);
    }
}

class BB {
    public void job() {
        long start = System.currentTimeMillis();
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
        System.out.println(end - start);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将公共的部分提取出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().calulateTime();
        new BB().calulateTime();
    }
}

class AA {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}

class BB {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果说加上了C在C类中还是必须要实现calulateTime方法，所以可以将job写为一个抽象方法，calulateTime在抽象类里实现，用各个子类继承实现job即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.abstract_;

public class Abstract {
    public static void main(String[] args) {
        new AA().calulateTime();
        new BB().calulateTime();
    }
}

abstract class DD {
    public void calulateTime() {
        long start = System.currentTimeMillis();
        job();
        long end = System.currentTimeMillis();
        System.out.println((end - start));
    }

    public abstract void job();
}

class AA extends DD {
    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}

class BB extends DD {
    public void job() {
        long num = 0;
        for (long i = 0; i &amp;lt; 800000; i++) {
            num += i / 2;
        }
        long end = System.currentTimeMillis();
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里运用到了动态绑定机制，job调用的是子类的具体实现&lt;/p&gt;
&lt;p&gt;运用到模板设计模式，也已大幅度提高代码的复用性，简易性&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;h3&gt;快速入门&lt;/h3&gt;
&lt;p&gt;现实中使用充电器，usb接口，都有着统一的尺寸规定，方便用户使用，这种思路在语言编程中也有对应使用&lt;/p&gt;
&lt;p&gt;可以用以下代码模拟&lt;/p&gt;
&lt;p&gt;有如下接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface UsbInterface {
    //规定接口的相关方法
    public void start();
    public void stop();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手机实现了接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;
//实现接口
public class Phone implements UsbInterface{
    public void start() {
        System.out.println(&quot;Phone start&quot;);
    }
    public void stop() {
        System.out.println(&quot;Phone stop&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相机实现了接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Camera implements UsbInterface{
    public void start(){
        System.out.println(&quot;Camera start&quot;);
    }
    public void stop(){
        System.out.println(&quot;Camera stop&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;电脑使用接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Computer {
    public void work(UsbInterface usbInterface) {
        //通过接口调用接口方法
        usbInterface.start();
        usbInterface.stop();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以传入接口，使用接口实现的类的接口实现方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Interface {
    public static void main(String[] args) {
        Camera camera = new Camera();
        Phone phone = new Phone();
        Computer computer = new Computer();
        computer.work(phone);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中可以通过computer的work传入phone，调用phone的方法&lt;/p&gt;
&lt;h3&gt;基本介绍&lt;/h3&gt;
&lt;p&gt;接口就是给出一些没有实现的方法，封装在一起，在某个类要使用的时候，再根据具体的情况把这些方法写出来，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface 接口名 {
	//属性
	//方法
}

class 类名 implements 接口名 {
	//属性
	//方法
	//必须实现的接口抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在jdk7之前的接口中没有方法体，都是抽象方法，而在jdk8之后接口可以有静态方法，默认方法，也就是接口中可以有方法的具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public interface AInterface {
    public int num = 0;
    public void hi();//在接口中不需要加abstract，默认为抽象方法
    public default void lo() {//默认的方法实现，使用default
        System.out.println(1);
    }
    public static void test() {
        System.out.println(&quot;test&quot;);
    }
}

class A implements AInterface {
    @Override
    public void hi() {
        System.out.println(&quot;hi&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;接口的使用场景&lt;/h3&gt;
&lt;p&gt;1.在设计飞机时，专家规定飞机需要实现的功能/规格即可，让别人具体实现&lt;/p&gt;
&lt;p&gt;2.项目经理，管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现&lt;/p&gt;
&lt;p&gt;例如：3个程序员编写三各类，分别完成对于MySQL，Oracle，DB2数据库的 connect &amp;amp; close的定义，可以分别对三个数据库规定三个接口，三个程序员就必须要统一连接和关闭的方法名，接口也可以识别connect &amp;amp; close对应的是哪一个接口&lt;/p&gt;
&lt;p&gt;接口的使用细节&lt;/p&gt;
&lt;p&gt;1.接口不能够被实例化&lt;/p&gt;
&lt;p&gt;2.接口中所有的方法是public方法，接口中的抽象方法可以不用abstract修饰方法也可以不用public修饰&lt;/p&gt;
&lt;p&gt;3.一个普通类实现接口，就必须将接口中的方法都实现&lt;/p&gt;
&lt;p&gt;4.抽象类实现接口，可以不用实现接口的方法&lt;/p&gt;
&lt;p&gt;5.一个类可以同时实现多个接口（类的继承不允许继承多个类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A implements IB, IC {
    //实现IB接口
    //实现IC接口
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.接口中的属性只能是final的，而且是public static final 修饰符，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
//实际上是 public static final int a = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.接口中属性的访问形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;接口名.属性名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.一个接口不能继承其他的类，但是可以继承多个别的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface A extends B, C {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9.接口的修饰符只能够是public和默认，和类的修饰符同理&lt;/p&gt;
&lt;p&gt;一个课堂练习，以下三种方式均可以成功访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

public class AInterface {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.num);//通过实例对象引用接口中的成员
        System.out.println(A.num);//通过类使用接口静态成员
        System.out.println(InterfaceTest.num);//通过接口使用静态成员
    }
}
interface InterfaceTest {
    int num = 1;
}

class A implements InterfaceTest {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;接口VS继承&lt;/h3&gt;
&lt;p&gt;接口在Java中算单继承的补充，例如一只小猴，对于猴类来说，猴子天生就会爬树，这算是继承，但是如果要学会游泳，这只猴子就需要去学习游泳（实现游泳接口的功能）&lt;/p&gt;
&lt;p&gt;接口比继承更加灵活，继承是is — a 的关系，而接口只需要满足 like — a 的关系&lt;/p&gt;
&lt;p&gt;接口在一定程度上实现代码的解耦（接口的规范性 + 动态绑定机制）在后续讲解源码的时候会有所涉及&lt;/p&gt;
&lt;h3&gt;接口的多态特性&lt;/h3&gt;
&lt;p&gt;1.多态参数&lt;/p&gt;
&lt;p&gt;例如在前面涉及到的入门，电脑在调用接口参数的时候，这个参数可以接受实现了这个接口的对象实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class Interface {
    public static void main(String[] args) {
        Camera camera = new Camera();
        Phone phone = new Phone();
        Computer computer = new Computer();
        computer.work(phone);//手机和相机都实现了work中参数接口
        computer.work(camera);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

public class AInterface {
    public static void main(String[] args) {
        InterfaceTest iface = new A();
        InterfaceTest iface2 = new B();
    }
}
interface InterfaceTest {}
class A implements InterfaceTest {}
class B implements InterfaceTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口类型应用变量可以指向实现了接口的对象实例，这个和继承多态类似（向下转型）&lt;/p&gt;
&lt;p&gt;2.多态数组&lt;/p&gt;
&lt;p&gt;同继承的多态，我们可以使用向下转型，使用运行类型的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interface_;

public class AInterface {
    public static void main(String[] args) {
        USBInterface[] usbInterfaces = new USBInterface[3];
        usbInterfaces[0] = new PhoneA();
        usbInterfaces[1] = new PhoneB();
        usbInterfaces[2] = new PhoneA();
        for (int i = 0; i &amp;lt; usbInterfaces.length; i++) {
            usbInterfaces[i].start();
            if (usbInterfaces[i] instanceof PhoneA) {
                ((PhoneA) usbInterfaces[i]).call();
            }
        }
    }
}
interface USBInterface {
    void start();
}

class PhoneA implements USBInterface {
    public void start() {
        System.out.println(&quot;Phone A start&quot;);
    }

    public void call() {
        System.out.println(&quot;Phone A call&quot;);
    }
}

class PhoneB implements USBInterface {
    public void start() {
        System.out.println(&quot;Phone B start&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.接口的多态传递&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.interfacearr;

public class InterfacePoly {
    IG ig = new Teacher();//接口类型可以指向实现接口的实例对象
    IH ih = new Teacher();//因为IG继承于IH，所以teacher也实现了IG的接口
}

interface IH {
    void teach();
}
interface IG extends IH { }

class Teacher implements IG {
    //teacher也需要实现IG继承的IH接口
    public void teach() {
        System.out.println(&quot;Teacher&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;内部类&lt;/h2&gt;
&lt;p&gt;一个类的内部内嵌套了另外的一个类，内部的类称作内部类，是类的五大成员之一：属性，方法， 构造器，代码块，内部类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A {
	class Inner {
		//内部类	
	}
}

class B {
	//其他类
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类的最大特点是可以直接访问私有属性，并且可以体现出类与类之间的包含关系，底层源码有大量的内部类&lt;/p&gt;
&lt;p&gt;有四种内部类&lt;/p&gt;
&lt;p&gt;第一类：定义在外部类局部上（比如方法内）&lt;/p&gt;
&lt;p&gt;1.局部内部类&lt;/p&gt;
&lt;p&gt;2.匿名内部类&lt;/p&gt;
&lt;p&gt;第二类：定义在外部类的成员位置上&lt;/p&gt;
&lt;p&gt;3.成员内部类（没用static修饰）&lt;/p&gt;
&lt;p&gt;4.静态内部类（使用static修饰）&lt;/p&gt;
&lt;h3&gt;局部内部类&lt;/h3&gt;
&lt;p&gt;1.可以直接访问外部类的所有成员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Outer {
    private int n1 = 100;
    public Outer(int n1) {
        this.n1 = n1;
    }

    {
        System.out.println(&quot;代码块&quot;);
    }

    public void teach() {
        System.out.println(n1 + 1);
    }

    public void Print() {
        class Inner {//内部类
            public void function() {
                System.out.println(n1);//访问外部类属性
                teach();//访问外部类的方法
            }
        }
        System.out.println(n1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.不能添加访问修饰符，因为它的地位是一个局部变量，但是可以使用final修饰，内部类可以被类继承&lt;/p&gt;
&lt;p&gt;3.作用域仅限于定义它的方法或代码块中&lt;/p&gt;
&lt;p&gt;4.局部内部类访问外部类成员方式：直接访问&lt;/p&gt;
&lt;p&gt;5外部类成员访问内部类方式：创建对象，再进行访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Main {//其他类
    public static void main(String[] args) {
        Outer outer = new Outer(1);
        outer.Print();
    }
}

class Outer {
    private int n1 = 100;
    public Outer(int n1) {
        this.n1 = n1;
    }

    {
        System.out.println(&quot;代码块&quot;);
    }

    public void teach() {
        System.out.println(n1 + 1);
    }


    public void Print() {
        class Inner {//内部类
            public void function() {
                System.out.println(n1);
                teach();
            }
        }
        System.out.println(n1);
        Inner inner = new Inner();//先创建对象
        inner.function();//在进行调用
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.外部其他类不可以访问内部类&lt;/p&gt;
&lt;p&gt;7.如果外部类和内部类的成员重名的时候，默认遵循就近原则，如果想访问外部类的成员可以使用 外部类名.this.成员 访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Main {//其他类
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.Print();
    }
}

class Outer {
    private int n1 = 100;
    {
        System.out.println(&quot;代码块&quot;);
    }

    public void Print() {
        class Inner {//内部类
            private int n1 = 200;
            public void function() {
                System.out.println(n1);//200，就近原则
                System.out.println(Outer.this.n1);//100，Outer.this本质是指的是Outer类的对象实例
            }
        }
        Inner inner = new Inner();
        inner.function();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;匿名内部类（重要！！）&lt;/h3&gt;
&lt;p&gt;本质是一个类，是一个内部类，是匿名的，同时还是一个对象&lt;/p&gt;
&lt;h4&gt;个人理解：&lt;/h4&gt;
&lt;p&gt;匿名内部类就是一个渣男，使用的时候创建了这样的一个内部类，这个内部类就会跑路，再也没有办法使用，还留下了一个孩子（匿名内部类的实例）。当然，孩子是有用的，可以调用匿名内部类实现的一切方法，通过这样就可以不用额外的创建一个新的类，极大的简化了代码&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new 类或接口 (参数列表) {
	类体
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码示例：传统上而言 写一个类实现接口，创建对象，在主方法中创建类的对象完成接口创建Tiger实例与调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {//外部类
    private int n1 = 10;
    public void method() {
        //基于接口的匿名内部类
        //需求分析：想使用IA接口，并创建对象
        //传统上：写一个类实现接口，创建对象
        IA tiger = new Tiger();
        tiger.cry();
    }
}

interface IA {//接口
    void cry();
}

class Tiger implements IA{//一个类
    public void cry() {
        System.out.println(&quot;Tiger 叫&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用匿名内部类实现接口&lt;/h4&gt;
&lt;p&gt;不想创建类，只想单独一次实现接口，并使用方法，可以使用匿名内部类简化（这个匿名内部类不能被使用第二次）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {//外部类
    private int n1 = 10;
    public void method() {
        //基于接口的匿名内部类
        //需求分析：想使用IA接口，并创建对象
        IA tiger = new IA() {
            public void cry() {
                System.out.println(&quot;tiger 叫&quot;);
            }
        };
        tiger.cry();
    }
}

interface IA {//接口
    void cry();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，tiger的编译类型是IA接口类型，而tiger的运行类型则是由底层系统分配名称的匿名内部类，这个类实现了接口，并立即创建实例，可以通过实例访问接口方法&lt;/p&gt;
&lt;p&gt;可以用tiger.getClass() 验证&lt;/p&gt;
&lt;p&gt;运行结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tiger 叫
运行类型为：class com.npu.inner.Outer04$1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用匿名内部类重写一个类方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {
    private int n1 = 10;
    public void method() {
        Father father = new Father(&quot;jack&quot;){
            //jack的参数会被传递给Father的构造器！！
            int age = 19;
            @Override
            public void Print() {
                System.out.println(this.name+ &quot; 年龄是 &quot; + age);
            }
        };
        father.Print();
        System.out.println(&quot;运行类型为：&quot; + father.getClass());
    }
}

class Father {
    String name;
    Father(String name) {
        this.name = name;
    }

    public void Print() {
        System.out.println(this.name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;基于抽象类的匿名内部类&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Anonymous {
    public static void main(String[] args) {
        Outer04 outer04 = new Outer04();
        outer04.method();
    }
}

class Outer04 {
    private int n1 = 10;
    public void method() {
        Animal animal = new Animal(){
            public void eat(){
                System.out.println(&quot;吃&quot;);
            }
        };
        animal.eat();
        System.out.println(&quot;运行类型为：&quot; + animal.getClass());
    }
}

abstract class Animal {
    abstract void eat();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;匿名内部类的使用细节&lt;/h4&gt;
&lt;p&gt;1.内部类创建完的结果是一个实例对象&lt;/p&gt;
&lt;p&gt;我们要访问匿名内部类的方法可以通过这个实例对象直接用.调用方法，或者可以先用一个接口，抽象类，类的引用接收，再通过这个引用调用运行类型为匿名内部类的类方法&lt;/p&gt;
&lt;p&gt;2.可以直接访问外部类的所有成员，包含私有的&lt;/p&gt;
&lt;p&gt;3.不能添加访问修饰符，因为是一个局部变量&lt;/p&gt;
&lt;p&gt;4.作用域位于处于的方法或者代码块&lt;/p&gt;
&lt;p&gt;5.如果外部类和匿名内部类成员重名的时候，就近访问内部类的成员，要使用外部类的同名成员的时候需要使用 外部类名.this.成员名&lt;/p&gt;
&lt;p&gt;外部类名.this指的是调用method()的对象&lt;/p&gt;
&lt;h3&gt;匿名内部类使用场景&lt;/h3&gt;
&lt;p&gt;1.当作实参直接传递，简洁高效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Test {
    public static void main(String[] args) {
        f1(new IL(){
           @Override
           public void show() {
               System.out.println(&quot;鸡哥&quot;);
           }
        });
    }
    //静态方法
    public static void f1(IL il){
        il.show();
    }
}

interface IL{
    void show();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传统上需要先实现一个实现了接口的类，再将类实例化，将实例传入f1，根据运行类型调用方法&lt;/p&gt;
&lt;p&gt;一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Test {
    public static void main(String[] args) {
        Cellphone cellphone = new Cellphone();

        cellphone.alarmclock(new Bell() {
            @Override
            public void ring() {
                System.out.println(&quot;ring1&quot;);
            }
        });

        cellphone.alarmclock(new Bell() {
            @Override
            public void ring() {
                System.out.println(&quot;ring2&quot;);
            }
        });
    }
}

interface Bell {
    void ring();
}

class Cellphone {
    public void alarmclock (Bell bell) {
        bell.ring();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;成员内部类&lt;/h3&gt;
&lt;p&gt;成员内部类定义在外部类的成员位置&lt;/p&gt;
&lt;p&gt;1.内部类可以访问外部类的所有成员，包含私有的&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        outer.inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    Inner inner = new Inner();
    {
        System.out.println(&quot;代码块&quot;);
    }
    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.成员内部类可以用访问修饰符修饰，因为它的地位是类的成员&lt;/p&gt;
&lt;p&gt;3.作用域为整个类体中&lt;/p&gt;
&lt;p&gt;4.访问同名成员的时候会遵循就近原则，要访问外部类的成员要使用 外部类名.this.重名成员 来进行访问&lt;/p&gt;
&lt;p&gt;5.外部其他类可以有如下的两种方式访问成员内部类&lt;/p&gt;
&lt;p&gt;1 使用外部类对象 通过new来创建一个成员内部类对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        Outer08.Inner inner = outer.new Inner();
    }
}

class Outer08 {
    private int n1 = 200;

    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 再外部类中编写一个方法返回一个Inner的实例（将第一种写为方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        Outer08.Inner inner = outer.getInner();

    }
}

class Outer08 {
    private int n1 = 200;

    class Inner {
        public void Print() {
            System.out.println(n1);
        }
    }

    public Inner getInner() {
        return new Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;静态内部类&lt;/h3&gt;
&lt;p&gt;定义在外部类的成员位置，由static修饰&lt;/p&gt;
&lt;p&gt;1.可以直接访问外部类的所有静态成员，包含私有的，但是不可以访问非静态成员&lt;/p&gt;
&lt;p&gt;2.成员内部类可以用访问修饰符修饰，因为它的地位是类的成员&lt;/p&gt;
&lt;p&gt;3.作用域为整个类体中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08 outer = new Outer08();
        outer.getInner();

    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

    public void getInner() {
        Inner inner = new Inner();
        inner.Print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.外部其他类使用静态内部类有以下几种方式&lt;/p&gt;
&lt;p&gt;1 用外部类静态创建内部类（不会创建外部类）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08.Inner inner = new Outer08.Inner();
        inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 静态方法返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.inner;

public class Member {//其他类
    public static void main(String[] args) {
        Outer08.Inner inner = Outer08.getInner();
        inner.Print();
    }
}

class Outer08 {
    private int n1 = 200;
    private static int n2 = 100;

    public static class Inner {
        public void Print() {
            System.out.println(n2);
        }
    }

    public static Inner getInner() {
        return new Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.在遇到同名成员的时候默认就近访问，要访问外部类成员需要使用 外部类名.成员访问&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Ffinal%E5%85%B3%E9%94%AE%E5%AD%97/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Ffinal%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>类方法，类变量，代码块，设计模式，final关键字</description><pubDate>Thu, 20 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;初级部分学习完成&lt;/h2&gt;
&lt;p&gt;终于完成了Java网络通讯的大作业，将整个项目的大致流程掌握，可以熟练的使用socket套接字进行TCP，UDP的网络编程，但是由于在进行项目的时候没有进行前置知识的学习，导致在多线程，异常处理，IO流的部分仍然无法自己独立完成，从这一课我将开始进入Java编程高级部分。&lt;/p&gt;
&lt;h2&gt;类变量和类方法&lt;/h2&gt;
&lt;h3&gt;类变量&lt;/h3&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class ChildGame {
    public static void main(String[] args) {
        int count = 0;//记录有几个小孩加入游戏

        Child child1 = new Child(&quot;1&quot;);
        child1.join();
        count++;
        Child child2 = new Child(&quot;2&quot;);
        child2.join();
        count++;
        Child child3 = new Child(&quot;3&quot;);
        child3.join();
        count++;

        System.out.println(&quot;一共有 &quot; + count + &quot; 小孩&quot;);
    }

}

class Child {
    private String name;

    public Child(String name) {
        this.name = name;
    }

    public void join() {
        System.out.println(this.name + &quot; join&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们会很容易发现这样做count（独立于对象）没有办法在类方法中使用，我们必须要将这个计数的功能单独提取出来，这会弱化代码的可读性（没有面向对象）较为麻烦，这个时候我们就要将count设置为类变量（静态变量）&lt;/p&gt;
&lt;p&gt;使用static关键字可以修饰一个可以供所有类同时享用的变量&lt;/p&gt;
&lt;p&gt;语法定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 static 数据类型 变量名 ; [推荐使用]
static 访问修饰符 数据类型 变量名 ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对象名.静态变量
类名.静态变量 [推荐使用]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class ChildGame {
    public static void main(String[] args) {


        Child child1 = new Child(&quot;1&quot;);
        Child child2 = new Child(&quot;2&quot;);
        Child child3 = new Child(&quot;3&quot;);

        child1.join();
        child2.join();
        child3.join();

        System.out.println(&quot;一共有 &quot; + Child.count + &quot; 小孩&quot;);
    }

}

class Child {
    private String name;
    public static int count = 0;

    public Child(String name) {
        this.name = name;
    }

    public void join() {
        System.out.println(this.name + &quot; join&quot;);
        count++;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个孩子对象实例访问到的count都是同一个，加强count和Child类的联系&lt;/p&gt;
&lt;h3&gt;类变量在内存中的布局&lt;/h3&gt;
&lt;p&gt;类变量在不同版本有不同的存放方式，有存放在Class实例尾部中（堆），也有存放在方法区的静态域之中，但是在运用的时候，只需要了解静态变量可以供所有的（同一个类）对象共享，在类加载的时候生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.println(A.count);
        //无需创建类即可访问，因为是类加载的时候count就被创建
    }
}

class A {
    public static int count = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法&lt;/h3&gt;
&lt;p&gt;类方法也叫静态方法&lt;/p&gt;
&lt;p&gt;定义形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;访问修饰符 static 数据返回类型 方法名 () {} [推荐使用]
static 访问修饰符 数据返回类型 方法名 () {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类方法的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类名.类方法名()[推荐使用]
对象名.类方法名()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法的使用场景&lt;/h3&gt;
&lt;p&gt;1.同类变量一样，在没有创建对象实例前可以通过类名来调用类方法&lt;/p&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.print(&quot;收钱前：&quot;);
        Stu.showFee();
        Stu tom = new Stu(&quot;Tom&quot;);
        Stu.payFee(100);
        Stu sony = new Stu(&quot;Sony&quot;);
        Stu.payFee(100);
        System.out.print(&quot;收钱后：&quot;);
        Stu.showFee();
    }
}

class Stu {
    private String name;
    private static double fee = 0.0;

    public Stu(String name) {
        this.name = name;
    }

    public static void payFee(double fee) {
        Stu.fee += fee;
    }

    public static void showFee() {
        System.out.println(fee);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.当方法中不涉及任何和对象相关的成员，可以将方法设计成为静态方法，提高开发效率（例如 Math 类），自己制作工具类的时候也推荐这样做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.static_;

public class VisitStatic {
    public static void main(String[] args) {
        System.out.println(Math.abs(-3));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Math源码中的abs静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int abs(int a) {
    return (a &amp;lt; 0) ? -a : a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;类方法细节&lt;/h3&gt;
&lt;p&gt;1.类方法会随着类的加载而加载，将结构信息存放在方法区&lt;/p&gt;
&lt;p&gt;2.类方法中没有this super参数，不允许使用和对象有关的关键字&lt;/p&gt;
&lt;p&gt;3.类方法只能访问类方法类变量，不可以使用普通成员和普通方法&lt;/p&gt;
&lt;p&gt;4.普通成员方法可以使用类变量，也可以使用静态方法&lt;/p&gt;
&lt;h2&gt;main方法&lt;/h2&gt;
&lt;p&gt;一个常见的main方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.main方法由java虚拟机调用，访问权限必须为public&lt;/p&gt;
&lt;p&gt;2.java虚拟机在执行main（）方法的时候不会创建对象，所以方法由static修饰&lt;/p&gt;
&lt;p&gt;3.该方法接收String类型的数组参数，该数组中保存执行java命令时所传递给所有运行类的参数，接收参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class Main {
    public static void main(String[] args) {
        for(int i = 0; i &amp;lt; args.length; i++) {
            System.out.println(&quot;第&quot;+ (i+1) + &quot;个参数&quot; + args[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在运用终端java运行class的时候，通过终端传入参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java 运行类名 第一个参数 第二个参数 第三个参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态变量和静态方法可以被对应的类直接使用，我们可以在main中使用在类中定义的静态方法和静态变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    private static String name = &quot;Hello&quot;;
    private static void Print() {
        System.out.println(name);
    }
    public static void main(String[] args) {
        Print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里不可以在main方法中使用非静态的方法变量，要使用的前提是新创建一个main的实例，通过实例对象来进行调用&lt;/p&gt;
&lt;p&gt;在IDEA继承的开发环境中可以通过如下设置传递命令行参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/73.png&quot; alt=&quot;73&quot; /&gt;&lt;/p&gt;
&lt;p&gt;输入对应的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/74.png&quot; alt=&quot;74&quot; /&gt;&lt;/p&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/75.png&quot; alt=&quot;75&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;代码块&lt;/h2&gt;
&lt;p&gt;代码块又称为初始化块，属于类中的成员是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{ } 包围起来&lt;/p&gt;
&lt;p&gt;和方法不同没有方法名，没有返回没有参数，只有方法体，不能够通过对象或者类显式调用，而是在加载类的时候，或者创建对象的时候隐式的调用&lt;/p&gt;
&lt;p&gt;使用基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[修饰符]{
	代码部分
};//;可选写或者不写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修饰符可选static修饰，分别称作（static）静态代码块，普通代码块&lt;/p&gt;
&lt;h3&gt;代码块的使用场景&lt;/h3&gt;
&lt;p&gt;1.普通代码块相当于另外一种形式的构造器，可以进行初始化的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    public static void main(String[] args) {

    }
}

class Movie {
    private String title;
    private String director;
    private int year;

    public Movie(String title, String director, int year) {
        System.out.println(&quot;Movie&quot;);
        this.title = title;
        this.director = director;
        this.year = year;
    }

    public Movie(String title) {
        System.out.println(&quot;Movie&quot;);
        this.title = title;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上的两个构造器都有输出，我们可以把相同的语句放入代码块中，在构造的时候会统一调用代码块（先调用普通代码块，后调用构造器），去除冗余&lt;/p&gt;
&lt;p&gt;代码示例如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;
public class Main {
    public static void main(String[] args) {
        Movie movie = new Movie(&quot;2&quot;);
    }
}

class Movie {
    private String title;
    private String director;
    private int year;

    {
        System.out.println(&quot;Movie&quot;);
    }
    
    public Movie(String title, String director, int year) {
        this.title = title;
        this.director = director;
        this.year = year;
    }

    public Movie(String title) {
        this.title = title;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码块的使用细节&lt;/h3&gt;
&lt;h4&gt;1.静态代码块在类加载的时候执行，只会执行一次，如果是普通代码块每创建一个对象就执行一次&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        new AA();
       
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.类什么时候被加载（只会加载一次）&lt;/h4&gt;
&lt;p&gt;创建对象实例的时候&lt;/p&gt;
&lt;p&gt;创建子类对象实例父类会被加载&lt;/p&gt;
&lt;p&gt;使用类的静态成员变量的时候，代码块被加载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        new BB();
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }
}

class BB extends AA {
    static {
        System.out.println(&quot;BB静态代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先加载父类代码块，在加载子类代码块&lt;/p&gt;
&lt;h4&gt;3.普通代码块在创建对象实例的时候被隐式调用，创建多少次调用多少次，但是在使用静态成员的时候，普通代码块不会被执行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        System.out.println(AA.i);
    }
}

class AA {
    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }

    {
        System.out.println(&quot;AA的普通代码块&quot;);
    }

    public static int i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上输出为（因为没有创建对象不调用普通代码块）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AA静态代码块
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4.创建一个对象的时候，在一个类的调用顺序是：&lt;/h4&gt;
&lt;p&gt;1调用静态代码块，和静态属性初始化 优先级一致（和前后顺序有关）&lt;/p&gt;
&lt;p&gt;2调用普通代码块和普通属性的初始化&lt;/p&gt;
&lt;p&gt;3调用构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        AA a = new AA();
    }
}

class AA {
    public static int i = getN1();
    private int j = getJ();

    public AA(){
        System.out.println(&quot;构造器&quot;);
    }

    public static int getN1() {
        System.out.println(&quot;静态方法调用&quot;);
        return 100;
    }

    public int getJ() {
        System.out.println(&quot;普通方法调用&quot;);
        return 200;
    }

    static {
        System.out.println(&quot;AA静态代码块&quot;);
    }

    {
        System.out.println(&quot;AA的普通代码块&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;静态方法调用
AA静态代码块
普通方法调用
AA的普通代码块
构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;5.构造器的最前端隐含了super和普通代码块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        BB b = new BB();
    }
}

class AA {
    {
        System.out.println(&quot;AA普通代码块&quot;);
    }

    public AA () {
        //super
        //本类的普通代码块
        System.out.println(&quot;AA构造器被调用&quot;);
    }
}

class BB extends AA {
    {
        System.out.println(&quot;BB普通代码块&quot;);
    }

    public BB() {
        //super
        //本类的普通代码块
        System.out.println(&quot;BB构造器被调用&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AA普通代码块
AA构造器被调用
BB普通代码块
BB构造器被调用
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;6.静态代码块只能调用静态成员，普通代码块可以调用任意成员&lt;/h4&gt;
&lt;h2&gt;设计模式（单例）&lt;/h2&gt;
&lt;p&gt;设计模式是在大量的实践和总结下优选的代码结构，编程风格，以及解决问题的思考方式，设计模式类似于经典的棋谱，使用的时候套公式是最好的方式&lt;/p&gt;
&lt;p&gt;单例模式：要求采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法&lt;/p&gt;
&lt;p&gt;单例模式有两种：饿汉式，懒汉式&lt;/p&gt;
&lt;h3&gt;饿汉式&lt;/h3&gt;
&lt;p&gt;1.将构造器私有化（防止new）&lt;/p&gt;
&lt;p&gt;2.类的内部构造对象&lt;/p&gt;
&lt;p&gt;3.向外暴露一个静态的公共方法getInstance&lt;/p&gt;
&lt;p&gt;以下是代码具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        Game instance = Game.getInstance();
        String string = instance.toString();
        System.out.println(string);
    }
}

class Game {
    private String name;
    //将构造器私有化
    private Game (String name) {
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game = new Game(&quot;饿汉&quot;);
    //提供对外静态调用方法
    public static Game getInstance() {
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就算调用接口再建立一个Game引用指向的也是由静态创建的实例&lt;/p&gt;
&lt;p&gt;之所以是饿汉式，是因为如果要调用Game中的静态成员，就会提前自动创建对象实例，可能会造成资源的浪费(对象实例没有被使用)&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        int j = Game.i;
    }
}

class Game {
    public static int i = 0;
    private String name;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器被调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game = new Game(&quot;饿汉&quot;);
    //提供对外静态调用方法
    public static Game getInstance() {
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造器被调用，结果输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;构造器被调用
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;懒汉式&lt;/h3&gt;
&lt;p&gt;事实上是懒汉式的改进&lt;/p&gt;
&lt;p&gt;1.将构造器私有化&lt;/p&gt;
&lt;p&gt;2.定义一个static静态属性对象（没用new创建实例）&lt;/p&gt;
&lt;p&gt;3.提供一个public的static方法，在方法中创建实例&lt;/p&gt;
&lt;p&gt;以下是代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        Game instance = Game.getInstance();
        String string = instance.toString();
        System.out.println(string);
    }
}

class Game {
    private String name;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game;
    //提供对外静态调用方法
    public static Game getInstance() {
        if (game == null) {
            game = new Game(&quot;懒汉&quot;);
        }
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在类加载的时候不会立即创建实例对象，而是通过静态的方法中创建&lt;/p&gt;
&lt;p&gt;而通过判断语句可以使得只创建一个实例对象&lt;/p&gt;
&lt;p&gt;这样就可以省去单例对象资源的浪费&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class CodeBlock {
    public static void main(String[] args) {
        System.out.println(Game.i);
    }
}

class Game {
    private String name;
    public static int i = 0;
    //将构造器私有化
    private Game (String name) {
        System.out.println(&quot;构造器调用&quot;);
        this.name = name;
    }
    //初始化创建静态实例
    private static Game game;
    //提供对外静态调用方法
    public static Game getInstance() {
        if (game == null) {
            game = new Game(&quot;懒汉&quot;);
        }
        return game;
    }

    public String toString() {
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;补充内容&lt;/h3&gt;
&lt;p&gt;饿汉式不存在线程安全问题，而懒汉式存在线程安全问题（多个线程同时判断game == null 从而创建多个对象）&lt;/p&gt;
&lt;h2&gt;final关键字&lt;/h2&gt;
&lt;p&gt;final可以修饰类，属性，方法，局部变量&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;h4&gt;1.当不希望类被继承的时候使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

final class A {
//用final修饰
}

class B extends A {
//错误
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.当不希望父类的某个方法被子类覆盖（重写），可以用final修饰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

class A {
    final public void Print(){//final修饰，不允许重写
        System.out.println(1);
    }
}

class B extends A {
    @Override//报错
    public void Print(){
        System.out.println(2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;3.当不希望类的某个值被修改，可以用final修饰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static final double Pi = 3.14;
    public static void main(String[] args) {
        Pi = 9;//报错，final修饰的属性不允许修改
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4.当不希望某个局部变量被修改&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {

    }
}

class Tool {
    public void test() {
        final double i = 2.0;
        i = 1.0;//报错，不允许修改final修饰的局部变量
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;final细节&lt;/h3&gt;
&lt;p&gt;1.final修饰的属性被称作常量，一般用XX_XX_XX_XX来命名&lt;/p&gt;
&lt;p&gt;2.final修饰的属性需要在定义的时候初始化（定义时，构造器，代码块选择其一）&lt;/p&gt;
&lt;p&gt;3.如果final修饰的属性使静态的，则初始化的位置只能是在定义时，静态代码块（注意不可以是在构造器中初始化，因为静态变量的赋值在构造器之前）&lt;/p&gt;
&lt;p&gt;4.如果不是final类，但是含有final方法，不可以重修final方法，但是类可以被继承&lt;/p&gt;
&lt;p&gt;5.一般来说类用final修饰，就没有必要将类中的方法用final修饰了&lt;/p&gt;
&lt;p&gt;6.final不能修饰构造器&lt;/p&gt;
&lt;p&gt;7.final和static往往搭配使用，效率更高，不会导致类的加载，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu;

public class final_ {
    public static void main(String[] args) {
        int num = Tool.num;
    }
}

class Tool {
    public final static int num = 10000;
    static {
        System.out.println(&quot;static block&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器优化，不会加载静态代码块&lt;/p&gt;
&lt;p&gt;8.包装类例如Integer，Double，Float，Boolean都是final类&lt;/p&gt;
&lt;p&gt;今天的内容就此结束，明天将会学习抽象类，接口，内部类&lt;/p&gt;
</content:encoded></item><item><title>项目标准开发流程</title><link>https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>企业标准开发流程</description><pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;项目开发流程&lt;/h1&gt;
&lt;p&gt;需求分析---设计阶段---编码实现---测试阶段---实施阶段&lt;/p&gt;
&lt;h2&gt;1.需求分析（需求分析师）&lt;/h2&gt;
&lt;p&gt;目的是产出一个需求分析报告，包含客户具体要求，项目功能&lt;/p&gt;
&lt;h2&gt;2.设计阶段（架构师/项目经理）&lt;/h2&gt;
&lt;p&gt;设计工作UML类图，流程图，模块设计，数据库，架构，原型开发 组建团队&lt;/p&gt;
&lt;h2&gt;3.实现阶段（程序员/码农）&lt;/h2&gt;
&lt;p&gt;完成架构师的模块功能，测试自己的模块&lt;/p&gt;
&lt;h2&gt;4.测试阶段（测试工程师）&lt;/h2&gt;
&lt;p&gt;单元测试，测试用例，白盒测试，黑盒测试，集成测试&lt;/p&gt;
&lt;h2&gt;5.实施阶段（实施工程师）&lt;/h2&gt;
&lt;p&gt;将项目部署到客户的平台，保证运行正常，要求对环境的部署能力要高&lt;/p&gt;
&lt;h2&gt;6.维护阶段（不固定人员）&lt;/h2&gt;
&lt;p&gt;Debug，项目升级，发现bug&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid><description>Java多用户通讯系统设计</description><pubDate>Mon, 17 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;多用户通信系统设计&lt;/h1&gt;
&lt;p&gt;https://github.com/thrinisty/Multi-user-communication-system.git&lt;/p&gt;
&lt;h2&gt;功能实现&lt;/h2&gt;
&lt;p&gt;1.用户登录&lt;/p&gt;
&lt;p&gt;2.拉取用户列表&lt;/p&gt;
&lt;p&gt;3.私聊&lt;/p&gt;
&lt;p&gt;4.群聊&lt;/p&gt;
&lt;p&gt;5.发文件&lt;/p&gt;
&lt;h2&gt;思路分析&lt;/h2&gt;
&lt;p&gt;当客户端与服务端产生链接的时候，服务端会产生一个socket，必须要创建一个线程来持有并管理产生的socket&lt;/p&gt;
&lt;p&gt;服务器端的多个线程需要一个管理线程的集合，用以后续的服务器推送新闻&lt;/p&gt;
&lt;p&gt;每一个客户端也可能会创建多个线程，和服务器端通信，需要客户端线程的管理集合（hashmap）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/66.png&quot; alt=&quot;66&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;服务端&lt;/h3&gt;
&lt;p&gt;1.当客户端连接到服务器时得到了socket&lt;/p&gt;
&lt;p&gt;2.启动了一个线程，该线程持有socket，socket是线程的属性&lt;/p&gt;
&lt;p&gt;3.为了管理线程，用集合hashmap管理线程，将线程放入集合&lt;/p&gt;
&lt;h3&gt;客户端&lt;/h3&gt;
&lt;p&gt;1.和服务端通信的时候使用对象的方式，可以使用对象流来进行读写&lt;/p&gt;
&lt;p&gt;2.当客户端连接到服务器端时，会得到socket&lt;/p&gt;
&lt;p&gt;3.启动一个线程，该线程持有socket&lt;/p&gt;
&lt;p&gt;4.为了管理线程，用集合hashmap管理线程，将线程放入集合&lt;/p&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;h3&gt;1.用户登录&lt;/h3&gt;
&lt;p&gt;创建User对象，表示一个用户信息（如果对象要在IO中传输，对象需要进行序列化）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.io.Serializable;

//表示一个用户信息
public class User implements Serializable {
    private static final long serialVersionUID = 1L;//增强兼容性
    private String userId;//用户名
    private String password;

    User(String userId, String password) {
        this.userId = userId;
        this.password = password;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建Message对象，表示客户端和服务端通信时的消息对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.io.Serializable;

//表示客户端和服务端通信时的消息对象
public class Message implements Serializable {
    private static final long serialVersionUID = 1L;
    private String sender;//发送者
    private String getter;//接收者
    private String content;//消息内容
    private String sendTime;//发送时间
    private String mesType;//消息类型【可以在接口定义消息类型】

    public String getMesType() {
        return mesType;
    }

    public void setMesType(String mesType) {
        this.mesType = mesType;
    }

    public String getSender() {
        return sender;
    }

    public void setSender(String sender) {
        this.sender = sender;
    }

    public String getGetter() {
        return getter;
    }

    public void setGetter(String getter) {
        this.getter = getter;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getSendTime() {
        return sendTime;
    }

    public void setSendTime(String sendTime) {
        this.sendTime = sendTime;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MessageType接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

public interface MessageType {
    String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//登录成功
    String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;客户端聊天的菜单界面（内部逻辑）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqcommon;

import java.util.Scanner;

public class QQview {
    //显示主菜单
    private boolean loop = true;
    private String key = &quot;&quot;;
    Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        QQview qqview = new QQview();
        qqview.mainMenu();
        System.out.println(&quot;退出聊天系统&quot;);
    }

    public void mainMenu() {
        while (loop) {
            System.out.println(&quot;==========欢迎来到网络登录系统==========&quot;);
            System.out.println(&quot;\t\t 1 登陆系统&quot;);
            System.out.println(&quot;\t\t 9 退出系统&quot;);
            System.out.print(&quot;请输入1-9： &quot;);
            key = scanner.next();
            switch (key) {
                case &quot;1&quot;:
                    System.out.println(&quot;登陆系统&quot;);
                    System.out.println(&quot;请输入用户号码： &quot;);
                    String userId = scanner.next();
                    System.out.println(&quot;请输入用户密码： &quot;);
                    String password = scanner.next();
                    //将用户密码和用户名称发送到服务端，暂定
                    if (true) {
                        System.out.println(&quot;==========登录成功==========&quot;);
                        while (loop) {
                            System.out.println(&quot;==========网络通讯系统==========&quot;);
                            System.out.println(&quot;欢迎用户&quot; + userId);
                            System.out.println(&quot;\t\t 1 显示在线用户列表&quot;);
                            System.out.println(&quot;\t\t 2 群发消息&quot;);
                            System.out.println(&quot;\t\t 3 私聊消息&quot;);
                            System.out.println(&quot;\t\t 4 发送文件&quot;);
                            System.out.println(&quot;\t\t 9 退出系统&quot;);
                            System.out.print(&quot;请输入1-9 &quot;);
                            key = scanner.next();
                            switch (key) {
                                case &quot;1&quot;:
                                    System.out.println(&quot;显示在线用户列表&quot;);
                                    break;
                                case &quot;2&quot;:
                                    System.out.println(&quot;群发消息&quot;);
                                    break;
                                case &quot;3&quot;:
                                    System.out.println(&quot;私聊消息&quot;);
                                    break;
                                case &quot;4&quot;:
                                    System.out.println(&quot;发送文件&quot;);
                                    break;
                                case &quot;9&quot;:
                                    System.out.println(&quot;退出系统&quot;);
                                    loop = false;
                                    break;
                            }

                        }
                    } else {
                        System.out.println(&quot;==========登陆失败==========&quot;);
                    }
                    break;
                case &quot;9&quot;:
                    System.out.println(&quot;==========登陆退出==========&quot;);
                    loop = false;
                    break;
            }

        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;线程服务类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqclient.service;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.net.Socket;


public class UserClientService {
    private User u = new User();//因为要在其他地方使用属性
    private Socket socket;

    public Socket getSocket() {
        return socket;
    }

    public void setSocket(Socket socket) {
        this.socket = socket;
    }

    //用以判断是否登录正确，消息来自于服务端按
    public boolean checkUser(String userId, String password) {
        boolean b = false;
        u.setUserId(userId);
        u.setPassword(password);
        //连接到服务器，发送u对象
        try {
            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(u);//发送User对象
            
            //读取收到的Message对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();
            if(ms.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)){
                //创建一个和服务器端保持通信的线程-&amp;gt;创建线程类 ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread = new ClientConnectServerThread(socket);
                clientConnectServerThread.start();
                //为了方便管理，将线程放入一个集合中ManageClientConnectServerThread
                ManageClientConnectServerThread.addClientConnectServerThread(userId, clientConnectServerThread);
                b = true;
            } else {
                //登陆失败不启动线程，关闭没有用到的socket
                socket.close();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中创建的线程是一个类，含有socket对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端监听9999端口，等待客户端连接，保持通信
public class QQServer {
    private ServerSocket ss = null;

    public QQServer() {
        try {
            System.out.println(&quot;服务端在9999监听...&quot;);
            ss = new ServerSocket(9999);
            while(true) {
                Socket socket = ss.accept();
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                User u = (User) ois.readObject();
                //将数据进行验证，但是这没有数据库，模拟一个验证流程
                Message message = new Message();
                if(u.getUserId().equals(&quot;100&quot;) &amp;amp;&amp;amp; u.getPassword().equals(&quot;123456&quot;)) {
                    //登陆成功，向客户端发送连接信息
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    oos.writeObject(message);

                    //创建线程持有socket对象
                    ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, u.getUserId());
                    serverConnectClientThread.start();

                    //将线程放入集合
                    ManageClientThreads.addClientThread(u.getUserId(),serverConnectClientThread);
                } else {
                    //登陆失败
                    System.out.println(&quot;用户 &quot; + u.getUserId() + &quot;登录无效&quot;);
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    socket.close();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //如果服务端退出循环，服务器端不再监听
            try{
                ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
true){
            try{
                System.out.println(&quot;客户端线程，等待读取服务器数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();//没有发送对象 线程发送阻塞
                //其余处理
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    public Socket getSocket() {
        return socket;
    }

    public void setSocket(Socket socket) {
        this.socket = socket;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;又在服务类里面创建了一个现成的集合对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqclient.service;

import java.util.HashMap;

//管理客户端带服务端线程的一个类
public class ManageClientConnectServerThread {
    //把多个线程放入一个hashmap集合中，key是用户id， value是线程
    public static HashMap&amp;lt;String, ClientConnectServerThread&amp;gt; hm = new HashMap&amp;lt;&amp;gt;();

    //将线程加入
    public static void addClientConnectServerThread(String userId, ClientConnectServerThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }
    //用id取出线程
    public static ClientConnectServerThread getClientConnectServerThread(String userId) {
        return hm.get(userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;基本的服务流程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;
import com.npu.qqcommon.MessageType;
import com.npu.qqcommon.User;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端监听9999端口，等待客户端连接，保持通信
public class QQServer {
    private ServerSocket ss = null;

    public QQServer() {
        try {
            System.out.println(&quot;服务端在9999监听...&quot;);
            ss = new ServerSocket(9999);
            while(true) {
                Socket socket = ss.accept();
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());

                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                User u = (User) ois.readObject();
                //将数据进行验证，但是这没有数据库，模拟一个验证流程 在后续更改为checkUser()
                Message message = new Message();
                if(u.getUserId().equals(&quot;100&quot;) &amp;amp;&amp;amp; u.getPassword().equals(&quot;123456&quot;)) {
                    //登陆成功，向客户端发送连接信息
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    oos.writeObject(message);

                    //创建线程持有socket对象

                    //将线程放入集合

                } else {

                    //登陆失败
                }

            }
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {

        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的创建线程对象如下，重写了线程运行的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import com.npu.qqcommon.Message;

import java.io.ObjectInputStream;
import java.net.Socket;

//该类对该类的对象和客户端保持连接，拥有一个socket
public class ServerConnectClientThread extends Thread {
    Socket socket = null;
    private String userId = &quot;&quot;;//连接到服务器的用户id

    public ServerConnectClientThread(Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

   @Override
    public void run() {
        while (true) {
            try{
                System.out.println(&quot;正在尝试读取客户端数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();
                //等待使用的数据
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在服务器中创建线程的时候将线程放入一个集合中统一管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.qqserver.server;

import java.util.HashMap;

//该类用于管理与客户端通讯的线程
public class ManageClientThreads {
    private static HashMap&amp;lt;String, ServerConnectClientThread&amp;gt; hm = new HashMap&amp;lt;&amp;gt;();

    public static void addClientThread(String userId, ServerConnectClientThread ServerConnectClientThread) {
        hm.put(userId, ServerConnectClientThread);
    }

    public static ServerConnectClientThread getClientThread(String userId) {
        return hm.get(userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;判断账户密码&lt;/h4&gt;
&lt;p&gt;在上述中我们服务器判断账号密码是否合法采用的是账户为100 密码为123456&lt;/p&gt;
&lt;p&gt;现在进行功能上的修改：更改为指定的数个账户&lt;/p&gt;
&lt;p&gt;判断方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean checkUser(String userId, String password) {
        User user = validUsers.get(userId);
        if(user == null) {

            System.out.println(&quot;用户id错误，不存在用户&quot; + userId);
            return false;
        }
        if(!password.equals(user.getPassword())) {
            System.out.println(&quot;用户密码错误&quot;);
            return false;
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中对应的hashmap集合（在静态中初始化一些用户）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; private static HashMap&amp;lt;String, User&amp;gt; validUsers = new HashMap&amp;lt;&amp;gt;();
    static {
        validUsers.put(&quot;100&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;200&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;300&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;400&quot;, new User(&quot;100&quot;, &quot;123456&quot;));
        validUsers.put(&quot;李昊轩&quot;, new User(&quot;李昊轩&quot;, &quot;123456&quot;));
        validUsers.put(&quot;王凌&quot;, new User(&quot;王凌&quot;, &quot;123456&quot;));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此多用户登录功能已经完成，下面进入拉取用户列表的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/67.png&quot; alt=&quot;67&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;2.拉取用户列表&lt;/h3&gt;
&lt;h4&gt;接口扩展&lt;/h4&gt;
&lt;p&gt;扩展MessageType接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface MessageType {
    String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//登录成功
    String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//登录失败
    String MESSAGE_COMM_MES = &quot;3&quot;;//普通信息包
    String MESSAGE_GET_ONLINE_FRIEND = &quot;4&quot;;//要求返回在线用户列表
    String MESSAGE_RET_ONLINE_FRIEND = &quot;5&quot;;//返回在线用户列表
    String MESSAGE_CLIENT_EXIT = &quot;6&quot;;//客户端请求退出
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;在客户端菜单栏中调用特定方法发送给服务器用户列表请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (key) {
case &quot;1&quot;:
     System.out.println(&quot;显示在线用户列表&quot;);
	userClientService.onlineFriendList();
	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端服务类的发送请求方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onlineFriendList() {
        Message ms = new Message();
        ms.setMesType(MessageType.MESSAGE_GET_ONLINE_FRIEND);
        //发送给服务器，先得到当前线程的socket对应的输出流
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                    .getClientConnectServerThread(u.getUserId()).getSocket().getOutputStream());
            oos.writeObject(ms);//发送请求
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在客户端线程中如果收到的message类型是在线用户列进行的相关处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run() {
        //因为持续通信持续循环
        while(true){
            try{
                System.out.println(&quot;客户端线程，等待读取服务器数据&quot;);
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();//没有发送对象 线程发送阻塞
                //其余处理,后续需要使用
                //判断message类型，处理后续内容

                //当读到用户列表请求
                if(message.getMesType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) {
                    //取出在线列表然后返回
                    String[] onlineUsers = message.getContent().split(&quot; &quot;);
                    System.out.println(&quot;======当前在线用户======&quot;);
                    for (int i = 0; i &amp;lt; onlineUsers.length; i++) {
                        System.out.println(&quot;用户：&quot; + onlineUsers[i]);
                    }
                } else {
                    System.out.println(&quot;暂时不处理&quot;);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;在线程中处理收到的Message信息&lt;/p&gt;
&lt;p&gt;如果收到的Message信息是请求获取列表，则构造信息返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run() {
    while (true) {
        try{
            System.out.println(&quot;用户id &quot; + userId);
            System.out.println(&quot;正在尝试读取客户端数据&quot;);
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message message = (Message) ois.readObject();
            //等待使用的数据
            //更具Message类型处理后续
            if(message.getMesType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) {
                //客户端要求返回在线用户列表
                System.out.println(userId + &quot; 需要在线列表&quot;);
                String onlineUser = ManageClientThreads.getOnlineUser();
                //拿到了信息构造一个Message
                Message message2 = new Message();
                message2.setMesType(MessageType.MESSAGE_RET_ONLINE_FRIEND);
                message2.setContent(onlineUser);
                message2.setGetter(message.getSender());
                //写入Message
                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                oos.writeObject(message2);
                System.out.println(&quot;已发送在线用户列表给 &quot; + userId);

            }else {
                System.out.println(&quot;收到服务器消息，暂不处理&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2.5.无异常退出&lt;/h3&gt;
&lt;p&gt;问题一：当在二级菜单 输入设置为9 退出的时候也没办法正常退出，因为服务器通讯的线程没有结束&lt;/p&gt;
&lt;p&gt;问题二：当客户端断开连接的时候，服务线程还在不断地尝试获取客户端消息，造成了报错&lt;/p&gt;
&lt;p&gt;我们需要一个好的方法进行无异常退出&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;客户端没有移除集合中的线程是因为最终客户端只拥有一个线程&lt;/p&gt;
&lt;p&gt;1.在主函数中调用方法给服务器端发送一个退出的Message对象&lt;/p&gt;
&lt;p&gt;2.调用客户端 System.exit(0) 进行退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void logout() {
        Message ms = new Message();
        ms.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
        ms.setSender(u.getUserId());
        try {
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(ms);
            System.out.println(&quot;退出系统&quot;);
            System.exit(0);//结束进程
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;1.接收message消息，当消息为退出的时候执行下述步骤&lt;/p&gt;
&lt;p&gt;2.移除集合中的对应线程&lt;/p&gt;
&lt;p&gt;3.服务器端关闭线程持有的socket,再退出线程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) {
       System.out.println(userId + &quot; 准备退出&quot;);
       //将客户端的线程从集合中删除
       ManageClientThreads.removeClientThread(userId);
       socket.close();
       //退出while循环
       break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/68.png&quot; alt=&quot;68&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/69.png&quot; alt=&quot;69&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;3.私聊&lt;/h3&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;1.接收用户希望给某个其他的在线用户聊天内容&lt;/p&gt;
&lt;p&gt;2.将消息构建成Message对象，通过对应的socket发送给服务器&lt;/p&gt;
&lt;p&gt;3.在通讯线程中收到其他的客户端发送的消息并显示&lt;/p&gt;
&lt;p&gt;在菜单中调用方法发送私聊&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;3&quot;:
    System.out.println(&quot;私聊消息&quot;);
    System.out.print(&quot;请输入要聊天的用户: &quot;);
    String getterId = scanner.next();
    System.out.print(&quot;请输入想说的话&quot;);
    String content = scanner.next();
    //编写一个方法完成发送
    messageClientService.sendMessageToOne(content, userId, getterId);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私聊实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void sendMessageToOne(String content, String senderId, String getterId) {
    Message ms = new Message();
    ms.setMesType(MessageType.MESSAGE_COMM_MES);//设置为普通消息类型
    ms.setSender(senderId);
    ms.setGetter(getterId);
    ms.setContent(content);
    System.out.println(senderId + &quot;对&quot; + getterId + &quot;私聊 内容为：&quot; + content);

    try {
        ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                .getClientConnectServerThread(senderId).getSocket().getOutputStream());
        oos.writeObject(ms);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收到私聊消息后显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_COMM_MES)) {
    //将消息显示出来
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 的消息，内容如下：&quot;);
    System.out.println(message.getContent());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;1.可以读取到客户端发送给某个客户的消息&lt;/p&gt;
&lt;p&gt;2.从管理的线程集合中根据发送的目标用户id，获取socket&lt;/p&gt;
&lt;p&gt;3.将message对象转发给客户&lt;/p&gt;
&lt;p&gt;服务器只完成转发的工作，当收到转发消息时转发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if(message.getMesType().equals(MessageType.MESSAGE_COMM_MES)) {
    //根据收到的消息中获取发送的对象进行转发
    ServerConnectClientThread serverConnectClientThread =
            ManageClientThreads.getClientThread(message.getGetter());
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread
            .getSocket().getOutputStream());
    oos.writeObject(message);//发送，如果客户不在线可以保存到数据库中
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.群聊&lt;/h3&gt;
&lt;p&gt;大体和私聊类似&lt;/p&gt;
&lt;p&gt;在Message消息类型补充&lt;/p&gt;
&lt;p&gt;String MESSAGE_TO_ALL_MES = &quot;7&quot;;//群发消息&lt;/p&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;菜单调用功能方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;2&quot;:
    System.out.println(&quot;请输入群发的话，内容将被发给所有的在线用户&quot;);
    String s = scanner.next();
    //调用方法将字符串发送给服务器进行广播
    messageClientService.sendMessageToAll(s, userId);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;群发消息到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void sendMessageToAll(String content, String senderId) {
    Message ms = new Message();
    ms.setMesType(MessageType.MESSAGE_TO_ALL_MES);//设置为普通消息类型
    ms.setSender(senderId);
    ms.setContent(content);
    System.out.println(senderId + &quot;群发消息，内容为：&quot; + content);

    try {
        ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                .getClientConnectServerThread(senderId).getSocket().getOutputStream());
        oos.writeObject(ms);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收到群发消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 群发的消息，内容如下：&quot;);
    System.out.println(message.getContent());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务端&lt;/h4&gt;
&lt;p&gt;当收到消息为群发时，中介群发给除发送者外的所有用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) {
    //需要遍历线程的管理集合逐个发送
    HashMap&amp;lt;String, ServerConnectClientThread&amp;gt; hm = ManageClientThreads.getHm();
    Iterator&amp;lt;String&amp;gt; interator = hm.keySet().iterator();
    while (interator.hasNext()) {
        //取出在线用户ID
        String onLineUserId = interator.next().toString();
        if(!onLineUserId.equals(message.getSender())) {
            ObjectOutputStream oos = new ObjectOutputStream(hm.get
                    (onLineUserId).getSocket().getOutputStream());
                oos.writeObject(message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此群发消息功能完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/70.png&quot; alt=&quot;70&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;5.发文件&lt;/h3&gt;
&lt;p&gt;首先我们要扩展Message类的定义，在类中添加bytes数组，以及一些必要的成员变量，拓展MessageType，定义新的消息类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private byte[] fileBytes;//用于发送文件
private int fileSize = 0;//文件大小
private String dest;//将文件传输到的位置
private String src;//发送的文件路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;客户端&lt;/h4&gt;
&lt;p&gt;1.将指定路径下的文件输出流转换为字节数组&lt;/p&gt;
&lt;p&gt;2.将字节数组封装在message对象中&lt;/p&gt;
&lt;p&gt;3.将message对象发送，在服务器进行相应处理&lt;/p&gt;
&lt;p&gt;4.接收到文件message对象的时候将message对象中的字节数组运用文件输入流存储至指定的目录下&lt;/p&gt;
&lt;p&gt;在菜单栏中调用文件类的功能方法，完成向服务器传送message消息（其中包含了文件的内容）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &quot;4&quot;:
    System.out.print(&quot;请输入发送对象 &quot;);
    String target = scanner.next();
    System.out.print(&quot;请输入要发送的文件路径 &quot;);
    //e:\\1.jpg  e:\\2.jpg
    String filePath = scanner.next();
    System.out.print(&quot;请输入保存至对方电脑的文件路径 &quot;);
    String savePath = scanner.next();
    fileClientService.sendFileToOne(filePath, savePath, userId, target);
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sendFileToOne具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FileClientService {
    public void sendFileToOne(String src, String dest, String senderId, String getterId) {
        //构造message信息
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_FILE_MES);
        message.setSender(senderId);
        message.setDest(dest);
        message.setGetter(getterId);
        message.setSrc(src);
        //读取文件内容
        FileInputStream fileInputStream = null;
        byte[] fileBytes = new byte[(int)new File(src).length()];

        try {
            fileInputStream = new FileInputStream(src);
            fileInputStream.read(fileBytes);
            //将字节数组放入message
            message.setFileBytes(fileBytes);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if(fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread
                    .getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发送目录 &quot; + message.getSrc() + &quot;目录文件至 &quot;
                + message.getGetter() + &quot; 的目录 &quot; + message.getDest());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运用线程来接收来自服务器的文件相关message，将其中的数据保存在指定目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) {
    System.out.println(&quot;\n收到来自 &quot; + message.getSender() + &quot; 的文件&quot;);
    FileOutputStream fos = new FileOutputStream(message.getDest());
    fos.write(message.getFileBytes());
    fos.close();
    System.out.println(&quot;文件保存在目录 &quot; + message.getDest());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;服务器&lt;/h4&gt;
&lt;p&gt;1.接收到message对象&lt;/p&gt;
&lt;p&gt;2.得到message对象中的getter，用他的userId获取通信线程&lt;/p&gt;
&lt;p&gt;3.将message对象转发给指定的用户&lt;/p&gt;
&lt;p&gt;和私聊类似，完成message转发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) {
    //根据getterid选取集合中的对应线程得到socket用以转发文件消息
    ServerConnectClientThread serverConnectClientThread =
            ManageClientThreads.getClientThread(message.getGetter());
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread
            .getSocket().getOutputStream());
    oos.writeObject(message);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/71.png&quot; alt=&quot;71&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/72.png&quot; alt=&quot;72&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>UDP网络编程</description><pubDate>Sun, 16 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;UDP网络通信编程&lt;/h2&gt;
&lt;p&gt;不同于TCP通信，UDP不需要建立连接，UDP数据包中含有发送的目标地址&lt;/p&gt;
&lt;p&gt;1.类 DatagramSocket 和 DatagramPacket【数据包/数据报】实现了基于UDP协议网络程序&lt;/p&gt;
&lt;p&gt;2.UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报有一定可以能够到达目的地，也不确定在什么时候可以到达&lt;/p&gt;
&lt;p&gt;3.DatagramPacket 对象封装了UDP数据报，在数据包中包含了发送端和接收端的IP地址以及端口号&lt;/p&gt;
&lt;p&gt;4.UDP协议中的每一个数据报都给出了完整的信息地址，因此无需建立发送方和接收方的链接吧&lt;/p&gt;
&lt;h2&gt;UDP特殊说明&lt;/h2&gt;
&lt;p&gt;1.UDP中没有明确的服务端和客户端，演变为数据的发送端和接收端&lt;/p&gt;
&lt;p&gt;2.接收数据和发送数据通过DatagramSocket对象完成&lt;/p&gt;
&lt;p&gt;3.发送数据时会将数据封装在DatagramPacket对象中，称之为装包&lt;/p&gt;
&lt;p&gt;4.当接收到数据包后，需要进行拆包取出数据&lt;/p&gt;
&lt;p&gt;5.DatagramSocket可以指定在哪个端口接收数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/65.png&quot; alt=&quot;65&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;UDP通信流程&lt;/h2&gt;
&lt;p&gt;1.建立发送端和接收端&lt;/p&gt;
&lt;p&gt;2.发送数据前建立数据包和数据报&lt;/p&gt;
&lt;p&gt;3.调用数据包的发送和接受方法&lt;/p&gt;
&lt;p&gt;4.关闭数据包&lt;/p&gt;
&lt;h2&gt;代码示例&lt;/h2&gt;
&lt;p&gt;发送端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.udp;

import java.io.IOException;
import java.net.*;

public class Sender {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9998);//发送端的端口是9998
        byte[] bytes = &quot;hello&quot;.getBytes();
        DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);
        socket.send(packet);
        System.out.println(&quot;数据已发送&quot;);
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.udp;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class Receiver {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9999);
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        System.out.println(&quot;等待接收数据&quot;);
        socket.receive(packet);//将收到的数据填充进入packet对象

        int length = packet.getLength();//实际接收到的数据长度
        byte[] data = packet.getData();
        String s = new String(data, 0, length);
        socket.close();
        System.out.println(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;一个代码的综合习题&lt;/h2&gt;
&lt;p&gt;这一道题是聊天交互的最简情况，支持一次通信，可以加上循环完成消息的重复发送与接收&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 6666);
        System.out.println(&quot;TCP链接建立&quot;);
        System.out.print(&quot;输入发送的消息:&quot;);
        String message = scanner.next();
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(message);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        System.out.println(&quot;消息发送完成&quot;);

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String response = bufferedReader.readLine();
        System.out.println(&quot;收到服务器消息：&quot; + response);

        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        System.out.println(&quot;客户端关闭&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(6666);
        System.out.println(&quot;服务器正在监听...&quot;);
        Socket socket = serverSocket.accept();

        OutputStream outputStream = socket.getOutputStream();
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        String receive = bufferedReader.readLine();
        System.out.println(&quot;收到客户短消息&quot; + receive);
        switch (receive) {
            case &quot;name&quot;:
                bufferedWriter.write(&quot;我是nova&quot;);
                break;
            case &quot;hobby&quot;:
                bufferedWriter.write(&quot;编写java程序&quot;);
                break;
            default:
                bufferedWriter.write(&quot;未知消息&quot;);
                break;
        }
        bufferedWriter.newLine();
        bufferedWriter.flush();
        bufferedWriter.close();
        System.out.println(&quot;回复消息已发送&quot;);

        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        serverSocket.close();
        System.out.println(&quot;服务器关闭&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BC%A0%E8%BE%93netstat%E6%8C%87%E4%BB%A4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BC%A0%E8%BE%93netstat%E6%8C%87%E4%BB%A4/</guid><description>字符流传输，netstat指令</description><pubDate>Sat, 15 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;文件传输&lt;/h2&gt;
&lt;p&gt;Java中利用套接字在服务器与客户端间进行文件传输&lt;/p&gt;
&lt;p&gt;在这里需要使用到文件的输入输出流&lt;/p&gt;
&lt;p&gt;客户端上：&lt;/p&gt;
&lt;p&gt;客户端接收文件的输入流，用工具类转化为字节流进行传输&lt;/p&gt;
&lt;p&gt;服务器上&lt;/p&gt;
&lt;p&gt;在服务器端上我们要将收到的输入流使用功能类转化为字节流&lt;/p&gt;
&lt;p&gt;再将转化后的字节数组用文件输出流送到一个特定的位置&lt;/p&gt;
&lt;p&gt;客户端代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class Client {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket(InetAddress.getLocalHost(),8899);
        String filePath = &quot;C:\\Users\\71460\\Desktop\\2.jpg&quot;;
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));
        byte[] bytes = StreamUtils.streamToByteArray(bis);

        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());
        bos.write(bytes);
        bos.flush();
        bis.close();
        socket.shutdownOutput();

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

        String reBack = bufferedReader.readLine();
        System.out.println(&quot;收到服务器回复: &quot; + reBack);
        bufferedReader.close();
        socket.close();
        bos.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务端代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(8899);
        Socket socket = serverSocket.accept();

        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = StreamUtils.streamToByteArray(bis);

        String target = &quot;.\\target.jpg&quot;;
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));
        bos.write(bytes);
        bos.close();

        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        bufferedWriter.write(&quot;收到图片&quot;);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        bufferedWriter.close();
        bis.close();
        socket.close();
        serverSocket.close();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用到的工具包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.file;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;

public class StreamUtils {
    //将输入流转化为字节流，可以将文件的内容读入到byte数组中
    public static byte[] streamToByteArray(InputStream is) throws  Exception{
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len = 0;
        while((len=is.read(buffer))!=-1){
            bos.write(buffer,0,len);
        }
        byte[] array = bos.toByteArray();
        bos.close();
        return array;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;netstat指令&lt;/h2&gt;
&lt;p&gt;netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况&lt;/p&gt;
&lt;p&gt;netstat -an | more 可以分页显示&lt;/p&gt;
&lt;p&gt;Listening代表有某个端口在监听&lt;/p&gt;
&lt;p&gt;如果有一个外部程序链接到端口就会显示一条连接信息&lt;/p&gt;
&lt;p&gt;再管理员权限下可以使用netstat -anb 来观察是哪一个程序监听端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/64.png&quot; alt=&quot;64&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中的8899端口所对应的就是我们的运行的文件传输服务器程序&lt;/p&gt;
&lt;h2&gt;TCP链接中的细节&lt;/h2&gt;
&lt;p&gt;TCP连接中，服务端监听了一个端口，再客户端和服务端建立链接的时候，客户端中也会有一个由TCP协议分配的一个端口&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86tcpudp%E5%AD%97%E8%8A%82%E6%B5%81%E4%BC%A0%E8%BE%93/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86tcpudp%E5%AD%97%E8%8A%82%E6%B5%81%E4%BC%A0%E8%BE%93/</guid><description>网络基础知识，TCP，UDP，字节流传输</description><pubDate>Fri, 14 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Java网络多线程&lt;/h1&gt;
&lt;h2&gt;IP地址&lt;/h2&gt;
&lt;p&gt;定义：用于唯一标识网络中的每一台计算机&lt;/p&gt;
&lt;p&gt;查看IP地址的指令：ipconfig&lt;/p&gt;
&lt;p&gt;IP地址组成：网络地址 + 主机地址&lt;/p&gt;
&lt;p&gt;A类地址 0 + 7位网络号 + 24位主机号&lt;/p&gt;
&lt;p&gt;B类地址 b10 + 14位网络号 + 16位主机号&lt;/p&gt;
&lt;p&gt;C类地址 b110 + 21位网络号 +8位主机号&lt;/p&gt;
&lt;p&gt;D类 b1110 + 28位多播组号&lt;/p&gt;
&lt;p&gt;E类 b11110 + 27位保留位&lt;/p&gt;
&lt;h2&gt;域名&lt;/h2&gt;
&lt;p&gt;www.baidu.com&lt;/p&gt;
&lt;p&gt;将ip地址映射为域名，方便记忆&lt;/p&gt;
&lt;h2&gt;端口号&lt;/h2&gt;
&lt;p&gt;概念：用于标识计算机上某个特定的网络程序&lt;/p&gt;
&lt;p&gt;通过IP + 端口即可访问一个特定网络上的特定程序&lt;/p&gt;
&lt;p&gt;表示形式：以整数形式表示：0—65535 （两个字节）&lt;/p&gt;
&lt;p&gt;0-1024被占用（在实际开发中不使用这一些端口）&lt;/p&gt;
&lt;h2&gt;网络通讯协议&lt;/h2&gt;
&lt;p&gt;在网络编程中数据的组织形式就是协议&lt;/p&gt;
&lt;p&gt;TCP/IP传输控制协议/因特网互联协议，又称网络通讯协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/61.png&quot; alt=&quot;61&quot; /&gt;&lt;/p&gt;
&lt;p&gt;网络层级以及对应协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/62.png&quot; alt=&quot;62&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TCP与UDP&lt;/h2&gt;
&lt;h3&gt;TCP&lt;/h3&gt;
&lt;p&gt;通过三次握手建立连接，四次握手释放连接&lt;/p&gt;
&lt;p&gt;TCP协议进行通信的两个应用进程：客户端、服务端&lt;/p&gt;
&lt;h3&gt;UDP&lt;/h3&gt;
&lt;p&gt;将数据，源，目的封装为数据包，不需要建立连接&lt;/p&gt;
&lt;p&gt;每一个数据包的大小限制为64K以内&lt;/p&gt;
&lt;h2&gt;InetAddress类&lt;/h2&gt;
&lt;p&gt;相关方法&lt;/p&gt;
&lt;p&gt;1.获取本机的InetAddress对象  getLocalHost&lt;/p&gt;
&lt;p&gt;2.根据指定的主机名/域名获取ip地址对象  getByName&lt;/p&gt;
&lt;p&gt;3.获取InetAddress对象的主机名  getHostName&lt;/p&gt;
&lt;p&gt;4.获取InetAddress对象的地址  getHostAddress&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;
import java.net.InetAddress;
import java.net.UnknownHostException;

public class Api {
    public static void main(String[] args) throws UnknownHostException {
        //1.获取本机的InetAddress对象
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost);

        //2.更具指定的主机名 获取InetAddress对象
        InetAddress host = InetAddress.getByName(&quot;thrinisty&quot;);
        System.out.println(host);

        //3.根据域名返回InetAddress对象
        InetAddress baidu = InetAddress.getByName(&quot;www.baidu.com&quot;);
        System.out.println(baidu);

        //4.通过 InetAddress对象，获取对应地址
        String baiduIp = baidu.getHostAddress();
        System.out.println(baiduIp);

        //5.通过InetAddress对象，获取域名或者主机名
        String baiduName = baidu.getHostName();
        System.out.println(baiduName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;socket套接字&lt;/h2&gt;
&lt;p&gt;1.套接字在网络开发中广泛的被采用，成为了事实上的标准&lt;/p&gt;
&lt;p&gt;2.通信的两端都需要有socket，是两台机器通信的端点&lt;/p&gt;
&lt;p&gt;3.网络通信实际上就是socket之间的通信&lt;/p&gt;
&lt;p&gt;4.socket允许程序把网络连接当成一个流，数据在两个socket之间通过IO进行传输&lt;/p&gt;
&lt;p&gt;5.一般是主动发起通信的应用程序是客户端，等待通信请求的是服务端&lt;/p&gt;
&lt;p&gt;getOutputStream()获取输出流&lt;/p&gt;
&lt;p&gt;getInputStrean()获取输入流&lt;/p&gt;
&lt;p&gt;通信流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/63.png&quot; alt=&quot;63&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TCP数据传输案例&lt;/h2&gt;
&lt;h3&gt;1.使用字节流进行传输&lt;/h3&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;p&gt;1.在本机的9999端口监听，等待连接&lt;/p&gt;
&lt;p&gt;2.当没有客户端连接时阻塞等待连接&lt;/p&gt;
&lt;p&gt;3.通过socket.getInputStream() 获取管道中的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println(&quot;Server start listening on port 9999&quot;);
        Socket socket = serverSocket.accept();//如果有客户端连接返回Socket对象，退出阻塞
        System.out.println(&quot;socket = &quot; + socket.getClass());
        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, readLen));
        }
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;p&gt;1.连接服务器&lt;/p&gt;
&lt;p&gt;2.连接上后生成socket套接字，通过socket.getOutputStream()获取到输入流&lt;/p&gt;
&lt;p&gt;3.通过输出流，写数据到数据通道&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println(&quot;socket返回 &quot; + socket.getClass());

        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;Hello!!&quot;.getBytes());
        outputStream.close();
        socket.close();
        System.out.println(&quot;客户端退出&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试在双端进行双向传递数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println(&quot;socket返回 &quot; + socket.getClass());

        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;Hello!!&quot;.getBytes());

        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int length = 0;
        while((length = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, length));
        }
        //socket.shutdownOutput();结束标记
        System.out.println(&quot;接收服务器数据完毕&quot;);

        inputStream.close();
        outputStream.close();
        socket.close();
        System.out.println(&quot;客户端退出&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.api;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println(&quot;Server start listening on port 9999&quot;);
        Socket socket = serverSocket.accept();//如果有客户端连接返回Socket对象，退出阻塞
        System.out.println(&quot;socket = &quot; + socket.getClass());
        InputStream inputStream = socket.getInputStream();
        byte[] buffer = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buffer)) != -1) {
            System.out.println(new String(buffer, 0, readLen));
        }
        OutputStream outputstream = socket.getOutputStream();
        outputstream.write(&quot;Hello client!&quot;.getBytes());
        //socket.shutdownOutput();结束标记
        System.out.println(&quot;发送完毕&quot;);

        outputstream.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一开始写的一段程序，但是运行会发现，程序没有按照预期的方式运行：服务器端会送消息到客户端（实际上并没有）&lt;/p&gt;
&lt;p&gt;这是因为缺少了结束的标记，导致了客户端认为服务端的消息还没有发送完毕，任然在等待服务端消息发送完毕&lt;/p&gt;
&lt;p&gt;需要使用结束标记，在原先代码上取消相关注释即可&lt;/p&gt;
&lt;h3&gt;2.使用字符流进行传输&lt;/h3&gt;
&lt;p&gt;需要使用转换流OutputStreamWriter，将OutputStream字节流转换为字符流&lt;/p&gt;
&lt;p&gt;使用转换流InputStreamWriter，将InputStream字节流转换为字符流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OutputStream outputStream = socket.getOutputStream();
BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
bufferedWriter.write(&quot;字符流&quot;);
bufferedWriter.newLine();//插入一个换行符，表示写入内容结束，要使对方也读一个readline
bufferedWriter.flush();//使用字符流，需要手动刷新
System.out.println(&quot;发送字符流完毕&quot;);

bufferedWriter.close();//这个时候关闭外层流即可
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;InputStream inputStream = socket.getInputStream();
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
String s = bufferedReader.readLine();
System.out.println(s);
System.out.println(&quot;接收数据完毕&quot;);

bufferedReader.close();//关闭外层流
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个完整程序&lt;/p&gt;
&lt;p&gt;服务器端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.test;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println(&quot;服务器开始监听端口8888&quot;);
        Socket socket = serverSocket.accept();
        System.out.println(&quot;链接建立&quot;);

        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

        String target = bufferedReader.readLine();
        System.out.println(&quot;收到消息 &quot; + target);

        bufferedReader.close();
        socket.close();
        System.out.println(&quot;服务器程序结束&quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.test;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);
        System.out.println(&quot;链接建立完毕&quot;);

        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));

        bufferedWriter.write(&quot;字符流数据&quot;);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        System.out.println(&quot;字符发送完毕&quot;);

        bufferedWriter.close();
        socket.close();
        System.out.println(&quot;客户端程序结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%94%B9%E9%80%A0%E9%9B%B6%E9%92%B1%E9%80%9A%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%94%B9%E9%80%A0%E9%9B%B6%E9%92%B1%E9%80%9A%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0/</guid><description>面向对象改造，零钱通综合实验，章节练习</description><pubDate>Thu, 13 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;零钱通综合案例&lt;/h2&gt;
&lt;p&gt;目的是使用Java开发零钱通项目，可以完成收益入账，消费，查看明细，退出等功能&lt;/p&gt;
&lt;h3&gt;1.显示菜单，可以显示菜单，给出对应提示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.util.Scanner;

public class SmallChangeSys {
    public static void main(String[] args) {
        boolean loop = true;
        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    System.out.println(&quot;1 零钱通明细&quot;);
                    break;
                case 2:
                    System.out.println(&quot;2收益入账&quot;);
                    break;
                case 3:
                    System.out.println(&quot;3 收益入账&quot;);
                    break;
                case 4:
                    System.out.println(&quot;4 程序退出&quot;);
                    loop = false;
                    break;
            }
        } while (loop);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2.完成零钱通明细&lt;/h3&gt;
&lt;p&gt;将收益放入数组，适用对象存储，用字符串进行拼接&lt;/p&gt;
&lt;p&gt;用字符串接收即可实现，打印字符串即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case 1:
   	System.out.println(details);
break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.完成收益入账&lt;/h3&gt;
&lt;p&gt;根据实现的功能定义新的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case 2:
	System.out.println(&quot;收益入账金额：&quot;);
	 money = scanner.nextDouble();
	//校验金额
 	balance += money;
  	date = new Date();//获取到当前的日期
 	 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd 		HH:mm:ss&quot;);
	details +=&quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + 	&quot;\t当前余额为 &quot; + balance;
break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.完成消费功能&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;case 3:
    System.out.println(&quot;输入消费金额&quot;);
   	money = scanner.nextDouble();
   	//金额校验
    System.out.print(&quot;消费说明:&quot;);
    note = scanner.next();
    balance -= money;
    date = new Date();//获取到当前的日期
   	details +=&quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + 		sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
   	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.退出逻辑&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;case 4:
	 String choice = &quot;&quot;;
	while (true) {
	System.out.println(&quot;请确认是否退出&quot;);
    choice = scanner.next();
	if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
 		break;
  	}
 	if (&quot;y&quot;.equals(choice)) {
		loop = false;
	}
	break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码整体&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class SmallChangeSys {
    public static void main(String[] args) {
        boolean loop = true;
        String details = &quot;------------零钱通明细---------------&quot;;
        double money = 0;
        double balance = 0;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String note = null;

        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    System.out.println(details);
                    break;
                case 2:
                    System.out.println(&quot;收益入账金额：&quot;);
                    money = scanner.nextDouble();
                    //校验金额
                    balance += money;
                    date = new Date();//获取到当前的日期
                    if (money &amp;lt;= 0) {
                        System.out.println(&quot;金额错误&quot;);
                        break;
                    }
                    details += &quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
                    break;
                case 3:
                    System.out.println(&quot;输入消费金额&quot;);
                    money = scanner.nextDouble();
                    if(money &amp;gt;= balance) {
                        System.out.println(&quot;余额不足&quot;);
                        break;
                    }
                    System.out.print(&quot;消费说明:&quot;);
                    note = scanner.next();
                    balance -= money;
                    date = new Date();//获取到当前的日期
                    details += &quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
                    break;
                case 4:
                    String choice = &quot;&quot;;
                    while (true) {
                        System.out.println(&quot;请确认是否退出&quot;);
                        choice = scanner.next();
                        if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
                            break;
                        }
                    }
                    if (&quot;y&quot;.equals(choice)) {
                        loop = false;
                    }
                    break;
                default:
            }
        } while (loop);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;面向对象&lt;/h2&gt;
&lt;p&gt;以上是面向过程的代码编程，以下是对于代码的改进，体会面向对象的方便之处&lt;/p&gt;
&lt;p&gt;将各个操作更改为以类的方法实现，再将方法综合在菜单方法里调用，即可完成封装&lt;/p&gt;
&lt;p&gt;main方法构造以及调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

public class SmallChangeSysApp {
    public static void main(String[] args) {
        SmallChangeSysOOP app = new SmallChangeSysOOP();
        app.mainMenu();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;零钱通类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.smallchange;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

//面向对象编程
//将各个功能对应一个方法
public class SmallChangeSysOOP {
    boolean loop = true;
    String details = &quot;------------零钱通明细---------------&quot;;
    double money = 0;
    double balance = 0;
    Date date = null;
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String note = null;
    Scanner scanner = new Scanner(System.in);

    public void mainMenu() {
        do {
            System.out.println(&quot;==========零钱通==========&quot;);
            System.out.println(&quot;\t\t1 零钱通明细&quot;);
            System.out.println(&quot;\t\t2 收益入账&quot;);
            System.out.println(&quot;\t\t3 消费&quot;);
            System.out.println(&quot;\t\t4 退出&quot;);

            System.out.println(&quot;请选择1-4&quot;);
            Scanner scanner = new Scanner(System.in);
            switch (scanner.nextInt()) {
                case 1:
                    this.detail();
                    break;
                case 2:
                    this.income();
                    break;
                case 3:
                    this.pay();
                    break;
                case 4:
                    this.exit();
                    break;
                default:
            }
        } while (loop);
    }

    public void detail() {
        System.out.println(details);
    }

    public void income(){
        System.out.println(&quot;收益入账金额：&quot;);
        money = scanner.nextDouble();
        //校验金额
        balance += money;
        date = new Date();//获取到当前的日期
        if (money &amp;lt;= 0) {
            System.out.println(&quot;金额错误&quot;);
            return;
        }
        details += &quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
    }

    public void pay(){
        System.out.println(&quot;输入消费金额&quot;);
        money = scanner.nextDouble();
        if(money &amp;gt;= balance) {
            System.out.println(&quot;余额不足&quot;);
            return;
        }
        System.out.print(&quot;消费说明:&quot;);
        note = scanner.next();
        balance -= money;
        date = new Date();//获取到当前的日期
        details += &quot;\n&quot; + note + &quot; 消费\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t当前余额为 &quot; + balance;
    }

    public void exit() {
        String choice = &quot;&quot;;
        while (true) {
            System.out.println(&quot;请确认是否退出&quot;);
            choice = scanner.next();
            if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) {
                break;
            }
        }
        if (&quot;y&quot;.equals(choice)) {
            loop = false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;章节作业&lt;/h2&gt;
&lt;p&gt;1.定义Person类，对Person数组按照年龄排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework01 {
    public static void main(String[] args) {
        Person[] personArray = new Person[3];
        personArray[0] = new Person(&quot;Jerry&quot;, 19, &quot;1&quot;);
        personArray[1] = new Person(&quot;John&quot;, 55, &quot;2&quot;);
        personArray[2] = new Person(&quot;Mary&quot;, 33, &quot;3&quot;);
        Tool tool = new Tool();
        tool.sort(personArray);
        tool.print(personArray);
    }
}

class Person {
    String name;
    int age;
    String job;

    Person(String name, int age, String job) {
        this.name = name;
        this.age = age;
        this.job = job;
    }
    @Override
    public String toString() {
        return this.name + &quot; &quot; + this.age + &quot; &quot; + this.job;
    }
}

class Tool {
    public void sort(Person[] personArray) {
        for (int i = 0; i &amp;lt; personArray.length - 1; i++) {
            for (int j = 0; j &amp;lt; personArray.length - i - 1; j++) {
                if(personArray[j].age &amp;lt; personArray[j + 1].age) {
                    Person temp = personArray[j];
                    personArray[j] = personArray[j + 1];
                    personArray[j + 1] = temp;
                }
            }
        }
    }

    public void print(Person[] personArray) {
        for (int i = 0; i &amp;lt; personArray.length; i++) {
            System.out.println(personArray[i].toString());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编写老师类，使三个教师类继承老师类，在教师类中重写方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework03 {
    public static void main(String[] args) {
        Professor professor = new Professor(&quot;LaoLi&quot;, 19, &quot;Math&quot;, 1900);
        professor.introduce();
    }
}

class Teacher {
    String name;
    int age;
    String post;
    double salary;

    public Teacher(String name, int age, String post, double salary) {
        this.name = name;
        this.age = age;
        this.post = post;
        this.salary = salary;
    }

    public void introduce() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Post: &quot; + post + &quot;, Salary: &quot; + salary);
    }
}

class Professor extends Teacher {
    Professor(String name, int age, String post, double salary) {
        super(name, age, post, salary);
    }
    public void introduce() {
        System.out.println(&quot;ProfessorName: &quot; + name + &quot;, Age: &quot; + age + &quot;, Post: &quot; + post + &quot;, Salary: &quot; + salary * 1.3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.Point&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework09 {
    public static void main(String[] args) {
        LabeledPoint point = new LabeledPoint(&quot;Thursday&quot;, 12 , 34);
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class LabeledPoint extends Point {
    String label;

    public LabeledPoint(String lable, int x, int y) {
        super(x, y);
        this.label = label;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.判断医生类是否各个属性相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework;

public class Homework10 {
    public static void main(String[] args) {
        Doctor human1 = new Doctor(&quot;Li&quot;, 19, &quot;A&quot;, &apos;F&apos;,1900);
        Doctor human2 = new Doctor(&quot;Li&quot;, 19, &quot;A&quot;, &apos;F&apos;,1900);
        System.out.println(human1.equals(human2));
    }
}

class Doctor {
    String name;
    int age;
    String job;
    char gender;
    double salary;

    public Doctor(String name, int age, String job, char gender, double salary) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.gender = gender;
        this.salary = salary;
    }

    public void setter(String name, int age, String job, char gender, double salary) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.gender = gender;
        this.salary = salary;
    }

    public void getter() {
        System.out.println(this.name + &quot; &quot; + this.age + &quot; &quot; + this.job + &quot; &quot; + this.gender + &quot; &quot; + this.salary);
    }

    public boolean equals(Object obj) {
        if(obj instanceof Doctor) {
            Doctor doctor = (Doctor) obj;
            return this.name.equals(doctor.name) &amp;amp;&amp;amp; this.age
                    == doctor.age &amp;amp;&amp;amp; this.job.equals(doctor.job) &amp;amp;&amp;amp; this.gender
                    == doctor.gender &amp;amp;&amp;amp; this.salary == doctor.salary;

        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.学生老师综合案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.homework13;

public class Homework13 {
    public static void main(String[] args) {
        Teacher teacher1 = new Teacher(&quot;王芳&quot;, &apos;女&apos;, 39, 10);
        Student student1 = new Student(&quot;李明&quot;, &apos;男&apos;, 19, 222333);
        Person[] personArray = new Person[4];
        personArray[0] = teacher1;
        personArray[1] = student1;
        personArray[2] = new Teacher(&quot;王&quot;, &apos;男&apos;, 59, 10);
        personArray[3] = new Student(&quot;李&quot;, &apos;女&apos;, 19, 333222);
        Tool tool = new Tool();
        tool.sort(personArray);
        for(Person person : personArray) {
            System.out.println(person.toString());
            tool.play(person);
        }

    }
}

class Tool {
    public void sort(Person[] personArray) {
        Person temp = null;
        for (int i = 0; i &amp;lt; personArray.length - 1; i++) {
            for (int j = 0; j &amp;lt; personArray.length - 1 - i; j++) {
                if(personArray[j].getAge() &amp;lt; personArray[j + 1].getAge()) {
                    temp = personArray[j];
                    personArray[j] = personArray[j + 1];
                    personArray[j + 1] = temp;
                }
            }
        }
    }

    public void play(Person person) {
        if(person instanceof Teacher) {
            Teacher teacher = (Teacher) person;
            teacher.play();
        } else if(person instanceof Student) {
            Student student = (Student) person;
            student.play();
        } else {
            System.out.println(&quot;Fail to play!!&quot;);
        }
    }
}

class Person {
    private String name;
    private char sex;
    private int age;

    public Person(String name, char sex, int age) {
        this.name = name;
        this.sex = sex;
        this.age = age;
    }

    public String toString() {
        return    &quot;姓名：&quot; + this.name + &quot;\n&quot;
                + &quot;年龄：&quot; + this.age + &quot;\n&quot;
                + &quot;性别：&quot; + this.sex + &quot;\n&quot;;
    }

    public void play() {
        System.out.println(&quot;play&quot;);
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public char getSex() {
        return this.sex;
    }

}

class Teacher extends Person {
    private int workAge;

    Teacher(String name, char sex, int age, int workAge) {
        super(name, sex, age);
        this.workAge = workAge;
    }

    public String toString() {
        return &quot;老师的信息：\n&quot; + super.toString() + &quot;工龄： &quot; + this.workAge;
    }

    public void play() {
        System.out.println(&quot;teacher play&quot;);
    }

    public int getWorkAge() {
        return workAge;
    }
}

class Student extends Person {
    private int id;
    Student(String name, char sex, int age, int id) {
        super(name, sex, age);
        this.id = id;
    }
    public String toString() {
        return &quot;学生的信息：\n&quot; + super.toString() + &quot;学号： &quot; + this.id;
    }

    public void play() {
        System.out.println(&quot;student play&quot;);
    }
    public int getId() {
        return id;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为课程大作业的安排，我打算明天完成房屋出租系统设计之后，先进行Java网络编程部分的学习，以此复习计算机网络相关知识，再顺便水个作业，美哉美哉&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0object%E7%B1%BB%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0object%E7%B1%BB%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</guid><description>Object类方法，断点调试</description><pubDate>Wed, 12 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Object类&lt;/h2&gt;
&lt;p&gt;这一章会介绍object类的方法&lt;/p&gt;
&lt;p&gt;通过自动配置或者手动配置后可以运用IDEA查看Object的源代码以及其对应的方法，点击右键跳转，或者ctrl + 左键 跳转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/55.png&quot; alt=&quot;55&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Object的子类String方法进行重写更改为，此时判断的是内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/56.png&quot; alt=&quot;56&quot; /&gt;&lt;/p&gt;
&lt;p&gt;整形的包装类equals判断方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/57.png&quot; alt=&quot;57&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/58.png&quot; alt=&quot;58&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看源码查看方法重写是程序员重要的技能&lt;/p&gt;
&lt;h3&gt;equals方法&lt;/h3&gt;
&lt;p&gt;在不重写equals方法的时候，Person类使用的是父类object的方法，这个时候判断的是两个引用是否指向同一个对象，如果需要用equals判断内容是否一致的时候需要重写方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Equals01 {
    public static void main(String[] args) {
        Person person1 = new Person(&quot;l&quot;, 1, &apos;女&apos;);
        Person person2 = new Person(&quot;k&quot;, 1, &apos;女&apos;);
        if(person2.equals(person1)) {
            System.out.println(&quot;Person 1 and Person 2 are equal&quot;);
        }
    }
}

class Person {
    private String name;
    private int age;
    private char gender;

    public Person(String name, int age, char gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    public boolean equals(Object obj) {
        if(this == obj) {
            return true;
        }
        if(obj instanceof Person) {
            Person person = (Person)obj;
            return person.name == person.name &amp;amp;&amp;amp; this.age == person.age &amp;amp;&amp;amp; this.gender == person.gender;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;hashCode方法&lt;/h3&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.两个引用如果指向同一个对象，则哈希值一定是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa1 = new AA();
        AA aa2 = new AA();
        AA aa3 = aa1;
        System.out.println(aa1.hashCode());
        System.out.println(aa2.hashCode());
        System.out.println(aa3.hashCode());
    }
}

class AA {}
/*运行结果
	1163157884
	1956725890
	1163157884
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.可以提高有哈希结构的容器效率&lt;/p&gt;
&lt;p&gt;3.哈希值是根据地址计算而来，但是不能够等价于地址（Java中代码是跑在虚拟机上的，不用关注于底层）&lt;/p&gt;
&lt;h3&gt;toString方法&lt;/h3&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全类名 + @ + 类的哈希地址十六进制&lt;/p&gt;
&lt;p&gt;全类名为 包名 + 类名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.npu.object.AA@4554617c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般而言我们会将Object类的toString方法进行重写，用于打印各个详细的属性信息&lt;/p&gt;
&lt;p&gt;当输出一个对象的时候，我们默认会调用这个对象的toString 方法进行输出&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        System.out.println(aa);
    }
}

class AA {
    int i;
    double m;

    public String toString() {
        return &quot;AA{i=&quot; + i + &quot;, m=&quot; + m + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;finalize方法&lt;/h3&gt;
&lt;p&gt;当垃圾回收器检测到没有指向该对象的引用时，系统自动调用该对象的finalize方法，进行资源释放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; AA aa = new AA();
 System.out.println(aa);
 aa = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行完毕的时候 AA的实例变为一个 垃圾 ，垃圾回收器就会被回收分配的堆空间&lt;/p&gt;
&lt;p&gt;程序员可以在销毁方法finalize 写一些自己的业务逻辑（通过重写finalize方法完成）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.object;

public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.out.println(&quot;代码结束&quot;);
    }
}

class AA {
    int i;
    double m;

    public String toString() {
        return &quot;AA{i=&quot; + i + &quot;, m=&quot; + m + &quot;}&quot;;
    }
    @Override
    protected void finalize() throws Throwable {
        System.out.println(&quot;Finalize called&quot;);
        super.finalize();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当回收的时候会输出对应的提示信息&lt;/p&gt;
&lt;p&gt;但是如上代码不会输出信息，因为回收调用回收方法的时候不是在置空引用后立即执行&lt;/p&gt;
&lt;p&gt;我们可以注定调用回收 System.gc( )&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hashcode {
    public static void main(String[] args) {
        AA aa = new AA();
        aa = null;
        System.gc();//主动调用回收器
        System.out.println(&quot;代码结束&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代码结束
Finalize called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码结束输出在前&lt;/p&gt;
&lt;p&gt;因为gc方法不会阻塞代码&lt;/p&gt;
&lt;h2&gt;断点调试&lt;/h2&gt;
&lt;p&gt;1.在实际开发中要查找错误的时候，断点调试是很重要的一步，可以一步一步的看代码执行的过程，从而纠错&lt;/p&gt;
&lt;p&gt;2.在断点调试的时候是运行的，是以对象的运行类型来执行的&lt;/p&gt;
&lt;p&gt;3.断点调试也可以帮我们查看java底层源代码的执行过程，提高Java水平&lt;/p&gt;
&lt;h3&gt;断点调试中常用的快捷键&lt;/h3&gt;
&lt;p&gt;F7 跳入&lt;/p&gt;
&lt;p&gt;F8 跳过&lt;/p&gt;
&lt;p&gt;shift + F8 跳出方法&lt;/p&gt;
&lt;p&gt;F9 跳到下一个断点 支持动态添加断点，可以添加到自写代码或者jdk源码中&lt;/p&gt;
&lt;p&gt;force step into 强制进入jdk源码 alt + shift + F7&lt;/p&gt;
&lt;p&gt;面向对象编程中级内容到此结束，明天将进行零钱通项目的综合运用&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%9A%E6%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>多态，动态绑定机制，多态的应用</description><pubDate>Tue, 11 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;多态&lt;/h2&gt;
&lt;p&gt;定义：方法或者对象具有多种形态&lt;/p&gt;
&lt;p&gt;1.重写或者重载体现出了方法的多态&lt;/p&gt;
&lt;p&gt;2.对象体现多态（是多态的核心）&lt;/p&gt;
&lt;p&gt;当一个类对于某一个类做一些操作的时候，我们可以对于每一个后向类编写方法，但是如果这些类都继承于同一个类，我们可以通过对于着一些类的父类编写方法来统一操作这一类的各个子类。通过这样做我们可以极大的提高代码的复用性&lt;/p&gt;
&lt;p&gt;例如我们有猫类，狗类继承于动物类，我们要通过一个人类来模拟喂食的时候需要在人类的方法中定义两个feed重载方法，这样子有大量的冗余&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Poly01 {
    public static void main(String[] args) {
        Master Tom = new Master(&quot;汤姆&quot;);
        Dog dog =  new Dog(&quot;大黄&quot;);
        Bone bone = new Bone(&quot;棒骨&quot;);
        Tom.feed(dog, bone);

        Cat cat = new Cat(&quot;小花&quot;);
        Fish fish = new Fish(&quot;鱼&quot;);
        Tom.feed(cat, fish);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.poly;

public class Master {
    private String name;
    
    public void setName(String name) {
        this.name = name;
    }

    public void feed(Dog dog, Bone bone) {
        System.out.println(&quot;喂&quot; + dog.getName() + &quot;吃&quot; + bone.getName());
    }

    public void feed(Cat cat, Fish fish) {
        System.out.println(&quot;喂&quot; + cat.getName() + &quot;吃&quot; + fish.getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上述的feed方法做更改，删除原先的feed方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void feed(Animal animal, Food food) {
        System.out.println(&quot;喂&quot; + animal.getName() + &quot;吃&quot; + food.getName());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样子做，在后续加动物的子类，或者加事物的子类，都可以使用这个方法，大大提高了代码的可维护性&lt;/p&gt;
&lt;h2&gt;多态重点&lt;/h2&gt;
&lt;p&gt;1.一个对象的编译类型和运行类型可以不一致&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Animal animal = new Dog();
//animal的编译类型是Animal 运行类型是Dog类
//可以用父类的引用指向子类的一个对象
animal = new Cat();//运行类型更改为Cat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.编译类型在定义对象时就被确定，不要能够改变&lt;/p&gt;
&lt;p&gt;3.运行类型可以变化&lt;/p&gt;
&lt;p&gt;4.编译类型看定义时 = 左边的内容， 运行时类型看 = 右边的内容&lt;/p&gt;
&lt;h2&gt;多态的细节&lt;/h2&gt;
&lt;p&gt;多态的前提是两个类存在继承关系&lt;/p&gt;
&lt;h3&gt;向上转型&lt;/h3&gt;
&lt;p&gt;父类的引用指向子类的对象&lt;/p&gt;
&lt;p&gt;语法：父类类型 父类引用名称 = new 子类类型（）；&lt;/p&gt;
&lt;p&gt;特点：编译类型是父类，运行类型是子类&lt;/p&gt;
&lt;p&gt;可以调用父类的所有成员，不可以调用子类的特有成员，但是如果有和父类的同名方法，最终调用的是子类方法&lt;/p&gt;
&lt;p&gt;这是因为在javac编译的时候只会认为对象是父类，但是交给运行器java的时候要从子类开始查找方法，按照继承那一章的步骤同理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/53.png&quot; alt=&quot;53&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;向下转型&lt;/h3&gt;
&lt;p&gt;语法：子类类型 子类引用名称 = （子类类型） 父类引用&lt;/p&gt;
&lt;p&gt;只可以强制转化父类的引用，不能够强制转化父类的对象&lt;/p&gt;
&lt;p&gt;要求父类的引用必须要指向当前目标类型的对象  例如：不能将指向狗的动物类转化为猫类&lt;/p&gt;
&lt;p&gt;这样将父类引用转化为子类，即可使用子类类型的成员&lt;/p&gt;
&lt;h3&gt;属性细节&lt;/h3&gt;
&lt;p&gt;属性没有重写之说，属性的值看编译类型&lt;/p&gt;
&lt;h3&gt;instanceOf&lt;/h3&gt;
&lt;h3&gt;比较操作运算符&lt;/h3&gt;
&lt;p&gt;运行类型 是否是 某类型或者该类型的子类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Master Tom = new Master(&quot;汤姆&quot;);
        Dog dog = new Dog(&quot;大黄&quot;);
        Bone bone = new Bone(&quot;棒骨&quot;);
        Tom.feed(dog, bone);

        Cat cat = new Cat(&quot;小花&quot;);
        Fish fish = new Fish(&quot;鱼&quot;);
        Tom.feed(cat, fish);

        Animal animal = new Animal(&quot;123&quot;);
        System.out.println(animal instanceof Animal);
        System.out.println(cat instanceof Animal);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;喂大黄吃棒骨
喂小花吃鱼
true
true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java的动态绑定机制&lt;/h2&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.dynamic;

public class Main {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//40用运行时的类型b
        System.out.println(a.sum1());//30用运行时的类型b
    }
}

class A {
    public int i = 10;
    public int sum() {
        return getl() + 10;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}

class B extends A {
    public int i = 20;
    public int sum() {
        return i + 20;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在将b子类的sum()方法注释，调用的就是父类的sum方法，但是这里问题出现了，到底是用的父类的getl方法还是子类的getl方法，引出了如下的规则&lt;/p&gt;
&lt;p&gt;动态绑定机制：&lt;/p&gt;
&lt;p&gt;1.当调用对象方法的时候，方法会和该对象的内存地址/运行类型做绑定&lt;/p&gt;
&lt;p&gt;System.out.println(a.sum());&lt;/p&gt;
&lt;p&gt;此时调用父类sum方法，sum中调用子类的getl方法，最终结果是30&lt;/p&gt;
&lt;p&gt;2.当调用对象属性的时候，没有动态绑定机制，哪里声明，就在那里使用&lt;/p&gt;
&lt;p&gt;将子类方法sum1注释，调用了父类的方法，而属性是父类的i，最终的结果是20&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.dynamic;

public class Main {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//30
        System.out.println(a.sum1());//20
    }
}

class A {
    public int i = 10;
    public int sum() {
        return getl() + 10;
    }
    public int getl() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}

class B extends A {
    public int i = 20;
    public int getl() {
        return i;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;多态的应用&lt;/h2&gt;
&lt;h3&gt;多态数组&lt;/h3&gt;
&lt;p&gt;数组的定义是父类类型，保存的元素类型是子类类型&lt;/p&gt;
&lt;p&gt;以下是一个存储老师和学生的Person类数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyarr;

public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        Student student = (Student) personArr[1];
        Teacher teacher = (Teacher) personArr[0];
        student.say();
        teacher.say();
    }
}

class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void say() {
        System.out.println(name + &quot; &quot; + age);
    }
}

class Student extends Person {
    public Student(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am student&quot; + name);
    }
}

class Teacher extends Person {
    public Teacher(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am teacher&quot; + name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数中也可以不做类型转化，因为调用的方法会根据运行类型做转化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        for(int i = 0; i&amp;lt;personArr.length; i++) {
            personArr[i].say();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在调用方法的时候需要向下转换调用方法，转换为子类型的引用再调用子类方法&lt;/p&gt;
&lt;p&gt;在这里还运用了类型的判断（运行类型判断）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyarr;

public class Main {
    public static void main(String[] args) {
        Person[] personArr = new Person[2];
        personArr[0] = new Teacher(&quot;John&quot;, 23);
        personArr[1] = new Student(&quot;Jane&quot;, 25);
        for(int i = 0; i&amp;lt;personArr.length; i++) {
            personArr[i].say();
            if(personArr[i] instanceof Teacher) {
                Teacher teacher = (Teacher) personArr[i];
                teacher.teach();
            } else {
                Student student = (Student) personArr[i];
                student.study();
            }
        }
    }
}

class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void say() {
        System.out.println(name + &quot; &quot; + age);
    }
}

class Student extends Person {
    public Student(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am student &quot; + name);
    }

    public void study() {
        System.out.println(&quot;studying&quot;);
    }
}

class Teacher extends Person {
    public Teacher(String name, int age) {
        super(name, age);
    }

    public void say() {
        System.out.println(&quot;I am teacher &quot; + name);
    }

    public void teach() {
        System.out.println(&quot;teaching&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多态参数&lt;/h3&gt;
&lt;p&gt;1.前文喂动物的时候曾使用过&lt;/p&gt;
&lt;p&gt;2.模拟工厂分发工资&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.polyparameter;

public class Main {
    public static void main(String[] args) {
        Worker worker = new Worker(&quot;大壮&quot;, 2000);
        Manager manager = new Manager(&quot;小明&quot;, 2300, 3000);
        Tool tool = new Tool();
        System.out.println(tool.showEmpAnnual(worker));
        System.out.println(tool.showEmpAnnual(manager));
        tool.testWork(worker);
        tool.testWork(manager);
    }
}

class Tool {
    public double showEmpAnnual(Employee emp) {
        if(emp instanceof Worker) {
            Worker worker = (Worker) emp;
            return worker.calculateSalary();
        } else {
            Manager manager = (Manager) emp;
            return manager.calculateSalary();
        }
    }
    public void testWork(Employee emp) {
        if(emp instanceof Worker) {
            Worker worker = (Worker) emp;
            worker.work();
        } else {
            Manager manager = (Manager) emp;
            manager.manage();
        }
    }
}

class Employee {
    String name;
    double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public double calculateSalary() {
        return salary * 12;
    }
}

class Worker extends Employee {
    public Worker(String name, double salary) {
        super(name, salary);
    }
    public void work() {
        System.out.println(&quot;work&quot;);
    }

    public double calculateSalary() {
        return super.calculateSalary();
    }
}

class Manager extends Employee {
    double bonus;
    public Manager(String name, double salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }
    public double calculateSalary() {
        return super.calculateSalary() + bonus;
    }
    public void manage() {
        System.out.println(&quot;manage&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是有关于多态的内容，相关的联系还得再多做习题巩固&lt;/p&gt;
&lt;p&gt;明天会来到Object类的详解，以及断点调试相关内容&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99/</guid><description>继承，重写</description><pubDate>Mon, 10 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;面向对象的三大特征&lt;/h2&gt;
&lt;h3&gt;继承&lt;/h3&gt;
&lt;p&gt;为了解决代码复用性的情况，引出了继承的概念&lt;/p&gt;
&lt;p&gt;例如以下的代码有小学生类以及大学生类，除了各自特有的方法，他们的属性，方法大致相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Pupil {
    public String name;
    public int age;
    private double score;

    Pupil(String name, int age, double score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Graduate {
    public String name;
    public int age;
    private double score;

    Graduate(String name, int age, double score) {
        this.name = name;
        this.age = age;
        this.score = score;
    }

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Extends01 {
    public static void main(String[] args) {
        Graduate human1 = new Graduate(&quot;thrinisy&quot;, 18, 100);
        human1.infoPrint();
        Pupil pupil1 = new Pupil(&quot;pupil&quot;, 11, 100);
        pupil1.infoPrint();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当多个类存在相同的属性和方法的时候，我们可以从类中抽象出这些相同的属性和方法制作父类，所有的子类中不需要重新定义这一些属性方法，而是通过extends 关键字声明即可&lt;/p&gt;
&lt;p&gt;父类又称为超类，基类&lt;/p&gt;
&lt;p&gt;子类又称派生类&lt;/p&gt;
&lt;p&gt;extends 使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Children extends Father {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上述的例子稍作更改&lt;/p&gt;
&lt;p&gt;将小学生和大学生抽象出一个父类 人类People&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class People {
    public String name;
    public int age;
    private double score;

    public void infoPrint() {
        System.out.println(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Score: &quot; + score);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Graduate extends People {
    public void speak () {
        System.out.println(&quot;大学生阴暗的爬行~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小学生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Pupil extends People {
    public void speak () {
        System.out.println(&quot;小学生玩游戏&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;继承的细节&lt;/h3&gt;
&lt;p&gt;1.子类继承了所有的属性和方法，但是私有的属性和方法不能够直接访问，必须要通过共有的方法才可以对private 修饰的属性进行修改&lt;/p&gt;
&lt;p&gt;例如我们要修改上述的成绩属性，我们需要在People定义一个公共的方法来进行更改&lt;/p&gt;
&lt;p&gt;要调用私有的方法只可以通过一个包含该私有方法的公共方法进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setScore(double score) {
        this.score = score;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样才可以在子类中调用该方法进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend;

public class Extends01 {
    public static void main(String[] args) {
        Graduate graduate = new Graduate();
        graduate.name = &quot;thrinisty&quot;;
        graduate.age = 18;
        graduate.setScore(11.3);
        graduate.infoPrint();

        Pupil pupil = new Pupil();
        pupil.name = &quot;james&quot;;
        pupil.age = 11;
        pupil.setScore(110.3);
        pupil.infoPrint();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.子类必须调用父类的构造器，完成父类的初始化&lt;/p&gt;
&lt;p&gt;在创建子类的时候，先调用父类的构造器，再调用子类的构造器（默认使用了super使用父类的构造器）&lt;/p&gt;
&lt;p&gt;3.当创建子类对象的时候，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类没有无参构造器，则必须要在子类的构造器中用super指定用哪个父类的构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Graduate(String name, int age) {
        super(name, age);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; People(String name, int age) {
        this.name = name;
        this.age = age;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.super在使用的时候需要放在构造器的第一行&lt;/p&gt;
&lt;p&gt;5.super和 this 不同存在于同一个构造器中，因为两个都必须要写在第一行&lt;/p&gt;
&lt;p&gt;6.java中的所有类都是Object类的子类&lt;img src=&quot;../images/52.png&quot; alt=&quot;52&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.父类构造器的调用不限于直接父类，将向上追溯到Object类&lt;/p&gt;
&lt;p&gt;所以当C继承于B继承于A的时候，调用C类构造器先执行的是A的构造器---&amp;gt;B—&amp;gt;C&lt;/p&gt;
&lt;p&gt;8.Java的单继承，一个子类只能继承一个父类&lt;/p&gt;
&lt;p&gt;9.不能滥用继承关系，子类和父类必须要满足 子类是父类 的关系&lt;/p&gt;
&lt;h3&gt;继承的本质（内存布局）&lt;/h3&gt;
&lt;p&gt;在访问属性的时候按照查找关系来返回信息，先检查子类有无这个属性，有则返回，无则向上访问直到找到属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend.test;

public class Inside {
    public static void main(String[] args) {
        Son son = new Son();
        System.out.println(&quot;name &quot; + son.name);
    }
}

class Grandpa {
    String name = &quot;Grandpa&quot;;
    String hobby = &quot;GHobby&quot;;
}

class Father extends Grandpa {
    String name = &quot;Father&quot;;
    int age = 40;
}

class Son extends Father {
    String name = &quot;Son&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/53.png&quot; alt=&quot;53&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;super关键字&lt;/h3&gt;
&lt;p&gt;super是父类的引用，可以访问父类的方法 属性 构造器&lt;/p&gt;
&lt;p&gt;但是不可以访问父类的私有方法以及私有属性&lt;/p&gt;
&lt;p&gt;1.当子类父类有重名属性方法时，访问父类的重名属性方法需要使用super，没有重名的话使用super this 直接访问的效果是一样的，但是为了代码的可读性，要访问属性或者方法之前，统一加上 this 或者 super 显示的指出要访问的是本类还是父类的属性方法&lt;/p&gt;
&lt;p&gt;2.有同名的属性方法就近找，先找子类再找父类&lt;/p&gt;
&lt;h3&gt;方法的重写&lt;/h3&gt;
&lt;p&gt;当子类的一个方法和父类的某一个方法重名，返回类型一致，参数一致，我们就说子类的方法覆盖了父类的方法&lt;/p&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.extend.overwrite;

public class Override {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Dog dog = new Dog();
        cat.speak();
        dog.speak();
    }
}
class Animal {
    public int age;
    public void speak() {
        System.out.println(&quot;speak&quot;);
    }
}
class Cat extends Animal {
    public void speak() {
        System.out.println(&quot;CAT speak&quot;);
    }
}
class Dog extends Animal {
    public void speak() {
        System.out.println(&quot;Dog speak&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法重写细节&lt;/h3&gt;
&lt;p&gt;1.子类的方法参数，方法名称要和父类的一致&lt;/p&gt;
&lt;p&gt;2.子类的返回类型要和父类的方法类型一样或者是父类返回类型的子类&lt;/p&gt;
&lt;p&gt;3.子类方法不可以缩小父类方法的访问权限&lt;/p&gt;
&lt;p&gt;重写和重载之间的比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/54.png&quot; alt=&quot;54&quot; /&gt;&lt;/p&gt;
&lt;p&gt;明天会来到面向对象中的多态&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0idea%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83java%E5%8C%85%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%B0%81%E8%A3%85/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0idea%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83java%E5%8C%85%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%B0%81%E8%A3%85/</guid><description>IDEA集成开发环境，Java包，访问修饰符，封装</description><pubDate>Sun, 09 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;IDEA的使用&lt;/h2&gt;
&lt;p&gt;IDEA支持30天试用，如果是学生或者教师可以在官网使用学校邮箱或者学信网获取授权使用&lt;/p&gt;
&lt;p&gt;IDEA之中各种快捷键，定义模板，变量名，自动补全，自动添加导入可以极大地增加开发的效率&lt;/p&gt;
&lt;h2&gt;Java中的包&lt;/h2&gt;
&lt;p&gt;包的本质是创建不同的文件夹来保存类文件&lt;/p&gt;
&lt;p&gt;包有三个重大的作用&lt;/p&gt;
&lt;p&gt;1.可以区分相同名字的类&lt;/p&gt;
&lt;p&gt;2.当类很多的时候可以高效的管理类&lt;/p&gt;
&lt;p&gt;3.控制访问范围&lt;/p&gt;
&lt;h3&gt;包的基本语法&lt;/h3&gt;
&lt;p&gt;package com.thrinisty&lt;/p&gt;
&lt;p&gt;package 关键字 表示打包&lt;/p&gt;
&lt;p&gt;com.thrinisty 表示包名&lt;/p&gt;
&lt;p&gt;以下是一个包的入门案例&lt;/p&gt;
&lt;p&gt;建立了两个包 小强的包 小明的包 在各自的包中定义了Dog方法&lt;/p&gt;
&lt;p&gt;在use包中定义了主方法，主方法中可以导入小明的Dog类，但是再导入小强的Dog类因为方法同名，可以通过com.xiaoqiang.Dog()使用小强的Dog类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/51.png&quot; alt=&quot;51&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package use;

import com.xiaoming.Dog;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        System.out.println(dog);

        com.xiaoqiang.Dog dog1 = new com.xiaoqiang.Dog();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包的命名&lt;/p&gt;
&lt;p&gt;命名规则，只能包含数子，字母，小圆点，但不能够是用数字开头，不能是关键字或保留字&lt;/p&gt;
&lt;p&gt;命名规范&lt;/p&gt;
&lt;p&gt;一般是小写字母 + 小圆点&lt;/p&gt;
&lt;p&gt;com.公司名.项目名.业务模块名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.sina.crm.user;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Java中常用的包&lt;/h3&gt;
&lt;p&gt;1.lang 基本包，默认引入，不需要再次引入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.lang.*;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.util 工具包系统提供的工具类，例如Scanner&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.net 网络包，用于网络开发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.net.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.awt 界面开发工具 GUI&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.awt.*
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;导入包&lt;/h3&gt;
&lt;p&gt;建议需要用哪个类就导入哪个类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;//导入Scanner类
import java.util.Scanner;//导入util下的所有类
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.pkg;

import java.util.Arrays;
public class Import {
    public static void main(String[] args) {
        int[] arr = {13, 35, 16, 67, 33};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用给定的 Arrays 方法排序输出&lt;/p&gt;
&lt;p&gt;1.package 作用是声明当前类的包，需要放在类的最上面，一个类中最多只能有一个package&lt;/p&gt;
&lt;p&gt;2.import 位置放在package下面，类定义的前面，可以导入多个包方法，且没有顺序要求&lt;/p&gt;
&lt;h2&gt;访问修饰符&lt;/h2&gt;
&lt;p&gt;1.public 公开 对外公开&lt;/p&gt;
&lt;p&gt;2.protected 受保护的 对子类和同一个包公开&lt;/p&gt;
&lt;p&gt;3.默认 向同一个包的类公开&lt;/p&gt;
&lt;p&gt;4.private 私有的 只有类的本身可以访问，不对外公开&lt;/p&gt;
&lt;p&gt;使用的注意事项&lt;/p&gt;
&lt;p&gt;1.修饰符可以用来修饰类中的属性，成员方法，以及类的本身&lt;/p&gt;
&lt;p&gt;2.只有默认和public才可以修饰类&lt;/p&gt;
&lt;p&gt;代码示例：（以属性举例）&lt;/p&gt;
&lt;p&gt;A类定义(同一个类中可以访问所有的变量)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

public class A {
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    //同一个类下可以访问所有的变量
    public void m1() {
        System.out.println(n1 + &quot; &quot; + n2 + &quot; &quot; + n3 + &quot; &quot; + n4);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

public class B {
    public void test() {
        A a = new A();
        System.out.println(a.n1 + &quot; &quot; + a.n2 + &quot; &quot; + a.n3);
        //在同一个包下可以访问 默认 public protected 修饰的变量
        //不可以访问private修饰的n4属性
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C类的子类权限暂时不做验证，在讲完子类后再做演示&lt;/p&gt;
&lt;p&gt;D类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.pkg;

import com.npu.modifier.A;
public class D {
    public void test() {
        A a = new A();
        System.out.println(a.n1);
        //在不同包下 只可以访问public修饰的属性方法
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.modifier;

import com.npu.pkg.D;

public class Main {
    public static void main(String[] args) {
        A a = new A();
        a.test();
        B b = new B();
        b.test();
        D d = new D();
        d.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;面向对象的三大特征&lt;/h2&gt;
&lt;h3&gt;封装&lt;/h3&gt;
&lt;p&gt;把抽象出来的属性和方法封装在一起，数据被保护在内部，程序的其他部分只有通过授权的方法才可以对于数据进行操作&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;p&gt;1.可以隐藏实现的细节，不必对外展示，外部直接传入参数即可使用&lt;/p&gt;
&lt;p&gt;2.可以对数据进行验证，保证安全合理&lt;/p&gt;
&lt;h3&gt;封装的实现步骤&lt;/h3&gt;
&lt;p&gt;1.将属性私有化&lt;/p&gt;
&lt;p&gt;2.提供一个公共的 set 方法用于对属性进行判断以及赋值(伪代码)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void setNum() {
	if(){
		set(Num);
	} else {
		sout(info)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.提供一个公共的 get 方法，用于获取某个属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public 类型 getNum(){
	return data;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Person {

    public String name;
    private int age;
    private double salary;

    public void setName(String name) {
        if(name.length() &amp;lt; 10) {
            this.name = name;
        } else {
            System.out.println(&quot;Name is too long&quot;);
        }
    }

    public void setSalary(double salary) {
        if(salary &amp;gt;= 0) {
            this.salary = salary;
        } else {
            System.out.println(&quot;illegal Salary&quot;);
        }
    }
    public void setAge(int age) {
        if(age &amp;gt;= 0 &amp;amp;&amp;amp; age &amp;lt;= 120) {
            this.age = age;
        } else {
            System.out.println(&quot;illegal Age&quot;);
        }
    }
    public void print() {
        System.out.println(&quot;Name: &quot; + name + &quot; Age: &quot; + age + &quot; Salary: &quot; + salary);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.setSalary(500);
        p.setName(&quot;Nikola&quot;);
        p.setAge(18);
        p.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以将构造器和封装结合起来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Person(String name, int age, double salary) {
        setName(name);
        setAge(age);
        setSalary(salary);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Main {
    public static void main(String[] args) {
        Person p = new Person(&quot;lory&quot;, 18, 3000);
        p.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个模拟银行注册的代码案例&lt;/p&gt;
&lt;p&gt;主函数调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class AccountTest {
    public static void main(String[] args) {
        Account account = new Account(&quot;thrinisy&quot;, 2000, &quot;123&quot;);
        account.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Account类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.npu.encap;

public class Account {
    private String name;
    private double balance;
    private String password;

    public Account(String name, double balance, String password) {
        setName(name);
        setBalance(balance);
        setPassword(password);
    }
    public void setName(String name) {
        if(name.length() == 2 || name.length() == 3|| name.length() == 4) {
            this.name = name;
            System.out.println(&quot;设置成功，用户名是&quot; + name);
        } else {
            this.name = &quot;王女士&quot;;
            System.out.println(&quot;姓名必须要满足2-4位，设置为默认用户名字：王女士&quot;);
        }
    }
    public void setBalance(double balance) {
        if(balance &amp;gt; 20) {
            this.balance = balance;
            System.out.println(&quot;设置成功，余额为&quot; + balance);
        } else {
            System.out.println(&quot;设置失败，余额必须大于20 ，赋初值位6666.6&quot;);
            this.balance = 6666.6;
        }
    }
    public void setPassword(String password) {
        if(password.length() == 6) {
            this.password = password;
            System.out.println(&quot;设置密码成功&quot;);
        } else {
            this.password = &quot;123456&quot;;
            System.out.println(&quot;设置密码失败，密码必须为六位数，默认设置为123456&quot;);
        }
    }
    public void print() {
        System.out.println(&quot;name = &quot; + name + &quot;, balance = &quot; + balance + &quot;, password = &quot; + password);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;姓名必须要满足2-4位，设置为默认用户名字：王女士
设置成功，余额为2000.0
设置密码失败，密码必须为六位数，默认设置为123456
name = 王女士, balance = 2000.0, password = 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;周末有事耽搁了，本来打算今天对于继承 多态收尾的，就把这两个部分放在明天来学习&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%BD%BD%E5%A4%9A%E5%8F%82%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8%E4%BD%9C%E7%94%A8%E5%9F%9Fthis/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%BD%BD%E5%A4%9A%E5%8F%82%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8%E4%BD%9C%E7%94%A8%E5%9F%9Fthis/</guid><description>重载，多参方法，构造器，作用域，this</description><pubDate>Sat, 08 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的重载&lt;/h2&gt;
&lt;p&gt;Java中允许同名方法的存在，这种情况下要求同名方法的参数不同&lt;/p&gt;
&lt;p&gt;以下是一个具体的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		myTool.Print(1);
		myTool.Print(&apos;1&apos;);
		myTool.Print(&quot;This is overload&quot;);
    }
}

class Tool {
	public void Print(int n) {
		System.out.println(n);
	}
	public void Print(char n) {
		System.out.println(n);
	}
	public void Print(String n) {
		System.out.println(n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重载除了形式参数类型不一样还可以数量不一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test(1, 2));
		System.out.println(myTool.Test(1, 2.0));
		System.out.println(myTool.Test(1.0, 2));
		System.out.println(myTool.Test(1, 2, 3));
    }
}

class Tool {
	public int Test(int m, int n) {
		return m + n;
	}
	public double Test(int m, double n) {
		return m + n;
	}
	public double Test(double m, int n) {
		return m + n;
	}
	public int Test(int n1, int n2, int n3) {
		return n1 + n2 + n3;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test(1, 2));
		System.out.println(myTool.Test(1.0, 2.0));
		System.out.println(myTool.Test(1.0, 3.0, 2.0));
    }
}

class Tool {
	public int Test(int m, int n) {
		return m &amp;gt; n ? m : n;
	}
	public double Test(double m, double n) {
		return m &amp;gt; n ? m : n;
	}
	public double Test(double m, double n, double i) {
		double max = m &amp;gt; n ? m : n;
		return max &amp;gt; i ? max : i;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的可变参数&lt;/h2&gt;
&lt;p&gt;java中允许将同一个类中多个同名同功能但参数个数不同的方法，封装为一个方法，可以通过可变参数实现&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;访问修饰符 返回类型 方法名称（数据类型... 形参名称）&lt;/p&gt;
&lt;p&gt;使用可变参数的时候作为数组来进行使用&lt;/p&gt;
&lt;p&gt;以下是一个可变参数的代码示例，可以计算 n 个数据的和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		System.out.println(myTool.Test());
		System.out.println(myTool.Test(1.0, 2.0));
		System.out.println(myTool.Test(1.0, 3.0, 2.0));
    }
}

class Tool {
	public double Test(double... nums) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
		double result = 0.0;
		for(int i = 0; i &amp;lt; nums.length; i++) {
			result +=nums[i];
		}
		return result;
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;可变参数的使用细节&lt;/h3&gt;
&lt;p&gt;1.可变参数的参数个数可以是 0 个或者任意多个&lt;/p&gt;
&lt;p&gt;2.可变参数的实参可以为数组（但是不允许可变的传统数组）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr[] = {1, 2, 3};	
		myTool.Test(arr);
    }
}

class Tool {
	public void Test(int... nums) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//如下的代码编译错误
public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr1[] = {1, 2, 3};
		int arr2[] = {1, 2, 3};
		int arr3[] = {1, 2, 3};
		myTool.Test(arr1);
		myTool.Test(arr1, arr2, arr3);
    }
}

class Tool {
	public void Test(int... nums[]) {
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);	
		for(int i = 0; i &amp;lt; nums.length; i++) {
			System.out.println(&quot;第&quot;+ i + &quot;个数组&quot;);
			for(int j = 0; j &amp;lt; nums[i].length; j++) {
				System.out.print(nums[i][j] + &quot; &quot;);
			}
		}
	}
	
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.可变参数的本质就是数组&lt;/p&gt;
&lt;p&gt;4.可变参数可以和普通类型的参数一起放在形参列表，但是必须要保证可变参数在最后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		int arr[] = {1, 2, 3};	
		myTool.Test(&quot;arr&quot;, arr);
//	myTool.Test(arr, &quot;arr&quot;);
    }
}
class Tool {
	public void Test(String str, int... nums) {
//  public void Test(int... nums, String str) {
		System.out.println(&quot;字符串&quot; + str);	
		System.out.println(&quot;接收了&quot; + nums.length + &quot;个参数&quot;);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.一个形参列表只能出现一个可变参数 ，不允许多个可变参数&lt;/p&gt;
&lt;p&gt;以下是一个练习题目 其目的是接收学生的名字和不确定个数的成绩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		double result = myTool.Test(&quot;Li Wen&quot;, 100.0, 33.0, 220.0);
		System.out.println(&quot;学生的总成绩是&quot; + result);
    }
}

class Tool {
	public double Test(String str, double... nums) {
		System.out.println(&quot;学生&quot; + str);	
		System.out.println(&quot;有&quot; + nums.length + &quot;个成绩&quot;);	
		double result = 0;
		for(int i = 0; i &amp;lt; nums.length; i++) {
			result += nums[i];
		}
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的作用域&lt;/h2&gt;
&lt;p&gt;局部变量一般是在成员方法中定义的变量&lt;/p&gt;
&lt;h3&gt;全局变量（属性）&lt;/h3&gt;
&lt;p&gt;也就是属性，作用于是整个类体，方法可以使用他们&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		
    }
}

class Tool {
	String name = &quot;jack&quot;;

	public void Test() {
		int n = 10;
		System.out.println(name);
	}

	public void Test1() {
		//System.out.println(n);
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;局部变量&lt;/h3&gt;
&lt;p&gt;除了属性外的其他变量，作用域在代码块中&lt;/p&gt;
&lt;h3&gt;注意要点&lt;/h3&gt;
&lt;p&gt;全局变量可以不赋值，有默认值，局部变脸必须要赋值才可以使用，因为没有默认值&lt;/p&gt;
&lt;p&gt;作用域注意事项&lt;/p&gt;
&lt;p&gt;1.属性和局部变量可以重名，访问时遵循就近原则&lt;/p&gt;
&lt;p&gt;2.在同一个作用域内，同一个成员方法中，两个局部变量不能够重名&lt;/p&gt;
&lt;p&gt;这里 java 和 c 语言中存在不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C语言&lt;/strong&gt;：允许在嵌套的代码块中重新定义与外层同名的变量，内层的变量会遮蔽外层的变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java&lt;/strong&gt;：不允许在嵌套的代码块中重新定义与外层同名的变量，编译器会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.属性的生命周期长于局部变量，属性随着对象创建而创建，随对象的销毁而销毁，局部变量是在方法调用时产生，调用完成后销毁&lt;/p&gt;
&lt;p&gt;4.全局变量可以被本类使用和其他的类使用（通过对象调用完成）局部变量只可以在本类的对应方法中使用&lt;/p&gt;
&lt;p&gt;也可以支持对象之间的相互传对象本身，编译通过，但是在实际编写代码的时候应该尽量避免相互依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		Person human = new Person();
		myTool.Test(human);
		human.Test(myTool);
    }
}

class Person {
	String name = &quot;jack&quot;;
	public void Test(Tool human) {
		System.out.println(human.name);
	}
}

class Tool {
	String name = &quot;liry&quot;;
	public void Test(Person human) {
		System.out.println(human.name);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.全局变量可以被访问修饰符使用，而局部变脸不行&lt;/p&gt;
&lt;h2&gt;Java中的构造器&lt;/h2&gt;
&lt;p&gt;构造方法，其中它的方法名字和类的名字相同&lt;/p&gt;
&lt;p&gt;构造方法没有返回值，也不能使用返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[修饰符] 方法名 (形参列表) {
	方法体;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个简单的入门代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool(&quot;thrinisty&quot;, 14);
		myTool.test();	
    }
}
class Tool {
	String name;
	int age;
	public Tool(String n, int m) {
		name = n;
		age = m;
	}
	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造器的使用细节&lt;/p&gt;
&lt;p&gt;1.构造器可以被重载，可以定义多个构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool(&quot;thrinisty&quot;);
        //在这里没有指定年龄，使用的是第二个构造方法
		myTool.test();
		
    }
}

class Tool {
	String name;
	int age;
	public Tool(String n, int m) {
		name = n;
		age = m;
	}

	public Tool(String n) {
		name = n;
		age = 0;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.构造器的名称要和类的名称相同&lt;/p&gt;
&lt;p&gt;3.构造器没有返回值&lt;/p&gt;
&lt;p&gt;4.构造器不会创建兑现，他的目的只是为了完成初始化&lt;/p&gt;
&lt;p&gt;5.在创建对象的时候会自动调用构造方法，不允许主动调用构造方法&lt;/p&gt;
&lt;p&gt;6.如果没有定义构造方法，系统会自动给类生成一个无参数的构造器&lt;/p&gt;
&lt;p&gt;可以使用 javap 反编译工具进行验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/49.png&quot; alt=&quot;49&quot; /&gt;&lt;/p&gt;
&lt;p&gt;7.一旦定义了构造方法，默认的无参构造器就被覆盖了，如果需要使用要显示定义一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Tool myTool = new Tool();
		myTool.test();
		
    }
}

class Tool {
	String name;
	int age;
	public Tool(){}

	public Tool(String n) {
		name = n;
		age = 0;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的this关键字&lt;/h2&gt;
&lt;p&gt;java虚拟机会给每一个对象分配一个this，这个this可以被当成为一个属性，这个属性是一个引用指向对象自己&lt;/p&gt;
&lt;p&gt;以下是一个代码示例，this 指的就是Person这个类，可以通过this 来引用类的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person(&quot;lory&quot;, 18);
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;名字是&quot; + name + &quot;年龄是&quot; + age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this在内存中的存在形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/50.png&quot; alt=&quot;50&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们也可以通过哈希编码来验证这个this指向的内容和对象引用的内存地址是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person(&quot;lory&quot;, 18);
		System.out.println(&quot;对象的哈希值是&quot; + human.hashCode());
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;this引用的哈希值是&quot; + this.hashCode());
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\71460\Desktop\Java\day8\class1&amp;gt; java Object
对象的哈希值是1311053135
this引用的哈希值是1311053135
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;this关键字的使用细节&lt;/h2&gt;
&lt;p&gt;1.this 可以用来访问本类的属性，方法，构造器&lt;/p&gt;
&lt;p&gt;2.this用于区分当前类的属性和局部变量&lt;/p&gt;
&lt;p&gt;3.this不能够被类定义的外部使用，只可以在类定义的方法中使用&lt;/p&gt;
&lt;p&gt;4.访问构造器语法this (参数列表)，只可以在构造器中使用（还必须将this语句放在第一条语句）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human = new Person();
		human.test();
		
    }
}

class Person {
	String name;
	int age;

	public Person() {
		this(&quot;jack&quot;, 100);//第一条语句
	}

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void test() {
		System.out.println(&quot;对象 &quot; + this.name + this.age);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;关键字用于引用当前对象的实例。在&lt;code&gt;Person&lt;/code&gt;类中，&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;this.age&lt;/code&gt;明确地指向当前对象的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;属性。然而，在&lt;code&gt;test&lt;/code&gt;方法中，直接使用&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;也可以访问这些属性，因为它们在当前对象的上下文中是可见的&lt;/p&gt;
&lt;p&gt;在代码规范上：开发团队或代码风格指南可能要求使用&lt;code&gt;this&lt;/code&gt;来访问实例变量，以增加代码的可读性和一致性。&lt;/p&gt;
&lt;h2&gt;this练习题目&lt;/h2&gt;
&lt;p&gt;判断类属性是否相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Person human1 = new Person();
		Person human2 = new Person(&quot;lory&quot;, 11);
		if(human1.compareTo(human2)) {
			System.out.println(&quot;对象属性相同&quot;);
		} else {
			System.out.println(&quot;对象属性不同&quot;);
		}
    }
}

class Person {
	String name;
	int age;

	public Person() {
		this(&quot;jack&quot;, 100);
	}

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public boolean compareTo(Person another) {
		return another.name.equals(this.name) &amp;amp;&amp;amp; another.age == this.age;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;章节作业&lt;/h2&gt;
&lt;p&gt;1.找到double数组中最大值返回这个最大值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        double arr[] = {1.3, 2.5, 1.1, 3.2, 5.2};
		Tool myTool = new Tool();
		System.out.println(&quot;最大值是&quot; + myTool.findMax(arr));
    }
}

class Tool{
	public double findMax(double[] arr) {
		double max = 0.0;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(max &amp;lt; arr[i]) {
				max = arr[i];
			}
		}
		return max;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.找到字符串元素的下标&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        String arr[] = {&quot;1.3&quot;, &quot;2.5&quot;, &quot;1.1&quot;, &quot;3.2&quot;, &quot;5.2&quot;};
		Tool myTool = new Tool();
		System.out.println(&quot;元素下标是&quot; + myTool.findString(arr, &quot;1.1&quot;));
    }
}

class Tool{
	public int findString(String[] arr, String target) {
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(target.equals(arr[i])){
				index = i;
				return index;
			}
		}
		return index;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.改变书本价格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Book myBook = new Book(&quot;爱丽丝&quot;, 133.0);
		myBook.updatePrice();
		System.out.println(myBook.price);
    }
}

class Book{
	String name;
	double price;
	public Book(String name, double price){
		this.name = name;
		this.price = price;
	}

	public void updatePrice() {
		if(this.price &amp;gt; 150) {
			this.price = 150;
		} else if(this.price &amp;lt;= 150 &amp;amp;&amp;amp; this.price &amp;gt; 100) {
			this.price = 100;
		} else {}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.实现数组的复制功能，元素和旧数组一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool();
		int oldArr[] = {1, 3, 5, 6};
		myTool.print(oldArr);
		int newArr[] = myTool.copyArr(oldArr);
		myTool.print(newArr);
    }
}

class Tool{
	public int[] copyArr(int[] arr) {
		int newArr[] = new int[arr.length];
		for(int i = 0; i &amp;lt; arr.length; i++) {
			newArr[i] = arr[i];
		}
		return newArr;
	}

	public void print(int[] arr) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.定义一个圆类，属性有半径， 提供周长方法，提供面积方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool(1.9);
		System.out.println(&quot;面积是&quot; + myTool.area());
		System.out.println(&quot;周长是&quot; + myTool.lan());
    }
}

class Tool{
	double r;
	public Tool(double r) {
		this.r = r;
	}

	public double area() {
		return Math.PI * r * r;
	}

	public double lan() {
		return Math.PI * r * 2;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.一个简单的除法计算器&lt;/p&gt;
&lt;p&gt;其中返回的类型是Double的包装类，可以返回null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		Tool myTool = new Tool(2.9, 0);

		if(myTool.div() != null) {
			System.out.println(&quot;结果是&quot; + myTool.div());
		}			
    }
}

class Tool{
	double num1;
	double num2;
	public Tool(double num1, double num2) {
		this.num1 = num1;
		this.num2 = num2;
	}

	public Double div() {
		if(num2 == 0){
			System.out.println(&quot;除数不能为0&quot;);
			return null;
		} else {
			return this.num1 / this.num2;
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.在类中传入其他类的实例，并调用其方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
		PassObject myFunction = new PassObject();
		Tool myTool = new Tool(2.0);
		myFunction.printAreas(myTool, 3);
    }
}

class Tool{
	double r;
	public Tool(double r) {
		this.r = r;
	}

	public double area() {
		return Math.PI * r * r;
	}

	public void setC(double n) {
		this.r = n;
	}
}

class PassObject {
	public void printAreas(Tool myCircle, int times) {
		for(int i = 1; i &amp;lt;= times; i++)
		{
			myCircle.setC(i);
			System.out.println(myCircle.area());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.综合实验题目：猜数字&lt;/p&gt;
&lt;p&gt;（还可以在类的封装上加以改进将People类和输入类封装在一个游戏类中通过在主函数中创建的游戏类来启动游戏，在这里不多过多介绍）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object {
    public static void main(String[] args) {
      People myPeople = new People();
      Scanner myScanner = new Scanner(System.in);
      while(true) {
        System.out.println(&quot;请输入数字&quot;);
        myPeople.setTarget(myScanner.nextInt());
        if(myPeople.complete()) {
          System.out.println(&quot;游戏结束&quot;);
          break;
        }
      }
    }
}

class People {
    int target;
    Machine myMachine = new Machine();
    int flag = myMachine.create();

    public void setTarget(int target) {
      this.target = target;
    }
    public boolean complete() {
      if(flag == target) {
        System.out.println(&quot;结果正确&quot;);
        return true;
      } else if(flag &amp;lt; target) {
        System.out.println(&quot;结果大了，请继续&quot;);
        return false;
      } else {
        System.out.println(&quot;结果小了，请继续&quot;);
        return false;      
      }
    }

}

class Machine {
    int target;
    public int create(){
      return (int)(Math.random() * 100) + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java面向对象的基础部分到此为止，接下来会进入IDEA的使用，包，访问修饰符，封装的部分&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</guid><description>一些递归练习题目</description><pubDate>Fri, 07 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的递归&lt;/h2&gt;
&lt;p&gt;递归在算法中属于比较复杂的一类了，在这里也希望在 java 的学习中复习算法&lt;/p&gt;
&lt;p&gt;一个简单的入门案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();
		Mytool.test(4);
	}
}

class Tool{
	public void test(int n) {
		if(n &amp;gt; 2) {
			test(n - 1);
		}
		System.out.println(n);
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/48.png&quot; alt=&quot;48&quot; /&gt;&lt;/p&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2
3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要等递归的方法结束后才执行递归调用主体函数中的输出，所以结果是从2到4&lt;/p&gt;
&lt;p&gt;计算阶乘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();
		System.out.println(Mytool.Printni(3));
	}
}

class Tool{
	public int Printni(int n) {
		if(n == 1) {
			return 1;
		} else {
			return Printni(n - 1) * n;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;递归的要点&lt;/h2&gt;
&lt;p&gt;1.执行方法的时候会生成一个新的独立的栈空间&lt;/p&gt;
&lt;p&gt;2.方法的局部变量是独立的不会相互影响&lt;/p&gt;
&lt;p&gt;3.如果方法中使用的是引用类型的数据变量，就会共享该引用类型的数据&lt;/p&gt;
&lt;p&gt;4.递归必须得指定退出的条件，在执行时也必须向退出的条件逼近&lt;/p&gt;
&lt;p&gt;5.当一个方法执行完毕的时候，或 return 就会返回到调用函数中&lt;/p&gt;
&lt;h2&gt;递归的经典例题&lt;/h2&gt;
&lt;h3&gt;斐波那契数列&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;
public class Object{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入斐波那契数列的第几个数&quot;);
		int target = myScanner.nextInt();
		Tool myTool = new Tool();
		System.out.println(&quot;斐波那契的第&quot;+ target + &quot;个数是&quot; + myTool.test(target));
	}
}

class Tool{
	public int test(int n) {
		if(n == 1 || n == 2) {
			return 1;
		} else {
			return test(n - 1) + test(n - 2);
		}
		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;猴子吃桃问题&lt;/h3&gt;
&lt;p&gt;猴子每天吃一般的桃子 再额外吃一个，第十天的时候有1个桃子可以吃，问第一天的时候有几个桃子&lt;/p&gt;
&lt;p&gt;递推式：第n天的桃子 = (第 n - 1 个桃子 / 2)-  1&lt;/p&gt;
&lt;p&gt;反递推式：第n天的桃子  =（第n + 1天的桃子 + 1） * 2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;
public class Object{
	public static void main(String[] args) {
		int target = 10;
		Tool myTool = new Tool();
		System.out.println(myTool.peace(1));
	}
}

class Tool{
	public int peace(int day) {
		if(day == 10){
			return 1;
		} else {
			return (peace(day + 1) + 1) * 2;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;经典的回溯算法走迷宫题目&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int arr[][] = new int[8][7];
		Tool myTool = new Tool();
		for(int j = 0; j &amp;lt; arr[0].length; j++) {
			arr[0][j] = 1;
			arr[arr.length - 1][j] = 1;
		}			
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i][0] = 1;
			arr[i][arr[0].length - 1] = 1;
		}
		arr[3][1] = 1;
		arr[3][2] = 1;
		arr[2][2] = 1;
		myTool.Print(arr);
		System.out.println();
		myTool.findWay(arr, 1, 1);
		myTool.Print(arr);
	}
}

class Tool{
	public void Print(int arr[][]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}

	/*
		如果找到迷宫路径就返回true，否则就返回false
		i 和 j 代表了小球的位置，初始化为 1，1
		0 表示可以走， 1 表示障碍物， 2 表示这条路可以走 3 表示这条路走过但是不可达
		当map[6][5] = 2 表示走通，退出递归
	*/
	public boolean findWay(int map[][], int i, int j) {
		if(map[6][5] == 2) {
			return true;
		} else {
			if(map[i][j] == 0) {
				map[i][j] = 2;
				//假定为可以走通
				if(findWay(map, i + 1, j)) {
					return true;
				} else if(findWay(map, i, j + 1)) {
					return true;
				} else if(findWay(map, i - 1, j)) {
					return true;
				} else if(findWay(map, i, j - 1)) {
					return true;
				} else {
					map[i][j] = 3;
					return false;
				}
			} else {
				return false;
			}

		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;汉诺塔&lt;/h3&gt;
&lt;p&gt;简单的递归问题，一共分为三步，就和把大象塞进冰箱一样&lt;/p&gt;
&lt;p&gt;1.打开冰箱（将A盘上的 n-1 个塔放在B盘）&lt;/p&gt;
&lt;p&gt;2.放入大象（将A盘的最大盘放在C盘）&lt;/p&gt;
&lt;p&gt;3.关闭冰箱（将B盘上的 n-1 个塔放在C盘）&lt;/p&gt;
&lt;p&gt;在这里有一个值得注意的递归终止条件仅仅剩余一个盘，直接放入即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object{
	public static void main(String[] args) {
		Hanoi myHanoi = new Hanoi();
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入汉诺塔的层数&quot;);
		int count = myScanner.nextInt();
		myHanoi.moveTower(count, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);
	}
}

class Hanoi{
	public void moveTower(int n, char a, char b, char c) {
		if(n == 1) {
			System.out.println(&quot;将&quot; + a + &quot;盘上的第一个塔移动到&quot; + c);
		} else {
			moveTower(n - 1, a, c, b);
			System.out.println(&quot;将&quot; + a + &quot;盘上的第一个塔移动到&quot; + c);
			moveTower(n - 1, b, a, c);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;八皇后问题&lt;/h3&gt;
&lt;p&gt;将这一道例题分解为了三个部分来完成&lt;/p&gt;
&lt;p&gt;1.设计了一个一维数组结构用于存放八个皇后，数组的下标代表了放置的行号，对应的数值部分是皇后放置的列数&lt;/p&gt;
&lt;p&gt;2.八皇后递归的主体部分，要注意先将对应的皇后放入一维数组，在进行后续的递归调用&lt;/p&gt;
&lt;p&gt;3.将递归的主体部分的结果返回至一个引用传回结果自增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object {
    public static void main(String[] args) {
        Queen myQueen = new Queen();
		int map[] = new int[8];
		int result[] = {0};
		myQueen.placeQueen(map, 0, result);
		System.out.println(result[0]);
    }
}

class Queen {
	public void placeQueen(int arr[], int row, int rst[]) {
		if(row == 8) {
			rst[0]++;
			return;
		}
		for(int col = 0; col &amp;lt; 8; col++) {
			if(canPlace(arr, row, col)){
				arr[row] = col;
				placeQueen(arr, row + 1, rst);
			}
		}
	}
   
   	public boolean canPlace(int arr[], int row, int col) {
		for(int i = 0; i &amp;lt; row; i++) {
			if(arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row) {
				return false;
			}
		}
		return true;
  	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归的例题完成，接下来是Java中方法的重载，可变参数，构造器的笔记&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/</guid><description>类与对象，方法，属性，对象的克隆</description><pubDate>Thu, 06 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;杨辉三角例题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int arr[][] = new int[10][];
		for(int i = 0; i &amp;lt; 10; i++) {
			arr[i] =new int[i + 1];
			arr[i][0] = 1;
			arr[i][i] = 1;

			if(i &amp;gt; 1) {
				for(int j = 1;j &amp;lt;= i - 1; j++) {
					arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
				}
			}			
		}
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j] +&quot;\t&quot;);
			}
			System.out.println(&quot;&quot;);
		}	
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二维数组的声明有三种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[][] y;
int[] y[];
int y[][];
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;插入算法经典例题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{	
	public static void main(String[] args){
		int arr[] = {10, 12, 45, 90};
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		int table[] = new int[arr.length + 1];
	
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(num &amp;lt; arr[i]) {
				
				for(int j = 0; j &amp;lt; i; j++) {
					table[j] = arr[j];
				}
				table [i] = num;
				for(int j = i + 1; j &amp;lt; table.length; j++) {
					table[j] = arr[j - 1];
				}
				break;//我们只需要找到一次需要插入的位置即可
			}
		}
		arr = table;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] +&quot; &quot;);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原先的算法似乎有一些复杂，以下是一个改进的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	public static void main(String[] args){
		int arr[] = {10, 12, 45, 90};
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		int table[] = new int[arr.length + 1];
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(arr[i] &amp;gt; num) {
				index = i;
				break;
			}
		}
		for(int i = 0, j = 0; i &amp;lt; table.length; i++){
			if(i != index) {
				table[i] = arr[j];
				j++;
			} else {
				table[i] = num;
			}
		}
		arr = table;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] +&quot; &quot;);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;综合例题&lt;/h2&gt;
&lt;p&gt;用数组存储10个随机数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args) {
		int arr[] = new int[10];
		int sum = 0;
		int max = 0;
		int index = -1;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = (int)(Math.random() * 100) + 1;
		}
		System.out.println(&quot;正序打印&quot;);
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
			sum += arr[i];
			if(max &amp;lt; arr[i]) {
				max = arr[i];
				index = i;
			}
		}
		System.out.println(&quot;\n平均数为&quot; + sum / 10);
		System.out.println(&quot;最大值是&quot; + max + &quot; 它的下标为&quot; + index);
		//从大到小排序
		int temp = 0;
		for(int i = 0; i &amp;lt; arr.length - 1; i++) {
			for(int j = 0; j &amp;lt; arr.length - i - 1; j++) {
				if(arr[j] &amp;lt; arr[j + 1]) {
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}

		int target = 30;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(arr[i] == target) {
				System.out.println(&quot;找到了目标数&quot; + target + &quot;下表为&quot; + i);
				break;
			}
			if(arr[i] &amp;lt; target) {
				System.out.println(&quot;没有找到&quot;);
				break;
			}
		}
		
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java 类与对象&lt;/h2&gt;
&lt;p&gt;终于来到了java中最为核心的部分内容，不同于c语言中的面向方法，java 的面向对象可以使得编程更加的贴近于现实。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		String cat1Name = &quot;小白&quot;;
		int cat1Age = 3;
		String cat1Color = &quot;蓝色&quot;

		String cat2Name = &quot;小花&quot;;
		int cat2Age = 2;
		String cat2Color = &quot;红色&quot;		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的代码存储了猫猫的各个信息，但是这样做会使得，变量离散缺少内在的联系&lt;/p&gt;
&lt;p&gt;这个时候会想到数组的结构来存储，但是数组不能存储不同数据类型的成员，全用字符串也没法体现数据含义，在用对于下表读取成员变量时，对应关系不明确&lt;/p&gt;
&lt;p&gt;为解决以上问题我们引入的类与对象&lt;/p&gt;
&lt;p&gt;一个事物，是由它的行为和属性构成的，&lt;/p&gt;
&lt;p&gt;而对象是对于事物的一个抽象，在这样一个抽象之中，会有它的属性和行为&lt;/p&gt;
&lt;p&gt;可以将上述的案例中的猫猫定义成为一种数据类型，这种类型中有猫的颜色，年龄，颜色，还可以有方法行为，这就是类的概念。&lt;/p&gt;
&lt;p&gt;我们用这样的一个抽象的数据类型可以创建一个或者数个具体的对象，也就是猫的对应的个体，称之为实例。&lt;/p&gt;
&lt;p&gt;用类来存放猫猫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Object{
	public static void main(String[] args) {
		//使用面向对象的方式来存放猫猫
		Cat cat1 = new Cat();
		cat1.name = &quot;小花&quot;;
		cat1.age = 2;
		cat1.color = &quot;红色&quot;;
		Cat cat2 = new Cat();
		cat2.name = &quot;小白&quot;;
		cat2.age = 3;
		cat2.color = &quot;白色&quot;;
	}
}

class Cat {
	//定义一个猫猫类
	String name;
	int age;
	String color;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用这样的方式可以方便的添加属性以及行为，也方便创建全新的猫猫实例&lt;/p&gt;
&lt;h2&gt;对象在内存中的存在形式&lt;/h2&gt;
&lt;p&gt;在创建一个对象实例的时候，对象的引用存放在 java虚拟机内存中的栈，而它所指向的属性会放在堆中（存放的形式是由对象的属性类型所决定的，基本数据类型的属性会放在堆中，而字符串类型的属性会在堆中存放其引用，而字符串内容会被放置在方法区的常量池中）&lt;/p&gt;
&lt;p&gt;额外的在用 new 创建一个对象的时候会将类的信息加载到方法区（属性，方法）&lt;img src=&quot;../images/47.png&quot; alt=&quot;47&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;属性 成员变量&lt;/h2&gt;
&lt;p&gt;从概念而言 成员变量 属性 字段都是用来表示类中的单个数据类型的，使用上是等价的&lt;/p&gt;
&lt;p&gt;1.在修饰属性中我们可以加上访问修饰符public protected 默认 private&lt;/p&gt;
&lt;p&gt;使用方式 访问修饰符 属性类型 属性名称&lt;/p&gt;
&lt;p&gt;2.属性的定义类型可以是任意类型，包含基本类型，引用类型&lt;/p&gt;
&lt;p&gt;3.属性如果不赋值，会有一些的默认值，规则同数组一样&lt;/p&gt;
&lt;p&gt;默认赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human = new Person();
		System.out.println(&quot;姓名 &quot; + human.name + &quot;\n年龄 &quot; + human.age
		+ &quot;\n薪水 &quot; + human.salary + &quot;\n是否通过 &quot; + human.isPass);
	}
}

class Person {
	String name;
	int age;
	double salary;
	boolean isPass;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;姓名 null
年龄 0
薪水 0.0
是否通过 false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;补充知识&lt;/h2&gt;
&lt;h3&gt;字符串常量池&lt;/h3&gt;
&lt;p&gt;字符串常量池是常量池的一部分，专门用于存储字符串字面量。它的设计目的是为了减少重复字符串的内存占用。&lt;/p&gt;
&lt;p&gt;之前笔记中提到的 int 包装类 数据类型存放在-128 -- 127也会被放在常量池中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 10; // 自动装箱，从常量池中获取对象
Integer y = 10; // 自动装箱，从常量池中获取对象

System.out.println(x == y); // true，因为 x 和 y 指向常量池中的同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;String s1 = &quot;Hello&quot;;  // &quot;Hello&quot; 会被放入字符串常量池
String s2 = &quot;Hello&quot;;  // 直接从字符串常量池中获取
String s3 = new String(&quot;Hello&quot;);  // 在堆中创建一个新的字符串对象

System.out.println(s1 == s2);  // true，因为 s1 和 s2 指向常量池中的同一个对象
System.out.println(s1 == s3);  // false，因为 s3 是堆中的一个新对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;字符串常量池的特点：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字面量赋值&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用双引号直接赋值的字符串（如 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;）会被放入字符串常量池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;new String()&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;new String()&lt;/code&gt; 创建的字符串对象会存储在堆中，而不是字符串常量池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;intern()&lt;/code&gt; 方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以将堆中的字符串对象放入字符串常量池，并返回常量池中的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String s4 = new String(&quot;World&quot;).intern();
String s5 = &quot;World&quot;;
System.out.println(s4 == s5);  // true，因为 s4 通过 intern() 方法放入了常量池
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Java中的几个存储区域&lt;/h2&gt;
&lt;p&gt;堆：存放 对象 数组 等&lt;/p&gt;
&lt;p&gt;栈：一般存放基本数据类型（局部变量）&lt;/p&gt;
&lt;p&gt;方法区：常量池（常量，比如字符串）加载信息&lt;/p&gt;
&lt;h2&gt;Java中创建对象的流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	Person human = new Person();
	temp.name = &quot;thrinisty&quot;;
	temp.age = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.加载Person类信息到方法区&lt;/p&gt;
&lt;p&gt;2.在堆中进行分配空间，进行默认的初始化&lt;/p&gt;
&lt;p&gt;3.将地址赋值给类的引用&lt;/p&gt;
&lt;p&gt;4.进行指定初始化,如上述的字符串赋值，和年龄赋值&lt;/p&gt;
&lt;h2&gt;Java中的成员方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human;
		human = new Person();
		human.speak();//调用方法
	}
}
class Person {
	String name;
	int age;

	public void speak() {
		System.out.println(&quot;我是一个好人&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里在 Person 类中定义了一个方法，输出了一段话，并在主函数中调用了这样一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Person human;
		human = new Person();
		human.speak();
		human.sum();
		System.out.println(human.add(10, 5));
	}
}
class Person {
	String name;
	int age;

	public void speak() {
		System.out.println(&quot;我是一个好人&quot;);
	}

	public void sum() {
		int result = 0;
		for(int i = 0; i &amp;lt; 1000; i++) {
			result += i;
		}
		System.out.println(result);
	}

	public int add(int count1, int count2) {
		int result = count1 + count2;
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Java中同样可以传入参数参与方法中的运算，在这里实现了一个加法的方法并将结果返回到了主函数中，在Java中我们在调用方法的时候和C语言类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保存当前指令地址&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在Java中，JVM会维护一个调用栈（Call Stack），用于跟踪方法调用。当一个方法被调用时，JVM会将当前的执行状态（包括程序计数器，即下一条指令的地址）保存在调用栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将方法参数压栈&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Java方法的参数会被压入操作数栈（Operand Stack）中。JVM是基于栈的虚拟机，所有的操作（包括方法调用）都是通过操作数栈来完成的。参数会按照方法声明的顺序被压入栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;JVM会执行&lt;code&gt;invokevirtual&lt;/code&gt;、&lt;code&gt;invokestatic&lt;/code&gt;、&lt;code&gt;invokeinterface&lt;/code&gt;或&lt;code&gt;invokespecial&lt;/code&gt;等字节码指令来调用方法。这些指令会根据方法的类型（实例方法、静态方法、接口方法等）来决定如何调用方法。&lt;/li&gt;
&lt;li&gt;在调用方法时，JVM会创建一个新的栈帧（Stack Frame）并将其压入调用栈。这个栈帧包含了方法的局部变量表、操作数栈等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行方法体&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;方法体中的字节码指令会被逐条执行。JVM会根据指令对操作数栈进行操作，计算结果会存储在操作数栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回结果&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当方法执行完毕后，JVM会将返回值压入调用者的操作数栈中。返回值的类型取决于方法的返回类型（&lt;code&gt;void&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退栈&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;方法执行完毕后，JVM会弹出当前方法的栈帧，恢复调用者的栈帧，并继续执行调用者的下一条指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中与c的函数调用有一些区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调用栈管理&lt;/strong&gt;：在C语言中，调用栈是由硬件和操作系统直接管理的，而在Java中，调用栈是由JVM管理的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码与机器码&lt;/strong&gt;：Java方法调用是通过字节码指令（如&lt;code&gt;invokevirtual&lt;/code&gt;）来完成的，而C语言中的函数调用是通过机器码指令（如&lt;code&gt;call&lt;/code&gt;）来完成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt;：Java有自动内存管理（垃圾回收），而C语言需要手动管理内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方法的妙用&lt;/h2&gt;
&lt;p&gt;可以提高代码的可读性，可以方便后续的维护，可以供用户方便调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int arr[][] = {{1, 3, 5}, {1, 6, 7}, {0, 3, 5}};
		Tool Mytool = new Tool();	
		Mytool.arrPrint(arr);
	}
}

class Tool {
	public void arrPrint(int table[][]) {
		for(int i = 0; i &amp;lt; table.length; i++) {
			for(int j = 0; j &amp;lt; table[i].length; j++) {
				System.out.print(table[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;方法的定义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public void arrPrint(int table[][]) {
//方法修饰类型 + 返回类型 + 方法名称 + （形参列表）
//  {
//    	方法主体	    
//  }
		for(int i = 0; i &amp;lt; table.length; i++) {
			for(int j = 0; j &amp;lt; table[i].length; j++) {
				System.out.print(table[i][j] + &quot; &quot;);
			}
			System.out.println();
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当要返回多个值的时候可以使用数组的返回类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();	
		int rst[] = new int[2];
		rst = Mytool.AddFunction(10, 15);
		System.out.println(&quot;+:&quot; + rst[0]);
		System.out.println(&quot;-:&quot; + rst[1]);
	}
}

class Tool {
	public int[] AddFunction(int n1, int n2) {
		int result[] = new int[2];
		result[0] = n1 + n2;
		result[1] = n1 - n2;
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用自定义的类来进行返回&lt;/p&gt;
&lt;p&gt;在这个例子中使用了自定义的 Result 结果类 将方法返回类型更改为Result即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool Mytool = new Tool();	
		Result rst = new Result();
		rst = Mytool.AddFunction(15, 10);
		System.out.println(&quot;+:&quot; + rst.add);
		System.out.println(&quot;-:&quot; + rst.sub);
	}
}

class Tool {
	public Result AddFunction(int n1, int n2) {
		Result result = new Result();
		result.add = n1 + n2;
		result.sub = n1 - n2;
		return result;
	}
}

class Result {
	int add;
	int sub;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法不能嵌套定义&lt;/p&gt;
&lt;h2&gt;方法的调用&lt;/h2&gt;
&lt;p&gt;1.同一个类的方法可以直接调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		A target = new A();
		target.print(19);
	}
}

class A {
	public void print(int n) {
		System.out.println(n);
	}
	public void Ok() {
		print(10);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.跨类的方法调用需要使用对象名进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		A target = new A();
		target.print(19);
		target.UseB(1);
	}
}

class A {
	public void print(int n) {
		System.out.println(n);
	}
	public void Ok() {
		print(10);
	}
	public void UseB(int n) {
		B ClassB = new B();
		ClassB.print(n);
	}
}

class B {
	public void print(int n) {
		System.out.println(&quot;B类的方法：&quot; + n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要在 A 的方法后创建一个 B 的实例，再运用 B 实例的引用来调用 B 类的方法&lt;/p&gt;
&lt;h2&gt;方法练习题目&lt;/h2&gt;
&lt;p&gt;判断一个数是是偶数还是奇数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		if(target.Judge(40)) {
			System.out.println(&quot;是一个偶数&quot;);
		} else {
			System.out.println(&quot;是一个奇数&quot;);
		}		
	}
}

class AA {
	public boolean Judge(int n) {
		if(n % 2 == 0) {
			return true;
		} else {
			return false;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印#字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		target.Print(3, 5);	
	}
}

class AA {
	public void Print(int m, int n) {
		for(int i = 0; i &amp;lt; m; i++) {
			for(int j = 0; j &amp;lt; n; j++) {
				System.out.print(&quot;#&quot;);
			}
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;成员方法的传参机制&lt;/h2&gt;
&lt;p&gt;1.方法中基本类型参数的传递中不会改变被调用参数的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		AA target = new AA();
		int m = 3, n = 5;
		target.Print(m, n);	
		System.out.println(&quot;主函数中的m n&quot;);
		System.out.println(&quot;m:&quot; + m);
		System.out.println(&quot;n:&quot; + n);
	}
}

class AA {
	public void Print(int m, int n) {
		int tmp = m;
		m = n;
		n = tmp;
		System.out.println(&quot;方法体中的m n&quot;);
		System.out.println(&quot;m:&quot; + m);
		System.out.println(&quot;n:&quot; + n);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法体中的m n
m:5
n:3
主函数中的m n
m:3
n:5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见调用方法内部的参数发生交换，打印结果改变&lt;/p&gt;
&lt;p&gt;但是主函数中的实际参数没有发生交换，这是因为调用的方法中的参数并不是对于主函数中m n的引用，并不会对于主方法中的参数产生改变&lt;/p&gt;
&lt;p&gt;2.方法中引用类型参数的传递中会改变被调用引用所指向的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int array[] = {1, 3, 6, 6};
		Tool MyTool = new Tool();
		MyTool.ChangeNum(array);
		MyTool.ArrPrint(array);
	}
}

class Tool {
	public void ChangeNum(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = 0;
		}
	}

	public void ArrPrint(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			System.out.print(arr[i] + &quot; &quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 0 0 0 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来这个例子非常容易犯错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		int array[] = {1, 3, 6, 6};
		Tool MyTool = new Tool();
		MyTool.ChangeNum(array);
		System.out.println(array[3]);
	}
}

class Tool {
	public void ChangeNum(int arr[]) {
		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = i;
		}
		arr = null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问是否可以正常编译运行，我开始是这么想的，既然 arr 指向了空 ，那么代表了他没有办法正常的访问成员数据，那么在主函数中的6行就会发生报错&lt;/p&gt;
&lt;p&gt;但是结果就是可以运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为运行的过程中虽然时指向了一个数组，利用方法体中的引用对于数组进行修改，但是原来主函数中的引用却没有消失，方法体中的引用设置空，不影响主方法的引用访问数组&lt;/p&gt;
&lt;h2&gt;对象的克隆&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Object{
	public static void main(String[] args) {
		Tool MyTool = new Tool();
		Person human = new Person();
		human.name = &quot;Li Haoxuan&quot;;
		human.age = 22;
		Person newHuman;
		newHuman = MyTool.CloneClass(human);
		human.name = &quot;Wang Ling&quot;;
		System.out.println(newHuman.name);
		//新的对象，改变原来的名字不会改变克隆的新人类
	}
}

class Tool {
	public Person CloneClass(Person human) {
		Person newHuman =new Person();
		newHuman.name = human.name;
		newHuman.age = human.age;
		return newHuman;
	}
}

class Person {
	String name;
	int age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将方法中创建的空间以及内容对应的引用返回赋值主函数中的引用就可以完成克隆，满足用主函数的新引用来使用克隆出来的内容&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</guid><description>数组，二维数组，数组赋值机制</description><pubDate>Wed, 05 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的数组&lt;/h2&gt;
&lt;p&gt;array 数组，在要处理大量数据的时候，引用数组的意义就非常重要了&lt;/p&gt;
&lt;p&gt;数组的定义：数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型&lt;/p&gt;
&lt;p&gt;使用场景：例如有很多的 hens 的时候 可以使用数组大量存储hens的数据，还可以通过for 循环来进行进行数据的批量处理&lt;/p&gt;
&lt;h3&gt;数组的静态初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		double hens[] = {3, 5, 1, 3.4, 2, 50};
        /*
        等价于 double hens[] = new double[6];
        hens[0] = 3;
        ......
        hens[5] = 50;
        */
		double sum = 0;
		for(int i = 0; i &amp;lt; 6; i++) {
			sum += hens[i];
		}
		System.out.println(sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组的使用方式&lt;/h2&gt;
&lt;h3&gt;数组的动态初始化&lt;/h3&gt;
&lt;p&gt;数据类型 数组名称[ ] = new 数据类型 [ 大小 ]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[] = new int[5];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		double sum = 0;
		double grade[] = new double[5];
		for(int i = 0; i &amp;lt; 5; i++) {
			System.out.println(&quot;请输入第&quot; + (i+1) +&quot;个成绩&quot;);
			grade[i] = myscanner.nextInt();
			sum += grade[i];
		}
		System.out.println(&quot;总和是&quot; + sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以先声明，在创建数组的实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a[];		//这个时候数组指向空
a = new int[5];	//在这里分配了数组对应的空间，再将数组指向了这个空间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组使用的注意事项&lt;/p&gt;
&lt;p&gt;1.数组元素可以是基本类型和引用类型，java不支持数组数据类型混用&lt;/p&gt;
&lt;p&gt;2.数组创建后如果没有赋值，会默认赋初始值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 *int short byte long 0
 *double float 0.0
 *char \u0000
 *boolean false
 *String null
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用数组的步骤，1.声明数组 2.分配空间 3.给数组的各个空间赋值 4.使用数组&lt;/p&gt;
&lt;p&gt;4.数组属于引用类型，数组型数据是对象（object）&lt;/p&gt;
&lt;p&gt;运用 java 数组存储二十六个字母&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			
		char table[] = new char[26];
		for(int i = 0; i &amp;lt; 26; i++) {
			table[i] = (char)(&apos;a&apos; + i);
		}	
		for(int i = 0; i &amp;lt; 26; i++) {
			System.out.println(table[i]);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在这里用到了java中数据类型转换的知识，&apos;a&apos; + i 是字符型加整形，会自动类型转化为int型，不能直接赋值给 char 型的变量，需要强制类型转换&lt;/p&gt;
&lt;p&gt;习题练习&lt;/p&gt;
&lt;p&gt;找到一个数组中最大的拿一个元素，并输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4} ;
		int max = 0;
		for(int i = 0; i &amp;lt; 5; i++) {
			max = max &amp;gt; table[i] ? max : table[i];
		}
		System.out.println(max);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组赋值机制&lt;/h2&gt;
&lt;p&gt;在基本数据类型赋值的时候，会赋给具体的数据，且互不影响&lt;/p&gt;
&lt;p&gt;而在数组再默认情况下赋值是引用的传递，赋给另一个数组的是数组各个元素所对应的地址&lt;/p&gt;
&lt;p&gt;代码举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int i = 1;
		int j = i;
		j = 3;

		System.out.println(i);//改变j的值不会影响到i的值
		
		int table_1[] = {2, 3, 5, 1, 4} ;
		int table_2[] = new int[5];
		table_2 = table_1;
		table_2[0] = 1;

		System.out.println(table_1[0]);//改变table2 会影响到table1指向的内存空间
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要一个全新的数据空间相互独立的数组，我们则需要一个数组拷贝&lt;/p&gt;
&lt;p&gt;可以通过for循环赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
		int table_1[] = {2, 3, 5, 1, 4} ;
		int table_3[] = new int[table_1.length];
		for(int i = 0; i &amp;lt; table_1.length; i++) {
			table_3[i] = table_1[i];
		}
		table_3[0] = 1;

		System.out.println(table_1[0]);//改变table3 不会影响到table1指向的内存空间
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组操作例题&lt;/h2&gt;
&lt;p&gt;1.将数组的内容反向保存&lt;/p&gt;
&lt;p&gt;方式1：通过遍历数组的一半利用下标对于数组的各个元素收尾互换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4, 6};
		int temp = 0;
		for(int i = 0; i &amp;lt; table.length / 2; i++) {
			temp = table[i];
			table[i] = table[table.length - i - 1];
			table[table.length - i - 1] = temp;
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式2：创建一个新的数组，遍历原数组将原数组中的元素反向存入新的数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
		int table[] = {2, 3, 5, 1, 4, 6};
		int temp = 0;
		int table_2[] = new int[6];
		for(int i = 0; i &amp;lt; table_2.length; i++) {
			table_2[i] = table[table_2.length - i - 1]; 
		}

		table = table_2; //在这里将table指向了新的数组，原来的空间因为没有变量引用被销毁
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数组的扩容与缩减&lt;/h2&gt;
&lt;p&gt;Java 中数组的长度是固定的，但是可以通过创建新数组的方式来将原数组的引用指向新数组的地址，以此来完成数组的扩容&lt;/p&gt;
&lt;p&gt;接下来用一段代码来完成数组的扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);

		int table[] = {2, 3, 5, 1, 4, 6};
		while(true) {
			char flag = &apos;n&apos;;
			System.out.println(&quot;请输入是否要添加一个元素，需要填 y &quot;);
			flag = myScanner.next().charAt(0);
			if(flag == &apos;y&apos;) {
				int num = myScanner.nextInt();
				int arr[] = new int[table.length + 1];
				for(int i = 0; i &amp;lt; table.length; i++) {
					arr[i] = table[i];
				}
				arr[table.length] = num;
				table = arr;
			} else {
				break;
			}
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理我们也可以用类似的方式完成数组长度的缩减&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);

		int table[] = {2, 3, 5, 1, 4, 6};
		while(true) {
			char flag = &apos;n&apos;;
			System.out.println(&quot;请输入是否要删除一个元素，需要填 y &quot;);
			flag = myScanner.next().charAt(0);
			if(flag == &apos;y&apos;) {
				if(table.length == 1) {
					System.out.println(&quot;只剩下一个元素，无法删除&quot;);
					break;
				}
				int arr[] = new int[table.length - 1];
				for(int i = 0; i &amp;lt; table.length - 1; i++) {
					arr[i] = table[i];
				}
				table = arr;
			} else {
				break;
			}
		}

		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.println(table[i]);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这样做太过于麻烦，可以使用后续的链表数据结构完成预期的功能&lt;/p&gt;
&lt;h2&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;经典的排序算法，在这里不过多介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{	
	public static void main(String[] args){
		
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数组的大小&quot;);
		int number = myScanner.nextInt();
		int table[] = new int[number];		
		System.out.println(&quot;请输入数组的各个元素&quot;);
		for(int i = 0; i &amp;lt; number; i++) {
			table[i] = myScanner.nextInt();
		}
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.print(table[i] + &quot; &quot;);
		}
		int temp = 0;
		for(int i = 0; i &amp;lt; table.length - 1; i++) {
			for(int j = 0; j &amp;lt; table.length - i - 1; j++) {
				if(table[j] &amp;gt; table[j + 1]) {
					temp = table[j];
					table[j] = table[j + 1];
					table[j + 1] = temp;
				}
			}
		}
		System.out.print(&apos;\n&apos;);
		for(int i = 0; i &amp;lt; table.length; i++) {
			System.out.print(table[i] + &quot; &quot;);
		}	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组中的查找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;
public class Test{	
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		String table[] = {&quot;朱雀&quot;, &quot;白虎&quot;, &quot;玄武&quot;, &quot;青龙&quot;};
		System.out.println(&quot;输入你想找到的元素&quot;);
		String target = myScanner.next();
		for(int i = 0; i &amp;lt; table.length; i++) {
			if(table[i].equals(target)) {
				System.out.println(&quot;找到了&quot; + target + &quot;位置在第&quot; + i + &quot;个元素上&quot;);
				return;
			}
		}
		System.out.println(&quot;没有找到目标的元素&quot; + target);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的二维数组&lt;/h2&gt;
&lt;p&gt;二维数组数数组的扩展，相比于数组，二维数组多了一个维度，可以模拟更加复杂的现实情况，在编程中有广泛的应用&lt;/p&gt;
&lt;p&gt;以下是一个二维数组静态初始化的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{	
	public static void main(String[] args){
		int arr[][] = { {1, 1, 5, 6, 6}, 
				  	   {3, 5, 5, 6, 6}, 
				  	   {3, 5, 5, 6, 2}, 
				  	   {3, 5, 5, 6, 1}};

		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在第二个循环条件中 判断的是 对应的一维数组的长度&lt;/p&gt;
&lt;p&gt;这里有一个比较有意思的点，这里涉及到了一个存储方式的问题，以前我在c语言中没有搞明白，为什么列优先的遍历二维数组的方式会比行优先的方式要慢很多&lt;/p&gt;
&lt;p&gt;在这一段代码中可以直观地看出二维数组的存储方式是通过先行再列的方式存储在内存之中，在内存中我们存储的方式是一维的，依次访问可以通过一次内存中的遍历得到想要的所有元素&lt;/p&gt;
&lt;p&gt;而列优先的话，会导致内存的访问不连续，增加了缓存未命中的概率（这里涉及到了计算机组成原理中的 cache，缓存会从内存中加载数据用以程序的计算，而使用cache的速度是要远远快于使用内存中的数据的，假设cache目前存储的是{1, 1, 5, 6, 6 }第一个一维数组的元素，运用行优先的方式，可以一次加载cache 中的内容，而列优先的话还需要从第二个一维数组中取元素，而第二个数组不再cache中，读内存需要大量的时间浪费），从而导致了速度缓慢&lt;/p&gt;
&lt;h2&gt;二维数组的内存布局&lt;/h2&gt;
&lt;p&gt;有点类似于操作系统中的三级虚拟内存，二维数组的引用指向于一个存放一维数组引用的数组，数组的各个元素指向对应的一维数组，一维数组中才会存放需要的具体数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/46.png&quot; alt=&quot;46&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;二维数组的使用&lt;/h2&gt;
&lt;p&gt;类型 [ ] [ ] = new 类型 [ size ] [ size ];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int arr[][] = new int[3][2]; //定义一个二维数组

int arr[][]; //也可以先定义引用，再创建二维数组的空间
arr =  new int[3][2];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java中支持二维数组中的每个一维数组元素数量不同（列数不确定）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class Test{
	
	public static void main(String[] args){
		int arr[][];		//声明一个二维数组的引用
		arr = new int[3][]; //先给二维数组的引用数组创建实例 没有创建存放数据包的一维数组

		for(int i = 0; i &amp;lt; arr.length; i++) {
			arr[i] = new int[i + 1];//在这里才对于一维数组中的引用，创建了每一个一维数组的空间
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				arr[i][j] = i + 1;
			}
		}
		
		for(int i = 0; i &amp;lt; arr.length; i++) {
			for(int j = 0; j &amp;lt; arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println(&quot;&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;课有点多，加上晚上要健身，今天先到这里了，明天开始会复习二维数组和相关例题，以及学习java中的类和对象&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid><description>循环练习，跳转控制语句</description><pubDate>Tue, 04 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;多重循环例题&lt;/h2&gt;
&lt;h3&gt;打印九九乘法表：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		for(int i = 1; i &amp;lt; 10; i++) {//九九乘法表有九行 从一开始
			for(int j = 1; j &amp;lt;= i; j++) {//九九乘法表在每一行上的乘法表达式不超过行列数
				System.out.print(i + &quot; * &quot; + j + &quot;=&quot; + i*j + &quot;\t&quot;);
			}
			System.out.print(&quot;\n&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;空心金字塔：&lt;/h3&gt;
&lt;p&gt;经典的嵌套循环练习题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		for(int i = 0; i &amp;lt; num; i++) {			//第一层循环 i代表每一层
			for(int j = 0; j &amp;lt; num - i; j++) {	
				System.out.print(&quot; &quot;);			//每一层都有空格开头 需要用输出填充
			}
			for(int j = 0; j &amp;lt;= 2 * i; j++) { 	//每一行需要输出 2 * 层数 + 1 个符号
				if(j == 0 || j == 2 * i || i == num -1) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}
				
			}
			System.out.print(&quot;\n&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编程这一道题目的时候，可以先打印出一个实心金字塔，再对代码进行修改处理&lt;/p&gt;
&lt;p&gt;题目拓展：打印一个空心的菱形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		int num = myScanner.nextInt();
		for(int i = 0; i &amp;lt; num; i++) {			//第一层循环 i代表每一层
			for(int j = 0; j &amp;lt; num - i - 1; j++) {	
				System.out.print(&quot; &quot;);			//每一层都有空格开头 需要用输出填充
			}
			for(int j = 0; j &amp;lt;= 2 * i; j++) { 	//每一行需要输出 2 * 层数 + 1 个符号
				if(j == 0 || j == 2 * i ) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}
				
			}
			System.out.print(&quot;\n&quot;);
		}
		for(int i = 1; i &amp;lt; num; i++) {
			for(int j = 1; j &amp;lt;= i; j++) {
				System.out.print(&apos; &apos;);
			}
			for(int j = 1; j &amp;lt;= num * 2  -2 * i - 1 ; j++) {
				if(j == 1 || j == num * 2  -2 * i - 1 ) {
					System.out.print(&apos;*&apos;);
				} else {
					System.out.print(&apos; &apos;);
				}					
			}
			System.out.print(&apos;\n&apos;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的跳转控制语句&lt;/h2&gt;
&lt;h3&gt;break&lt;/h3&gt;
&lt;p&gt;用于终止或跳出循环 以下是一个具体的代码案例 目的是记录生成的随机数50前一共生成的随机数次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.lang.Math;	//引入Math类	

public class Move{
	public static void main(String[] args) {
		int num = 0;
		while(true) {
			num++;
			if(((int)(Math.random() * 100) + 1) == 50) // 利用random() 生成1-100 的随机数
				break;			
		}	
		
		System.out.println(num);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中Math 类中的 random 方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/45.png&quot; alt=&quot;45&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;break语句的使用细节&lt;/h4&gt;
&lt;p&gt;break 出现在多层嵌套的语句块中 ，可以通过标签 lable 指明需要终止的是那一层语句块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		lable1:
		for(int i = 0; i &amp;lt; 3; i++) {
			System.out.println(&quot;i = &quot; + i);
			lable2:
			for(int j = 0; j &amp;lt; 2; j++) {
				System.out.println(&quot;j = &quot; + j);
				if(j == 1) break lable1;
			}
		}		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.break 语句可以指定退出那一层&lt;/p&gt;
&lt;p&gt;2.break 默认退出最近的一层&lt;/p&gt;
&lt;p&gt;3.在实际开发中尽量不使用break + lable的组合，会降低代码的可读性&lt;/p&gt;
&lt;p&gt;例题1：&lt;/p&gt;
&lt;p&gt;输出1+2+3+...+100中到哪一个数字的时候和大于 20&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Move{
	public static void main(String[] args) {
		int sum = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			sum += i;
			if(sum &amp;gt; 20) {
				System.out.println(&quot;最后的数字是：&quot; + i);
				break;
			}
		}		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例题2：登陆验证，限制登录次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		for(int i = 3; i &amp;gt;= 1; i--) {
			System.out.println(&quot;输入姓名&quot;);		
			String userName = myScanner.next();
			System.out.println(&quot;输入密码&quot;);		
			String password = myScanner.next();
			if(&quot;丁真&quot;.equals(userName) &amp;amp;&amp;amp; &quot;123456&quot;.equals(password)){
				System.out.println(&quot;登录成功&quot;);	
				break;
			}else {
				System.out.println(&quot;登陆失败 剩余&quot; + i + &quot;次机会&quot;);	
			}
		}
		System.out.println(&quot;登录结束&quot;);		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意！！再java中比较字符串的时候需要使用到 String 方法的 equals()，不可以使用 == 来进行比较&lt;/p&gt;
&lt;p&gt;在比较字符串的时候，建议将常量字符串先写在前面，这样做可以避免空指针的情况引起报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// if(userName.equals(&quot;丁真&quot;) &amp;amp;&amp;amp; password.equals(&quot;123456&quot;))
if(&quot;丁真&quot;.equals(userName) &amp;amp;&amp;amp; &quot;123456&quot;.equals(password))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Java 中的字符串比较&lt;/h3&gt;
&lt;p&gt;在 Java 中，字符串比较需要使用 &lt;code&gt;String&lt;/code&gt; 类的 &lt;code&gt;equals&lt;/code&gt; 方法，而不能直接使用 &lt;code&gt;==&lt;/code&gt; 运算符，原因是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt; 的作用完全不同&lt;/strong&gt;：&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;==&lt;/code&gt; 的作用&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 是 Java 中的&lt;strong&gt;比较运算符&lt;/strong&gt;，用于比较两个对象的**引用（内存地址）**是否相同。&lt;/li&gt;
&lt;li&gt;对于字符串（&lt;code&gt;String&lt;/code&gt; 类型），&lt;code&gt;==&lt;/code&gt; 比较的是两个字符串对象是否指向&lt;strong&gt;同一个内存地址&lt;/strong&gt;，而不是比较字符串的内容是否相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;hello&quot;);
String str2 = new String(&quot;hello&quot;);

System.out.println(str1 == str2); // false，因为 str1 和 str2 是不同的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中，&lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; 是两个不同的对象，尽管它们的内容都是 &lt;code&gt;&quot;hello&quot;&lt;/code&gt;，但它们的&lt;strong&gt;内存地址不同&lt;/strong&gt;，因此 &lt;code&gt;==&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4&gt;&lt;code&gt;equals&lt;/code&gt; 的作用&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; 类中&lt;strong&gt;重写&lt;/strong&gt;的方法，用于比较两个字符串的&lt;strong&gt;内容&lt;/strong&gt;是否相同。&lt;/li&gt;
&lt;li&gt;它会逐个字符比较两个字符串的值，而不是比较它们的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;String str1 = new String(&quot;hello&quot;);
String str2 = new String(&quot;hello&quot;);

System.out.println(str1.equals(str2)); // true，因为内容相同
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尽管 &lt;code&gt;str1&lt;/code&gt; 和 &lt;code&gt;str2&lt;/code&gt; 是不同的对象，但它们的内容相同，因此 &lt;code&gt;equals&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较方式&lt;/th&gt;
&lt;th&gt;作用范围&lt;/th&gt;
&lt;th&gt;比较内容&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象引用&lt;/td&gt;
&lt;td&gt;内存地址&lt;/td&gt;
&lt;td&gt;判断两个对象是否是同一个实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象内容&lt;/td&gt;
&lt;td&gt;字符串的实际值&lt;/td&gt;
&lt;td&gt;判断两个字符串的内容是否相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;引申的相关问题&lt;/h4&gt;
&lt;p&gt;1.为什么==在比较数值的时候可以使用，不是比较的是地址嘛？&lt;/p&gt;
&lt;p&gt;对于基本数据类型而言 == 比较的就是之的内容 ，而对于引用的内容而言比较的是是否是引用的同一个内容&lt;/p&gt;
&lt;p&gt;2.那如果我将基本数据类型创建实例，存储的内容不再栈上，还可以使用==进行比较吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;（如 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt; 等）是直接存储在栈内存中的，它们没有对象实例的概念。因此，你无法直接为基本数据类型创建实例。&lt;/p&gt;
&lt;p&gt;但是，Java 提供了&lt;strong&gt;包装类&lt;/strong&gt;（Wrapper Classes）来将基本数据类型封装为对象。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; 的包装类是 &lt;code&gt;Integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt; 的包装类是 &lt;code&gt;Double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt; 的包装类是 &lt;code&gt;Character&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你使用包装类时，存储的内容是在&lt;strong&gt;堆内存&lt;/strong&gt;中，而不是栈内存中。这时，&lt;code&gt;==&lt;/code&gt; 的行为会发生变化。&lt;/p&gt;
&lt;p&gt;Java 对包装类（如 &lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Character&lt;/code&gt; 等）做了一些优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于较小的值（例如 &lt;code&gt;Integer&lt;/code&gt; 在 -128 到 127 之间），Java 会使用&lt;strong&gt;常量池&lt;/strong&gt;来缓存对象。&lt;/li&gt;
&lt;li&gt;如果使用自动装箱（例如 &lt;code&gt;Integer a = 10;&lt;/code&gt;），Java 会优先从常量池中获取对象，而不是创建新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 10; // 自动装箱，从常量池中获取对象
Integer y = 10; // 自动装箱，从常量池中获取对象

System.out.println(x == y); // true，因为 x 和 y 指向常量池中的同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都指向常量池中的同一个对象，因此 &lt;code&gt;==&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但如果值超出了常量池的范围，&lt;code&gt;==&lt;/code&gt; 就会返回 &lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer m = 200; // 超出常量池范围，创建新对象
Integer n = 200; // 超出常量池范围，创建新对象

System.out.println(m == n); // false，因为 m 和 n 是不同的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;th&gt;&lt;code&gt;==&lt;/code&gt; 的行为&lt;/th&gt;
&lt;th&gt;推荐方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基本数据类型&lt;/td&gt;
&lt;td&gt;比较&lt;strong&gt;值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;直接使用 &lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包装类对象&lt;/td&gt;
&lt;td&gt;比较&lt;strong&gt;引用（内存地址）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包装类对象（常量池范围内）&lt;/td&gt;
&lt;td&gt;可能比较&lt;strong&gt;引用&lt;/strong&gt;（常量池优化）&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;equals&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;continue&lt;/h3&gt;
&lt;p&gt;和c语言中的类似，退出当前运行的代码块，执行循环中的下一次循环&lt;/p&gt;
&lt;p&gt;也可以使用标签做 break类似的相关操作，默认执行最近的循环与语句&lt;/p&gt;
&lt;h3&gt;return&lt;/h3&gt;
&lt;p&gt;用于跳出所在的方法，在main 函数中使用退出程序&lt;/p&gt;
&lt;h2&gt;控制语句练习题目&lt;/h2&gt;
&lt;p&gt;1.求最大可以通过路口的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		double money = 100000;
		int number = 0;
		while(true) {			
			if(money &amp;gt; 50000) {
				money *= 0.95;
			} else if(money &amp;lt;= 50000 &amp;amp;&amp;amp; money &amp;gt;= 1000) {
				money -= 1000;
			} else {
				break;
			}
			number++;
		}

		System.out.println(&quot;最多可以通过 &quot; + number + &quot; 次路口&quot;); 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.判断一个年份是否为闰年&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个年份&quot;);
		int year = myScanner.nextInt();

		if((year % 4 == 0 &amp;amp;&amp;amp; year % 100 != 0)||(year % 400 == 0)) {
			System.out.println(year + &quot;年份是一个闰年&quot;);
		} else {
			System.out.println(year + &quot;年份不是是一个闰年&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.判断一个水仙花数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个三位数的水仙花数&quot;);
		int number = myScanner.nextInt();
		int sum = 0;
		int num1 = number / 100;
		int num2 = number % 100 / 10;
		int num3 = number % 10; 

		sum = num1 * num1 * num1 + num2 * num2 * num2 + num3 * num3 * num3;
		if(number == sum) {
			System.out.println(number + &quot;是一个水仙花数&quot;);
		} else {
			System.out.println(number + &quot;不是一个水仙花数&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一份代码还可以进行一个代码优化，优化为支持判断所有位数的水仙花数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Move{
	public static void main(String[] args) {
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入一个数&quot;);
		int number = myScanner.nextInt();
		int sum = 0;
		int flag = number;

		while(flag != 0) {			//当没有位数的时候停止
			int num = flag % 10;	//分离出当前数字的个位
			sum += (num * num * num);
			flag /= 10;	     	    //去除当前数字的个位
		}

		if(number == sum) {
			System.out.println(number + &quot;是一个水仙花数&quot;);
		} else {
			System.out.println(number + &quot;不是一个水仙花数&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.输出1-100间不可以被 5 整除的数字，用5个一行来显示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{	
	public static void main(String[] args) {
		int count = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			if(i % 5 != 0){
				System.out.print(i + &quot; &quot;);
				count++;
				if(count % 5 == 0){
					System.out.print(&quot;\n&quot;);
				}
			}
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.运用 for 循环打印出字母表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		for(char i = &apos;a&apos;; i &amp;lt;= &apos;z&apos;; i++) {			
			System.out.println((i));			
		} 
		for(char i = &apos;Z&apos;; i &amp;gt;= &apos;A&apos;; i--) {			
			System.out.println((i));			
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里考察的是char 也可以做自增操作，char的本质是 Unicode编码(UTF-8)&lt;/p&gt;
&lt;p&gt;6.1 - 1/2 + 1/3 - 1/4 +1/5 - ...... - 1/100&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		double sum = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			double temp = 0;
			if(i % 2 == 0) {
				temp = -1.0 / i;
			} else {
				temp = 1.0 / i;
			}
			sum += temp;
		}
		System.out.println(&quot;运算结果是&quot; + sum);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7.1 + (1+2) + (1+2+3) + ...... + （1+ ... +100）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		int sum = 0, temp = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			temp = 0;
			for(int j = 1; j &amp;lt;= i; j++) {
				temp += j; 
			}
			sum += temp;
		}
		System.out.println(sum);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的代码可以正确完成功能，但是我发现了相加的每一项其实都是在前一项的基础上加上了它所对应的项数，通过一个temp变量保存前一个项的值即可让算法的复杂度降低，通过一个循环即可计算出结果，以下是代码的改进部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	public static void main(String[] args) {
		int sum = 0, temp = 0;
		for(int i = 1; i &amp;lt;= 100; i++) {
			temp += i;
			sum +=temp;
		}
		System.out.println(sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E8%BF%9B%E5%88%B6%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E8%BF%9B%E5%88%B6%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid><description>进制，位运算，流程控制</description><pubDate>Mon, 03 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的进制&lt;/h2&gt;
&lt;p&gt;二进制  	0b 开头		 如 0b101， 0B1111&lt;/p&gt;
&lt;p&gt;十进制  						 如 10， 100&lt;/p&gt;
&lt;p&gt;八进制  	0 开头表示	如 077，0734&lt;/p&gt;
&lt;p&gt;十六进制  0x开头表示	如 0xFFFF， 0Xab03， 0xaaaa， 0XEEFE&lt;/p&gt;
&lt;h2&gt;Java中的位运算&lt;/h2&gt;
&lt;p&gt;~2 按位取反&lt;/p&gt;
&lt;p&gt;2&amp;amp;3 按位与&lt;/p&gt;
&lt;p&gt;2|3  按位或&lt;/p&gt;
&lt;p&gt;3^6 按位异或&lt;/p&gt;
&lt;h2&gt;Java 中的位运算符&lt;/h2&gt;
&lt;p&gt;算术左移，&amp;lt;&amp;lt;，符号位不变低位补 0&lt;/p&gt;
&lt;p&gt;算数右移，&amp;gt;&amp;gt;，符号位不变用符号位补高位&lt;/p&gt;
&lt;p&gt;逻辑右移，&amp;gt;&amp;gt;&amp;gt;，低位溢出，高位补 0&lt;/p&gt;
&lt;h2&gt;Java中的分支控制&lt;/h2&gt;
&lt;h3&gt;if &amp;amp;&amp;amp; else&lt;/h3&gt;
&lt;p&gt;随便写了一个，较为简陋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();

		if(grade &amp;gt; 90) {
			System.out.println(&quot;A&quot;);
		} else if(grade &amp;gt; 60 &amp;amp;&amp;amp; grade &amp;lt;= 90) {
			System.out.println(&quot;B&quot;);
		} else {
			System.out.println(&quot;C&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分支的嵌套注意点：在使用分支嵌套的情况下不要超过三层的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嵌套分支举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();

		System.out.println(&quot;请输入性别：&quot;);
		int sex = myscanner.next().charAt(0);	
         /*
         注意在java中似乎没有nextChar()的用法 需要使用next接收一个字符串
         再将字符串中运用charAt(0)提取出第一个字符
		*/
		if(grade &amp;gt; 60) {
			System.out.println(&quot;恭喜过关&quot;);
			if(sex == &apos;男&apos;) {
				System.out.println(&quot;进入男子组决赛&quot;);
			} else {
				System.out.println(&quot;进入女子组决赛&quot;);
			}
		} else {
			System.out.println(&quot;淘汰&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;switch&lt;/h3&gt;
&lt;p&gt;与C语言同理在这里不多做说明以下是一个代码示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入成绩：&quot;);
		int grade = myscanner.nextInt();
		switch(grade){
			case 1:
				System.out.println(&quot;A&quot;);
			break;		
             //break 退出 如果不假如break会依次执行后续的分支，在这里删除break则会输出A B
			case 2:
				System.out.println(&quot;B&quot;);
			break;		
			default:	//默认的分支
				System.out.println(&quot;C&quot;);
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;switch 中值得注意的细节&lt;/p&gt;
&lt;p&gt;1.表达式的类型应该和 case 后的常量一致，或者可以发生自动转换，例如输入的是字符，而case 后常量为 int&lt;/p&gt;
&lt;p&gt;2.case 语句后的值一定是常量，不能是变量&lt;/p&gt;
&lt;p&gt;利用 击穿 的特性我们也可以简化一些代码，如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Test{
	
	public static void main(String[] args) {
		Scanner myscanner = new Scanner(System.in);
		System.out.println(&quot;请输入月份：&quot;);
		int grade = myscanner.nextInt();
		switch(grade){
             //当满足以下三条任意的条件中的一条执行break前的指令
			case 3:
			case 4:
			case 5:
				System.out.println(&quot;春季&quot;);
			break;
			case 6:
			case 7:
			case 8:
				System.out.println(&quot;夏季&quot;);
			break;
			case 9:
			case 10:
			case 11:
				System.out.println(&quot;秋季&quot;);
			break;
			default:
				System.out.println(&quot;冬季&quot;);
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;在编程时候if 和 switch 的取舍&lt;/h3&gt;
&lt;p&gt;1.如果判断类型数值不多的情况下，并且符合byte short int char enum String 六种类型时优先使用switch&lt;/p&gt;
&lt;p&gt;2.区间判断，boolean 类型判断时 if 使用更加广泛&lt;/p&gt;
&lt;h2&gt;Java中的循环控制&lt;/h2&gt;
&lt;h3&gt;for 循环控制&lt;/h3&gt;
&lt;p&gt;与c语言基本一模一样，在这里不多介绍，以下是代码样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入名字：&quot;);
		String name = myScanner.next();
		
		for(int i = 0; i &amp;lt; 10; i++){
			System.out.println(name);
		}
		
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;while 循环控制&lt;/h3&gt;
&lt;p&gt;在这里因为java中循环条件需要boolean类型的表达式，而在java中不能自动完成 int 到 boolean类型的转换&lt;/p&gt;
&lt;p&gt;c程序编写中常见的 flag-- 计数不再适用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数字：&quot;);
		int flag = myScanner.nextInt();
		
		while(flag &amp;gt; 0) {
			System.out.println(flag);
			flag--;
		}
        /*
        while(flag--) {
			System.out.println(flag);
		}
        */
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然可以写成一下这种写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		System.out.println(&quot;请输入数字：&quot;);
		int flag = myScanner.nextInt();
		
		while((flag--) != 0) {
			System.out.println(10);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;do while 循环语句&lt;/h3&gt;
&lt;p&gt;一定会执行一次，在执行完后再次判断是否执行语句块，如下是一个暴力的催债程序:joy:&lt;/p&gt;
&lt;p&gt;先打一拳！打的时候再把问题问遍！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner;

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);
		boolean flag = false;
		int i = 1;
		System.out.println(&quot;还不还钱？&quot;);
		do {
			System.out.println(&quot;打第&quot; + i + &quot;拳&quot;);
			i++;
			flag = myScanner.nextBoolean();
		}while(!flag); 
		System.out.println(&quot;还钱了，结束打人&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的多重循环&lt;/h2&gt;
&lt;p&gt;学习到了第三天终于来到了算法难点部分，在这里也希望自己可以通过课程学习来巩固自己算法的基础。&lt;/p&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B/</guid><description>变量，数据类型，类型转换，编码类型</description><pubDate>Sun, 02 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;h2&gt;Java中的变量&lt;/h2&gt;
&lt;p&gt;在这一个部分因为本人有C语言的相关基础，只记录Java 中与C 不同的部分，以及重点部分&lt;/p&gt;
&lt;p&gt;Java中的“+”的使用方式，1.当左右两边都是数值的时候，做加法运算，当有一方是字符串时，做拼接运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		System.out.println(100 + 11);			//111
		System.out.println(1 + &quot;100&quot;);			//1100
		System.out.println(100 + 11 + &quot;100&quot;);	//111100
		System.out.println(&quot;100&quot; + 100 + 11);	//10010011
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的数据类型&lt;/h2&gt;
&lt;p&gt;分为基本数值类型和引用数据类型&lt;/p&gt;
&lt;h3&gt;基本数值类型&lt;/h3&gt;
&lt;p&gt;数值型 byte short int long float double&lt;/p&gt;
&lt;p&gt;字符型 char 占两个字节（因为有中文等的存在需要更多的空间存储）&lt;/p&gt;
&lt;p&gt;布尔型 boolean&lt;/p&gt;
&lt;h3&gt;引用数据类型&lt;/h3&gt;
&lt;p&gt;类   class&lt;/p&gt;
&lt;p&gt;接口 interface&lt;/p&gt;
&lt;p&gt;数组 [ ]&lt;/p&gt;
&lt;h2&gt;整数类型&lt;/h2&gt;
&lt;p&gt;在java上整数类型有着固定的范围和字段长度，不受具体的操作系统的影响，保证了可移植性。&lt;/p&gt;
&lt;p&gt;java中整形常量默认为int 型，声明long型需要在数据后加上 L 或者 l （以下为一个具体的例子）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long b = 127;
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;127&lt;/code&gt;是一个&lt;code&gt;int&lt;/code&gt;类型的常量，但由于&lt;code&gt;long&lt;/code&gt;类型的范围比&lt;code&gt;int&lt;/code&gt;类型大，Java会自动将&lt;code&gt;127&lt;/code&gt;转换为&lt;code&gt;long&lt;/code&gt;类型，然后赋值给变量&lt;code&gt;b&lt;/code&gt;。因此，这段代码可以通过编译并正常运行。&lt;/p&gt;
&lt;p&gt;如果你要将一个超出&lt;code&gt;int&lt;/code&gt;范围的常量赋值给&lt;code&gt;long&lt;/code&gt;类型的变量，那么你必须在常量后面加上&lt;code&gt;L&lt;/code&gt;或&lt;code&gt;l&lt;/code&gt;来明确指定这是一个&lt;code&gt;long&lt;/code&gt;类型的常量。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long b = 2147483648L;  // 这个值超出了int的范围，必须加上L
System.out.println(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这种情况下，如果不加&lt;code&gt;L&lt;/code&gt;，编译器会报错，因为&lt;code&gt;2147483648&lt;/code&gt;超出了&lt;code&gt;int&lt;/code&gt;类型的范围（&lt;code&gt;int&lt;/code&gt;的范围是&lt;code&gt;-2147483648&lt;/code&gt;到&lt;code&gt;2147483647&lt;/code&gt;），而Java不会自动将超出&lt;code&gt;int&lt;/code&gt;范围的常量转换为&lt;code&gt;long&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/40.png&quot; alt=&quot;40&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;浮点类型&lt;/h2&gt;
&lt;p&gt;与整型相同，java中浮点类型有着固定的范围和字段长度，不受操作系统的影响。&lt;/p&gt;
&lt;p&gt;java中浮点类型常量默认为double 型，声明float型需要在数据后加上 f 或者 F&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		float num1 = 1.1;//错误 浮点数默认存储是double类型
         double num2 = 1.1;//可以，没有类型的转换
		System.out.println(b);	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/41.png&quot; alt=&quot;41&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;特殊的数值表示&lt;/h2&gt;
&lt;p&gt;.123 表示 0.123&lt;/p&gt;
&lt;p&gt;科学计数法 e大小写都可以&lt;/p&gt;
&lt;p&gt;3.14e2 表示 314.0&lt;/p&gt;
&lt;p&gt;3.14E-1 表示 0.314&lt;/p&gt;
&lt;p&gt;在使用浮点类型推荐使用double类型&lt;/p&gt;
&lt;p&gt;在判断两个浮点数是否相等时往往取二者的差值是否小于一定的范围，而非直接 == 判断&lt;/p&gt;
&lt;h2&gt;字符类型&lt;/h2&gt;
&lt;p&gt;char型，两个字节，可以存放汉字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		char num1 = &apos;李&apos;; 		//汉字
		char num2 = &apos;\n&apos;; 		//转义字符
		char num3 = &apos;a&apos;;  		//字母
		char num4 = 20013;  	//中的Unicode编码为20013
		System.out.println(num1);
		System.out.println(num2);
		System.out.println(num3);
		System.out.println(num4);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符类型的单个字符运用的 Unicode 进行编码，char 类型也可以参与运算，取其 Unicode编码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(&apos;a&apos; + 1);	//结果为98 a 的ASCII编码为 97
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ASCII&lt;/h3&gt;
&lt;p&gt;American Standard Code for Information Interchange，美国信息交换标准代码&lt;/p&gt;
&lt;p&gt;是最早的字符编码标准之一。它使用 7 位二进制数（即 1 个字节中的低 7 位）来表示字符，总共可以表示 128 个字符，注意在这里只用了 128 个字符，实际加上 8 位可以表示 256 个字符&lt;/p&gt;
&lt;p&gt;Unicode 是一个国际化的字符编码标准，旨在为世界上所有的字符提供一个唯一的编号（称为 &lt;strong&gt;码点&lt;/strong&gt;，Code Point）。&lt;/p&gt;
&lt;h3&gt;Unicode&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;16 位或更多位&lt;/strong&gt; 来表示字符，理论上可以表示超过 100 万个字符。&lt;/p&gt;
&lt;p&gt;Unicode 完全兼容 ASCII，即 ASCII 字符的 Unicode 码点与 ASCII 码相同。&lt;/p&gt;
&lt;p&gt;还有一些其他常用的编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/43.png&quot; alt=&quot;43&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;UTF-8&lt;/h4&gt;
&lt;p&gt;是在互联网中使用最广的一种Unicode实现方式，也是对Unicode编码的一种改进&lt;/p&gt;
&lt;p&gt;它是一种变长的编码方式，支持使用 1 到 6 个字节表示一个符号，根据不同的符号来变化字节长度&lt;/p&gt;
&lt;h2&gt;布尔类型&lt;/h2&gt;
&lt;p&gt;boolean 类型 只允许取置 true 与 false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
		
		boolean isPass = true;
		if(isPass == true) {
			System.out.println(&quot;pass&quot;);
		} else {
			System.out.println(&quot;No pass&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 java 中不允许用 0 和 非 0 来代替 true 与 false&lt;/p&gt;
&lt;h2&gt;基本数据类型转换&lt;/h2&gt;
&lt;p&gt;从左到右可以自动类型转换&lt;/p&gt;
&lt;p&gt;char  int  long  float  double&lt;/p&gt;
&lt;p&gt;byte  short  int  long  float  double&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
	
			int a = &apos;a&apos;;	//char 转 int
			char b = a;		//int 转 char 不可实现
			double c = 12;	//int 转 double
			float d = 10; 	//int 转 float 
			float e = 10.0; //double 转 float 不可实现
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据类型转换重点&lt;/h3&gt;
&lt;p&gt;1.有多种类型的混合运算时，将所有的类型转化为数据类型精度最大的后在进行运算&lt;/p&gt;
&lt;p&gt;2.byte short 与 char 类型间不可以发生自动的精度转换&lt;/p&gt;
&lt;p&gt;3.boolean 类型不参与类型自动转换&lt;/p&gt;
&lt;p&gt;4.byte short char 三者可以计算，先将三者转化为 int 类型 再参与运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
	
			char a = &apos;a&apos;;
			short b = 2;
			byte c = 1;
			int c = a + b + c; //三者参与运算时转为 int 类型
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Test{
	
	public static void main(String[] args){
			byte a = 1;
			byte b = 1;
			byte c = a + b; //三者参与运算时转为 int 不可转为byte 编译错误
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.自动提升原则：表达式结果的类型自动提升为操作数中最大的类型&lt;/p&gt;
&lt;h2&gt;强制类型转换&lt;/h2&gt;
&lt;p&gt;自动类型转换的逆过程，将精度大的转为小的，使用强制类型转换符（） ，会造成精度的降低或溢出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			int num1 = (int)1.9;
			System.out.println(num1);	//发生截断 结果为 1
			int num2 = 2000;
			byte flag = (byte)num2;
			System.out.println(flag);	//发生溢出 结果为 -48
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本数据类型和 String 类型的转换&lt;/h2&gt;
&lt;p&gt;将基本数据类型转化为 String 类型&lt;/p&gt;
&lt;p&gt;加上 &quot; &quot; 即可实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			int num1 = 100;
			float num2 = 2.1f;
			double num3 = 3.1;
			boolean num4 = true;
			String s1 = num1 + &quot;&quot;;
			String s2 = num2 + &quot;&quot;;
			String s3 = num3 + &quot;&quot;;
			String s4 = num4 + &quot;&quot;;
        	System.out.println(s1 + s2 + s3 + s4);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将String 类型转化为 基本数据类型&lt;/p&gt;
&lt;p&gt;通过 parse 方法实现转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			
			String s1 = &quot;100&quot;;
			String s2 = &quot;23.2&quot;;
			String s3 = &quot;23.1&quot;;
			String s4 = &quot;true&quot;;
			
			int n1 = Integer.parseInt(s1);
			double n2 = Double.parseDouble(s2);
			float n3 = Float.parseFloat(s3);
			boolean n4 = Boolean.parseBoolean(s4);
			char n5 = s4.charAt(0);	//得到字符串的第一个字符
			
			System.out.println(n1);
			System.out.println(n2);
			System.out.println(n3);
			System.out.println(n4);
			System.out.println(n5);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把字符串转为字符指的是将字符串中第一个字符取出转化为 char 类型&lt;/p&gt;
&lt;p&gt;假设将 hello 字符串转化为 int 类型则会发生解析错误，在这里编译的时候不会发生错误，但是运行的时候会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	public static void main(String[] args) {	
			String s1 = &quot;true&quot;;
			int n1 = Integer.parseInt(s1);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/44.png&quot; alt=&quot;44&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Java API 文档&lt;/h2&gt;
&lt;p&gt;Application Programming Interface&lt;/p&gt;
&lt;p&gt;提供了大量的基础类，官方给了相应的API文档，用于告诉开发者如何使用相关类以及方法&lt;/p&gt;
&lt;p&gt;在这里提供一个java8 中文文档&lt;/p&gt;
&lt;p&gt;https://www.matools.com/api/java8&lt;/p&gt;
&lt;h2&gt;Java类 的组织形式&lt;/h2&gt;
&lt;p&gt;java 中类以包的形式包装，JDK 中有很多的包，包下面有很多的接口，类，异常&lt;/p&gt;
&lt;p&gt;类下面有字段，（构造器）构造方法，（成员方法）方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/42.png&quot; alt=&quot;42&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过文档可以方便的查找需要的 API&lt;/p&gt;
&lt;h2&gt;Java 中的算数运算符&lt;/h2&gt;
&lt;p&gt;/ 号在处理 int 数据时会发生截断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			double n1 = 10 / 4;    
			System.out.println(n1);//结果是2.0 将int 2 转为 2.0
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取模公式 a % b = a - a / b * b&lt;/p&gt;
&lt;p&gt;java中面试题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
i = i++; // 1.temp = i;  2. i = i + 1;  3.i = temp;
System.out.println(i) //i = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
i = ++i; // 1.i = i + 1;  2. temp = i;  3.i = temp;
System.out.println(i) //i = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java中的逻辑运算符&lt;/h2&gt;
&lt;p&gt;&amp;amp;&amp;amp; 短路与 &amp;amp; 与&lt;/p&gt;
&lt;p&gt;|| 短路或 | 或&lt;/p&gt;
&lt;p&gt;! 取反&lt;/p&gt;
&lt;p&gt;a ^ b 逻辑异或 a与b不同时为 true ，相同时为 true&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;p&gt;注意在使用赋值运算符计算byte char short 类型的时候会发生类型的转换，计算得到的 int 类型 会转化为 byte类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Test{
	
	public static void main(String[] args){
			byte b = 3;
			b += 2;	//等价于 b = (byte)(b + 2);
			b++;	//等价于 b = (byte)(b + 1);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运算符优先级大致分类&lt;/h2&gt;
&lt;p&gt;1.（）{}&lt;/p&gt;
&lt;p&gt;2.单目运算符++ --&lt;/p&gt;
&lt;p&gt;3.算术运算符 + - % /&lt;/p&gt;
&lt;p&gt;4.位移运算符 &amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;5.比较运算符 &amp;gt; ==&lt;/p&gt;
&lt;p&gt;6.逻辑运算符 || &amp;amp;&amp;amp; ^&lt;/p&gt;
&lt;p&gt;7.三元运算符 ？ ：&lt;/p&gt;
&lt;p&gt;8.赋值运算符 =&lt;/p&gt;
&lt;h2&gt;Java中的标识符&lt;/h2&gt;
&lt;h3&gt;标识符的命名规则&lt;/h3&gt;
&lt;p&gt;1.由26个英文字母大小写，0—9，_ ，$ 组成&lt;/p&gt;
&lt;p&gt;2.不可以以数字开头如 int 2ab = 1;&lt;/p&gt;
&lt;p&gt;3.不可以使用关键字或者保留字，但是可以包含关键字和保留字&lt;/p&gt;
&lt;p&gt;4.java 中严格区分大小写，在长度上无限制&lt;/p&gt;
&lt;p&gt;5.标识符不含空格 如 int a b = 1;&lt;/p&gt;
&lt;h3&gt;标识符的命名规范&lt;/h3&gt;
&lt;p&gt;可以使得代码的编写更加专业&lt;/p&gt;
&lt;p&gt;1.包名：多单词组成时，所有字母小写&lt;/p&gt;
&lt;p&gt;2.类名与接口名：多单词组成时，所有首字母大写，如 StudentClass（大驼峰法）&lt;/p&gt;
&lt;p&gt;3.变量名与方法名：多单词组成时，第一个单词首字母小写，其余的单词首字母大写，如 studentName（小驼峰法）&lt;/p&gt;
&lt;p&gt;4.常量命名：所有字母大写，再多单词组成时之间用 _ 链接，STUDENT_NAME_CLASS&lt;/p&gt;
&lt;h2&gt;Java中的键盘输入&lt;/h2&gt;
&lt;p&gt;再 java 编程中需要接收用户输入数据时需要键盘输入语句类获取内容时&lt;/p&gt;
&lt;p&gt;我们需要使用到 java.util.*包中的扫描器 Scanner&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.导入类所在包&lt;/p&gt;
&lt;p&gt;2.创建类的对象&lt;/p&gt;
&lt;p&gt;3.调用类方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Scanner; 							//1.导入类所在包

public class Input{
	public static void main(String[] args){
		Scanner myScanner = new Scanner(System.in);	 //2.创建类的对象
		System.out.println(&quot;请输入名字：&quot;);
		String name = myScanner.next();				//3.调用类方法
		System.out.println(&quot;请输入年龄：&quot;);
		int ages = myScanner.nextInt();				//3.调用类方法
		System.out.println(&quot;请输入成绩：&quot;);
		double grades = myScanner.nextDouble();		 //3.调用类方法
		System.out.println(&quot;信息如下：&quot; + name + ages + grades);
	}
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java笔记</title><link>https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9%E6%B3%A8%E9%87%8A%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/java%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9%E6%B3%A8%E9%87%8A%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid><description>重要特点，注释，编程规范</description><pubDate>Sat, 01 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;听课笔记&lt;/h1&gt;
&lt;p&gt;目前在听韩顺平老师的java课程，准备以此来巩固自己的java基础，以下是一些我听课程时候所记录的笔记&lt;/p&gt;
&lt;h2&gt;Java技术体系平台&lt;/h2&gt;
&lt;p&gt;1.java SE标准版&lt;/p&gt;
&lt;p&gt;2.java EE企业版&lt;/p&gt;
&lt;p&gt;3.java ME小型版&lt;/p&gt;
&lt;h2&gt;Java的重要特点&lt;/h2&gt;
&lt;p&gt;1.面向对象&lt;/p&gt;
&lt;p&gt;2.java的健壮性，java强类型机制，异常处理，垃圾自动收集保证了java的健壮性&lt;/p&gt;
&lt;p&gt;3.java的跨平台性质的&lt;/p&gt;
&lt;p&gt;可以通过.java文件生成.class文件&lt;/p&gt;
&lt;p&gt;class可以在Windows又可以在Linux上运行，并不需要再重新编译.java文件(利用了JVM虚拟机可以在三大操作系统上执行）&lt;/p&gt;
&lt;p&gt;4.java语言是解释性语言，解释性语言在编译之后需要解释器来进行执行，编译性语言（二进制）可以被机器直接执行。&lt;/p&gt;
&lt;p&gt;Win+s可以直接打开windows的搜索栏，ctrl + l 可以快速清除命令行中的内容,再命令行中用Tab键补全&lt;/p&gt;
&lt;h2&gt;java虚拟机 JVM包含于jdk&lt;/h2&gt;
&lt;p&gt;全称java virtual machine&lt;/p&gt;
&lt;p&gt;是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责的执行指令管理数据内存寄存器都包含在jdk中&lt;/p&gt;
&lt;p&gt;Test.java -编译javac（需要用到java开发工具）-&amp;gt; Test.class -运行java（只需要JRE运行环境）-&amp;gt; JVM of op_system&lt;/p&gt;
&lt;h2&gt;JDK java开发工具包 Java Development Kit&lt;/h2&gt;
&lt;p&gt;JDK = JRE + java开发工具&lt;/p&gt;
&lt;h2&gt;JRE (运行.class必要的环境)&lt;/h2&gt;
&lt;p&gt;java运行环境 Java Runtime Environment&lt;/p&gt;
&lt;p&gt;JRE = JVM + Java核心类库 Java SE标准类库&lt;/p&gt;
&lt;h2&gt;运行第一个Java程序&lt;/h2&gt;
&lt;p&gt;注意中文编码问题需要使用 javac -encoding UTF-8 Test.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//表示Hello类的开始与结束
public class Test{
	
	//编写一个主方法，即程序的入口
	public static void main(String[] args){
		System.out.println(&quot;Hello world!!&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.java文件   源文件&lt;/p&gt;
&lt;p&gt;.class文件 字节码文件&lt;/p&gt;
&lt;p&gt;执行的本质是将.class文件装载到jvm机器执行，所以修改后的源文件需要通过重新编译生成新的.class文件才可以输出正确的预期结果&lt;/p&gt;
&lt;h2&gt;java开发注意事项以及细节说明&lt;/h2&gt;
&lt;p&gt;1.java应用程序执行入口是main（）方法，有着固定的书写格式：public static void main(String[] args)&lt;/p&gt;
&lt;p&gt;2.一个源文件中最多只有一个public类， 其他的类个数不做限制&lt;/p&gt;
&lt;p&gt;3.如果源文件中包含一个public类，则文件名必须按照该类名进行命名&lt;/p&gt;
&lt;p&gt;4.习惯上因为{}成对出现，所以先写括号再填内容&lt;/p&gt;
&lt;p&gt;5.如果源文件中包含一个public类，则文件名必须按照该类名进行命名，也可以将main方法写在非public，这样入口java执行非public的main方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//java的快速入门，演示开发过程
//表示Hello类的开始与结束
public class Test{
	
	//编写一个主方法，即程序的入口
	public static void main(String[] args){
		System.out.println(&quot;Thrinisty正在学习！！\n&quot;);
	}
}

class Cat{
	public static void main(String[] args){
		System.out.println(&quot;修狗！！\n&quot;);
	}
}

class Dog{public static void main(String[] args){
		System.out.println(&quot;猫猫！！\n&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在技术学习方法方面，老师有一点说的很好，在之后工作之中学习新技术的时候，先掌握基本原理与基本语法，之后再补充细节上的部分。&lt;/p&gt;
&lt;h2&gt;Java转义字符&lt;/h2&gt;
&lt;p&gt;\t  可以实现对齐功能(字表位)&lt;/p&gt;
&lt;p&gt;\n 可以实现换行功能&lt;/p&gt;
&lt;p&gt;要想输出 \  字符需要使用 \ \ 进行转义&lt;/p&gt;
&lt;p&gt;\r 可以实现回车功能(将光标定在当前行的第一个字符，之后输入的字符将替换后续的内容)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class ChangeChar{

	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
		
		System.out.println(&quot;C:\\Users\\71460\\Desktop\\Java\\class2&quot;);
		
		System.out.println(&quot;书名 \&quot;北京\&quot;&quot;);
		
		System.out.println(&quot;书名是\r北京&quot;);
        //输出的结果为 北京是
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Java注释&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//单行注释

//多行注释
/*	测试文字
	测试文字
	测试文字
	测试文字
*/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意！！Java不支持嵌套多行注释！！&lt;/p&gt;
&lt;h2&gt;注释文档&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 *@author thrinisty
 *@version 1.0
 */

public class Test{

	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
		
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;javadoc -d D:\temp -author -version Test.java 指令生成了对应的文档&lt;/p&gt;
&lt;p&gt;java文档标签示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/38.png&quot; alt=&quot;38&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/39.png&quot; alt=&quot;39&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Java中的代码规范&lt;/h2&gt;
&lt;p&gt;1.类，方法的注释，要以javadoc的方式来写&lt;/p&gt;
&lt;p&gt;2.非java doc的注释用单行注释来进行描述&lt;/p&gt;
&lt;p&gt;3.注意运用Tab来进行代码对齐，提高代码的美观性（运用tab向右移动，shift + tab 向左移动）&lt;/p&gt;
&lt;p&gt;4.运算符与数具之间留有空格 a = b + c 来替代a=b+c&lt;/p&gt;
&lt;p&gt;5.源文件使用UTF-8来进行存储&lt;/p&gt;
&lt;p&gt;6.行宽不大于80个字符&lt;/p&gt;
&lt;p&gt;7.代码编写次行风格与行尾风格（都可以使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 *行尾风格
 */
 
 public class Test{
	public static void main(String[] args){
		System.out.println(&quot;北京\t上海\t天津\n&quot;);		
	}
}


/**
 *次行风格
 */
 public class Test
 {
	public static void main(String[] args)
	{
		System.out.println(&quot;北京\t上海\t天津\n&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Dos指令相关内容&lt;/h2&gt;
&lt;p&gt;dir 查看当前目录下有些什么内容。也可以用ls 来进行查看&lt;/p&gt;
&lt;p&gt;cd 改变文件目录，与linux 相关操作同理，在这里不多做叙述，可查看linux相关指令那一篇文&lt;/p&gt;
&lt;p&gt;cls 清除所有显示的内容&lt;/p&gt;
&lt;p&gt;md 创建文件夹 rd删除文件&lt;/p&gt;
&lt;p&gt;copy 拷贝文件 del 删除文件&lt;/p&gt;
&lt;p&gt;echo 输入内容到文件&lt;/p&gt;
&lt;p&gt;move 移动文件&lt;/p&gt;
&lt;p&gt;exit 退出命令行&lt;/p&gt;
</content:encoded></item><item><title>Linux</title><link>https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/linux%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>linux常见指令，这个部分较为简易，后续或许回补充</description><pubDate>Wed, 19 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;linux中的一些常用指令&lt;/h3&gt;
&lt;h4&gt;cd（change directory）更改目录&lt;/h4&gt;
&lt;p&gt;其中 / 是linux中的根目录， . 代表的是当前的目录， .. 表示上一层目录
大部分的情况下 ./ 可以省略 直接cd + 目录下的文件路径&lt;/p&gt;
&lt;p&gt;cd ||  cd ~进入家目录&lt;/p&gt;
&lt;p&gt;cd - 进入上一次的目录&lt;/p&gt;
&lt;h4&gt;ls（list）显示当前目录的文件&lt;/h4&gt;
&lt;p&gt;-l参数会显示各个类型属性&lt;/p&gt;
&lt;p&gt;-a还会显示额外的文件&lt;/p&gt;
&lt;p&gt;-al综合前两个&lt;/p&gt;
&lt;h4&gt;cp（copy）拷贝文件&lt;/h4&gt;
&lt;p&gt;cp + 拷贝源路径 + 目标路径&lt;/p&gt;
&lt;p&gt;-r 参数 递归地拷贝&lt;/p&gt;
&lt;h4&gt;mv（move to）剪切&lt;/h4&gt;
&lt;p&gt;用法与复制类似&lt;/p&gt;
&lt;p&gt;特殊用法（更改名字）&lt;/p&gt;
&lt;p&gt;mv + 目标原来的文件名 + 现在的文件名&lt;/p&gt;
&lt;h4&gt;chmod （change mode）修改文件权限&lt;/h4&gt;
&lt;p&gt;可以通过chmod 744 文件名 修改&lt;/p&gt;
&lt;p&gt;chmod u+x 文件&lt;/p&gt;
&lt;p&gt;chmod g-r  文件&lt;/p&gt;
&lt;p&gt;chmod o+r 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/34.png&quot; alt=&quot;34&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;rm（remove）删除文件&lt;/h4&gt;
&lt;p&gt;-rf 强制删除参数&lt;/p&gt;
&lt;h4&gt;touch 创建文件&lt;/h4&gt;
&lt;p&gt;touch a b c&lt;/p&gt;
&lt;h4&gt;mkdir 创建文件夹&lt;/h4&gt;
&lt;h4&gt;tar 压缩&lt;/h4&gt;
&lt;p&gt;tar -zcf 压缩名字 需要压缩的文件文件&lt;/p&gt;
&lt;p&gt;tar -xzf 解压文件&lt;/p&gt;
&lt;p&gt;tar -zcf x.tar.gz a b c&lt;/p&gt;
&lt;h4&gt;find 查找文件&lt;/h4&gt;
&lt;p&gt;find 路径 -name &quot;文件名&quot;&lt;/p&gt;
&lt;h4&gt;grep 查找关键字&lt;/h4&gt;
&lt;p&gt;grep &quot;搜索关键字&quot; 路径 -r (递归)&lt;/p&gt;
</content:encoded></item><item><title>Vim</title><link>https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vim%E5%85%A5%E9%97%A8/</guid><description>Vim入门</description><pubDate>Tue, 18 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;VIM&lt;/h2&gt;
&lt;p&gt;vim stdio.h 如果有则进入如果没有则创建文件&lt;/p&gt;
&lt;h4&gt;三种模式&lt;/h4&gt;
&lt;h5&gt;命令模式（默认进入）&lt;/h5&gt;
&lt;p&gt;yy复制一行  10yy复制十行&lt;/p&gt;
&lt;p&gt;p粘贴&lt;/p&gt;
&lt;p&gt;dd剪切&lt;/p&gt;
&lt;p&gt;u撤销&lt;/p&gt;
&lt;p&gt;x删除一个字符&lt;/p&gt;
&lt;p&gt;shift g跳到最后一行&lt;/p&gt;
&lt;p&gt;gg回到第一行&lt;/p&gt;
&lt;p&gt;*用于查找&lt;/p&gt;
&lt;p&gt;shift z&lt;/p&gt;
&lt;h5&gt;插入模式（Insert编辑）&lt;/h5&gt;
&lt;p&gt;通过i或者a按键进入，esc退出并进入命令模式&lt;/p&gt;
&lt;h5&gt;底行模式（通过命令模式下进入）：&lt;/h5&gt;
&lt;p&gt;:w保存 q退出 wq保存退出 wq! 强制保存退出&lt;/p&gt;
&lt;p&gt;:10跳到10行&lt;/p&gt;
&lt;p&gt;：nohl消除高亮&lt;/p&gt;
&lt;p&gt;:set nonu 去除行号&lt;/p&gt;
&lt;p&gt;:set nu 加上行号&lt;/p&gt;
&lt;p&gt;:%s/old/new替换&lt;/p&gt;
&lt;p&gt;/进入底行模式用于查找&lt;/p&gt;
&lt;p&gt;如/main&lt;/p&gt;
</content:encoded></item><item><title>关于 Git</title><link>https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/%E5%85%B3%E4%BA%8Egit/</guid><description>Git 学习笔记</description><pubDate>Wed, 15 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git的功能相当于一个游戏的存档功能，可用以代码的管理，正确使用git即可提高编码的效率以及存储安全，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/30.png&quot; alt=&quot;30&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在VScode之中可以通过GUI进行快速的配置与github的git链接，首先用默认的浏览器注册一个GitHub账号，保持账号的登陆状态，按照网络上的教程安装git（详细可参照各大博客上的相关教程）&lt;/p&gt;
&lt;p&gt;再次打开vscode即可在上图的位置看到打开文件夹以及克隆仓库的两个选项，我们选择创建一个文件夹，在文件夹下可以新建一个本地的git仓库，可以自行在仓库中添加一些内容，提交就等价于游戏中保存一个本地存档，而同步相当于提交本地的游戏数据到云端存储，而第一次存储到github中需要按照相关的步骤对本地的环境进行授权操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/31.png&quot; alt=&quot;31&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以上是源代码的管理图，有着代码各个版本的说明以及修改内容介绍，蓝色的代表本地存档，而紫色的代表云存档，二者进度不一定相同，例如提交了本地仓库，但是没有同步至云端。&lt;/p&gt;
&lt;p&gt;在对应的仓库目录下，我们可以在终端使用git log指令查看日志，来检索git提交的版本信息 ，键入q来进行退出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/32.png&quot; alt=&quot;32&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上述我们通过了在本地的初始化建立git仓库，默认提交到了github中，当然我们也可以在GitHub中先建立仓库，然后再远程建立连接，我们先在源代码管理界面的右侧找到三个点...的选项，选择远程，添加远程库，如果你登陆了github账号的话即可自动查找github中的仓库，选取并在后续选择私有或者公有即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/33.png&quot; alt=&quot;33&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>虚拟机代理</title><link>https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86/</guid><description>VMware虚拟机代理</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;第一份正式的博客内容&lt;/h3&gt;
&lt;p&gt;这算是我写的第一份博客，大学时光已经过半，我也想在有限的时间里面留下点什么，希望这一篇推文可以帮助到你:happy:&lt;/p&gt;
&lt;h4&gt;序言&lt;/h4&gt;
&lt;p&gt;和大多数人一样，我在linux安装各种软件包的时候，想到的第一个方法应该是换源，换一个学术的源平台去下载各种各样的包或者软件之类的，但是有的时候镜像资源难免会出现一些缺漏，导致了没有办法正确的找到依赖，而通过代理的方式可以在linux虚拟机下安装各式各样的软件一劳永逸，接下来是我从网络上找寻到的一种方式&lt;/p&gt;
&lt;h4&gt;解决方式（需要主机拥有代理软件）&lt;/h4&gt;
&lt;h5&gt;第一种解决方式：用图形化界面手动设置&lt;/h5&gt;
&lt;p&gt;第一：设置虚拟机（我这里运用的是VMware虚拟机，Ubuntu版本为22.04）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/7.png&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图我们将其中的网络适配器网络连接方式更改成为NAT桥接模式，使虚拟机与宿主机共享同样的的IP地址&lt;/p&gt;
&lt;p&gt;第二：记录主机的IP地址&lt;/p&gt;
&lt;p&gt;在主机上打开终端，键入  ipconfig 查看，其中会打印出很多的网络配置信息，我们重点聚焦于主机的IP地址
&lt;img src=&quot;../images/4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中以太网适配器中的IPv4是我们所需的，将其记录下来：192.168.9.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/6.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第三：开启代理软件获取其端口号（以clash举例，多的我也没有）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中7890就是我们所需要的内容，将其记录下来&lt;/p&gt;
&lt;p&gt;第四：启动linux虚拟机设置并开启网络代理&lt;/p&gt;
&lt;p&gt;在网络代理设置中点击手动（默认为已禁用），此时不更改网络代理的数据的时候是无法正常上网的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/8.png&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下一步为设置两个代理，以及Socks主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/9.png&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中前一个为IP地址：填入主机IP，后一个端口号填入代理端口，保存即可完成虚拟机共享主机代理的设置&lt;/p&gt;
&lt;p&gt;第五：验证代理是否成功&lt;/p&gt;
&lt;p&gt;发现可以正常访问学术网站，linux虚拟机代理成功，同时也可以解决rustc软件包安装失效的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/10.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;
&lt;h5&gt;第二种解决方式：通过命令行配置代理&lt;/h5&gt;
&lt;p&gt;第一：配置代理&lt;/p&gt;
&lt;p&gt;在终端中输入以下指令（ip地址为你自己的，端口号为代理软件的，同第一种解决方式中的一样）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export https_proxy=http://192.168.9.1:7890
export http_proxy=http://192.168.9.1:7890
export ftp_proxy=http://192.168.9.1:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二：配置生效&lt;/p&gt;
&lt;p&gt;安装完成后，我们可以重新打开一个终端来让之前设置的环境变量生效。&lt;/p&gt;
&lt;p&gt;我们也可以手动将环境变量设置应用到当前终端（非永久生效，仅限于当前终端），输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source $HOME/.cargo/env
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结语&lt;/h4&gt;
&lt;p&gt;真诚地希望你的问题在这里得到解决，以上是我写的有关linux虚拟机代理的解决方法&lt;/p&gt;
</content:encoded></item><item><title>My First Post</title><link>https://thrinisty.github.io/posts/thrinisty/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/thrinisty/</guid><description>第一篇博客</description><pubDate>Fri, 15 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h4&gt;关于Thrinisty&lt;/h4&gt;
&lt;h5&gt;欢迎:happy:&lt;/h5&gt;
&lt;p&gt;欢迎来到我的博客网页，在这里我会不定期的更新一些实验中的思路，遇到的问题以及解决方案&lt;/p&gt;
&lt;h5&gt;关于名字&lt;/h5&gt;
&lt;p&gt;为什么要取thrinisty这样的名字，其实这个名字源自于我母亲大人的LOL账号名，又受制于自己起名水平:cry:，故直接将这个称号照搬作为了我的博客名称。&lt;/p&gt;
&lt;h5&gt;尾声&lt;/h5&gt;
&lt;p&gt;总而言之，还是欢迎你来到我的博客，希望你在这里可以找到你想要的东西！！:happy:&lt;/p&gt;
</content:encoded></item><item><title>Markdown Extended Features</title><link>https://thrinisty.github.io/posts/markdown-extended/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown-extended/</guid><description>Read more about Markdown features in Fuwari</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;GitHub Repository Cards&lt;/h2&gt;
&lt;p&gt;You can add dynamic cards that link to GitHub repositories, on page load, the repository information is pulled from the GitHub API.&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;Fabrizz/MMM-OnSpotify&quot;}&lt;/p&gt;
&lt;p&gt;Create a GitHub repository card with the code &lt;code&gt;::github{repo=&quot;&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;&quot;}&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Admonitions&lt;/h2&gt;
&lt;p&gt;Following types of admonitions are supported: &lt;code&gt;note&lt;/code&gt; &lt;code&gt;tip&lt;/code&gt; &lt;code&gt;important&lt;/code&gt; &lt;code&gt;warning&lt;/code&gt; &lt;code&gt;caution&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
Highlights information that users should take into account, even when skimming.
:::&lt;/p&gt;
&lt;p&gt;:::tip
Optional information to help a user be more successful.
:::&lt;/p&gt;
&lt;p&gt;:::important
Crucial information necessary for users to succeed.
:::&lt;/p&gt;
&lt;p&gt;:::warning
Critical content demanding immediate user attention due to potential risks.
:::&lt;/p&gt;
&lt;p&gt;:::caution
Negative potential consequences of an action.
:::&lt;/p&gt;
&lt;h3&gt;Basic Syntax&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;:::note
Highlights information that users should take into account, even when skimming.
:::

:::tip
Optional information to help a user be more successful.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Custom Titles&lt;/h3&gt;
&lt;p&gt;The title of the admonition can be customized.&lt;/p&gt;
&lt;p&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
This is a note with a custom title.
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;GitHub Syntax&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt;The GitHub syntax&lt;/a&gt; is also supported.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; The GitHub syntax is also supported.

&amp;gt; [!TIP]
&amp;gt; The GitHub syntax is also supported.
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Simple Guides for Fuwari</title><link>https://thrinisty.github.io/posts/guide/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/guide/</guid><description>How to use this blog template.</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Cover image source: &lt;a href=&quot;https://image.civitai.com/xG1nkqKTMzGDvpLrqFT7WA/208fc754-890d-4adb-9753-2c963332675d/width=2048/01651-1456859105-(colour_1.5),girl,_Blue,yellow,green,cyan,purple,red,pink,_best,8k,UHD,masterpiece,male%20focus,%201boy,gloves,%20ponytail,%20long%20hair,.jpeg&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This blog template is built with &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. For the things that are not mentioned in this guide, you may find the answers in the &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Front-matter of Posts&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: My First Blog Post
published: 2023-09-09
description: This is the first post of my new Astro blog.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The title of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The date the post was published.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A short description of the post. Displayed on index page.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The cover image path of the post.&amp;lt;br/&amp;gt;1. Start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: Use web image&amp;lt;br/&amp;gt;2. Start with &lt;code&gt;/&lt;/code&gt;: For image in &lt;code&gt;public&lt;/code&gt; dir&amp;lt;br/&amp;gt;3. With none of the prefixes: Relative to the markdown file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The tags of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The category of the post.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If this post is still a draft, which won&apos;t be displayed.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Where to Place the Post Files&lt;/h2&gt;
&lt;p&gt;Your post files should be placed in &lt;code&gt;src/content/posts/&lt;/code&gt; directory. You can also create sub-directories to better organize your posts and assets.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Markdown Example</title><link>https://thrinisty.github.io/posts/markdown/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/markdown/</guid><description>A simple example of a Markdown blog post.</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;An h1 header&lt;/h1&gt;
&lt;p&gt;Paragraphs are separated by a blank line.&lt;/p&gt;
&lt;p&gt;2nd paragraph. &lt;em&gt;Italic&lt;/em&gt;, &lt;strong&gt;bold&lt;/strong&gt;, and &lt;code&gt;monospace&lt;/code&gt;. Itemized lists
look like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this one&lt;/li&gt;
&lt;li&gt;that one&lt;/li&gt;
&lt;li&gt;the other one&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that --- not considering the asterisk --- the actual text
content starts at 4-columns in.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Block quotes are
written like so.&lt;/p&gt;
&lt;p&gt;They can span multiple paragraphs,
if you like.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use 3 dashes for an em-dash. Use 2 dashes for ranges (ex., &quot;it&apos;s all
in chapters 12--14&quot;). Three dots ... will be converted to an ellipsis.
Unicode is supported. ☺&lt;/p&gt;
&lt;h2&gt;An h2 header&lt;/h2&gt;
&lt;p&gt;Here&apos;s a numbered list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;first item&lt;/li&gt;
&lt;li&gt;second item&lt;/li&gt;
&lt;li&gt;third item&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note again how the actual text starts at 4 columns in (4 characters
from the left side). Here&apos;s a code sample:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let me re-iterate ...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you probably guessed, indented 4 spaces. By the way, instead of
indenting the block, you can use delimited blocks, if you like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(which makes copying &amp;amp; pasting easier). You can optionally mark the
delimited block for Pandoc to syntax highlight it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# Quick, count to ten!
for i in range(10):
    # (but not *too* quick)
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;An h3 header&lt;/h3&gt;
&lt;p&gt;Now a nested list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice again how text always lines up on 4-space indents (including
that last line which continues item 3 above).&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.&lt;/p&gt;
&lt;p&gt;Tables can look like this:&lt;/p&gt;
&lt;p&gt;size material color&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;9 leather brown
10 hemp canvas natural
11 glass transparent&lt;/p&gt;
&lt;p&gt;Table: Shoes, their sizes, and what they&apos;re made of&lt;/p&gt;
&lt;p&gt;(The above is the caption for the table.) Pandoc also supports
multi-line tables:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;keyword text&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;red Sunsets, apples, and
other red or reddish
things.&lt;/p&gt;
&lt;p&gt;green Leaves, grass, frogs
and other things it&apos;s
not easy being.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A horizontal rule follows.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Here&apos;s a definition list:&lt;/p&gt;
&lt;p&gt;apples
: Good for making applesauce.
oranges
: Citrus!
tomatoes
: There&apos;s no &quot;e&quot; in tomatoe.&lt;/p&gt;
&lt;p&gt;Again, text is indented 4 spaces. (Put a blank line between each
term/definition pair to spread things out more.)&lt;/p&gt;
&lt;p&gt;Here&apos;s a &quot;line block&quot;:&lt;/p&gt;
&lt;p&gt;| Line one
| Line too
| Line tree&lt;/p&gt;
&lt;p&gt;and images can be specified like so:&lt;/p&gt;
&lt;p&gt;[//]: # &quot;![example image](./demo-banner.png &quot;An exemplary image&quot;)&quot;&lt;/p&gt;
&lt;p&gt;Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters
which you wish to be displayed literally, ex.: `foo`, *bar*, etc.&lt;/p&gt;
</content:encoded></item><item><title>Include Video in the Posts</title><link>https://thrinisty.github.io/posts/video/</link><guid isPermaLink="true">https://thrinisty.github.io/posts/video/</guid><description>This post demonstrates how to include embedded video in a blog post.</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Just copy the embed code from YouTube or other platforms, and paste it in the markdown file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item></channel></rss>